<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeal-up.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="⭐ Zeal&#39;s Blog 🛠 Zeal&#39;s 知乎专栏 🌀 Zeal&#39;s Github  前言 ORB-SLAM系列使用FAST关键点提取+ORB特征描述子做跟踪、重定位、回环检测。在ORB-SLAM几篇论文中，图像特征提取部分都是一带而过，基本没有详细说明特征提取的方法。但是在实际的代码实现中，这部分内容其实还是做了不少工作的。Opencv中已经对ORB特征提取进行了实现：OpenCV-o">
<meta property="og:type" content="article">
<meta property="og:title" content="ORB-SLAM3保姆级教程——详解特征点提取">
<meta property="og:url" content="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/index.html">
<meta property="og:site_name" content="Zeal&#39;s Blog">
<meta property="og:description" content="⭐ Zeal&#39;s Blog 🛠 Zeal&#39;s 知乎专栏 🌀 Zeal&#39;s Github  前言 ORB-SLAM系列使用FAST关键点提取+ORB特征描述子做跟踪、重定位、回环检测。在ORB-SLAM几篇论文中，图像特征提取部分都是一带而过，基本没有详细说明特征提取的方法。但是在实际的代码实现中，这部分内容其实还是做了不少工作的。Opencv中已经对ORB特征提取进行了实现：OpenCV-o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/imgs/01-FAST_segment_test.jpg">
<meta property="og:image" content="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/imgs/02-BRIEF_blur.png">
<meta property="og:image" content="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/imgs/03-intensity_centroid.png">
<meta property="og:image" content="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/imgs/A-01-decisiontree.png">
<meta property="article:published_time" content="2023-05-18T08:58:39.000Z">
<meta property="article:modified_time" content="2023-07-07T02:06:50.122Z">
<meta property="article:author" content="Zeal">
<meta property="article:tag" content="slam">
<meta property="article:tag" content="图像特征点">
<meta property="article:tag" content="SLAM_Theory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/imgs/01-FAST_segment_test.jpg">


<link rel="canonical" href="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/","path":"2023/05/18/orbslam/orbslam3-ORBextractor/","title":"ORB-SLAM3保姆级教程——详解特征点提取"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ORB-SLAM3保姆级教程——详解特征点提取 | Zeal's Blog</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SE75EDBKX6","only_pageview":true}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/zeal-up" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zeal's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习～天天向上～</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#orb-slam%E4%B8%AD%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E7%82%B9%E5%85%B7%E6%9C%89%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">1.1.</span> <span class="nav-text">ORB-SLAM中图像特征点具有的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E6%82%9F"><span class="nav-number">1.2.</span> <span class="nav-text">感悟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87"><span class="nav-number">1.3.</span> <span class="nav-text">本文结构组织</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#orb%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">ORB特征描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fast%E5%85%B3%E9%94%AE%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">FAST关键点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fast%E8%A7%92%E7%82%B9%E6%8F%90%E5%8F%96"><span class="nav-number">2.1.1.</span> <span class="nav-text">FAST角点提取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95%E7%A1%AE%E5%AE%9A16%E4%B8%AA%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">用机器学习的方法确定16个点的检查顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6non-maximal-suppression"><span class="nav-number">2.1.3.</span> <span class="nav-text">最大值抑制（Non-maximal Suppression）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#brief%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E5%AD%90"><span class="nav-number">2.2.</span> <span class="nav-text">BRIEF特征描述子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rbrief%E6%8F%8F%E8%BF%B0%E5%AD%90"><span class="nav-number">2.3.</span> <span class="nav-text">rBRIEF描述子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94"><span class="nav-number">2.4.</span> <span class="nav-text">图像金字塔</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#orb-slam-%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E7%9A%84orb%E7%89%B9%E5%BE%81%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">ORB-SLAM 均匀分布的ORB特征点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%87%E5%88%86%E5%88%87%E5%89%B2%E6%B3%95orb-slam1%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">均分切割法（ORB-SLAM1中使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%8F%89%E6%A0%91%E5%88%86%E9%85%8D%E6%B3%95orb-slam2%E5%8F%8A%E4%B9%8B%E5%90%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">四叉树分配法（ORB-SLAM2及之后使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="nav-number">3.3.</span> <span class="nav-text">实现中的一些细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">完整代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95a%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">附录A——决策树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9"><span class="nav-number">5.1.</span> <span class="nav-text">特征选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%B5entropy"><span class="nav-number">5.2.</span> <span class="nav-text">熵（Entropy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8Ainformation-gain"><span class="nav-number">5.3.</span> <span class="nav-text">信息增益（Information gain）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81id3%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">伪代码（ID3算法）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zeal</p>
  <div class="site-description" itemprop="description">学习记录及分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ORB-SLAM3保姆级教程——详解特征点提取 | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ORB-SLAM3保姆级教程——详解特征点提取
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-18 16:58:39" itemprop="dateCreated datePublished" datetime="2023-05-18T16:58:39+08:00">2023-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-07 10:06:50" itemprop="dateModified" datetime="2023-07-07T10:06:50+08:00">2023-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Orbslam/" itemprop="url" rel="index"><span itemprop="name">Orbslam</span></a>
        </span>
    </span>

  
    <span id="/2023/05/18/orbslam/orbslam3-ORBextractor/" class="post-meta-item leancloud_visitors" data-flag-title="ORB-SLAM3保姆级教程——详解特征点提取" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="ORB-SLAM3保姆级教程——详解特征点提取" href="/2023/05/18/orbslam/orbslam3-ORBextractor/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::a2b00e2b2d77cb00c0a5bbc2d15a6dd4" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>ORB-SLAM系列使用<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">FAST</a>关键点提取+ORB特征描述子做跟踪、重定位、回环检测。在ORB-SLAM几篇论文中，图像特征提取部分都是一带而过，基本没有详细说明特征提取的方法。但是在实际的代码实现中，这部分内容其实还是做了不少工作的。Opencv中已经对ORB特征提取进行了实现：<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/4.7.0/modules/features2d/src/orb.cpp">OpenCV-orb.cpp</a>。在ORB的原始论文：<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ICCV.2011.6126544">ORB: an efficient alternative to SIFT or SURF</a>已经考虑到了特征点提取的多尺度问题，使用图像金字塔的方式对多个尺度的图像进行ORB特征提取。但是在ORB-SLAM系列中，为了让特征点分散更加均匀，ORB-SLAM的作者根据OpenCV的实现进行了修改，让特征点尽可能地分散到图片的整个区域而不是只有在纹理明显的区域有特征点。不仅如此，在ORB-SLAM1和ORB-SLAM2及之后的代码，对于特征点平均分布的实现还有所不同，可见ORB-SLAM是在不断的迭代改进中成熟的。</p>
<h3 id="orb-slam中图像特征点具有的性质">ORB-SLAM中图像特征点具有的性质</h3>
<ol type="1">
<li>尺度不变性（ORB本身具有的特点）</li>
<li>旋转不变性（ORB本身具有的特点）</li>
<li>分布均匀（ORB-SLAM的实现）</li>
</ol>
<h3 id="感悟">感悟</h3>
<p>看完了ORB-SLAM3中关于特征提取的实现代码，深感做科研和算法的不易。在论文中轻轻带过的几句话在实现中就需要两千多行代码（虽然大部分是基于OpenCV的实现）。另外，在ORBSLAM1中为了实现特征点的均匀分布，是将图像切割成与特征点数量成比例的小区块，每个区块提取5个特征点，点数不够的区块由其他区块补足，但是从ORBSLAM2后，这部分的实现变成用四叉树分割图像。这部分的改进应该更多是为了效率考虑，具体效率还没有进行测试。</p>
<h3 id="本文结构组织">本文结构组织</h3>
<p>本文首先对ORB特征提取做一个详细的介绍，说清楚FAST关键点和BRIEF特征以及rBRIEF特征；然后说明白ORB-SLAM中为了将特征点尽可能均匀地分布到图像中进行的两种实现。</p>
<h2 id="orb特征描述">ORB特征描述</h2>
<p>论文：<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ICCV.2011.6126544">ORB: an efficient alternative to SIFT or SURF</a></p>
<p>图像的特征描述一般有两个步骤：</p>
<ol type="1">
<li>关键点的选取。经典的有<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/dc/d0d/tutorial_py_features_harris.html">Harris Corner</a>，ORB中使用的是<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">FAST</a>角点检测</li>
<li>关键点特征描述子。经典的描述子很多，比如SIFT等。ORB中使用的是改进后的BRIEF描述子，具有角度不变形，叫做rBRIEF</li>
</ol>
<h3 id="fast关键点">FAST关键点</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">OpenCV FAST Corner Detection</a> 论文：<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1007/11744023_34">Machine learning for high-speed corner detection</a></p>
<p>FAST(Features from Accelerated Segment Test) 在论文 <em><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1007/11744023_34">Machine learning for high-speed corner detection</a></em> 中被提出。 相比于其他角点检测，比如<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/dc/d0d/tutorial_py_features_harris.html">Harris Corner</a>或者SIFT的角点检测过程<em>DoG</em> 都要更快，更适合应用到实时性要求高的任务，比如SLAM中。</p>
<h4 id="fast角点提取">FAST角点提取</h4>
<p>FAST角点的核心思想是对于像素<span class="math inline">\(p\)</span>，如果<span class="math inline">\(p\)</span>与其周围的像素值差异比较大，则认为<span class="math inline">\(p\)</span>是一个角点。</p>
<figure>
<img src="./imgs/01-FAST_segment_test.jpg" alt="" /><figcaption>图1：FAST角点提取示例图</figcaption>
</figure>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>在图像中选择一个像素<span class="math inline">\(p\)</span>，令其像素值为<span class="math inline">\(I_p\)</span></li>
<li>以<span class="math inline">\(p\)</span>为中心，往上下左右扩张3个像素值，并以<span class="math inline">\(p\)</span>为中心画圆，以对称的方式选择圆上16个像素。如上图所示</li>
<li>选择一个阈值<span class="math inline">\(t\)</span>，如果第二步中的16个像素有连续<span class="math inline">\(n\)</span>（<span class="math inline">\(n\)</span>一般为12）个像素的值都大于<span class="math inline">\(I_p+t\)</span>或者小于<span class="math inline">\(I_p-t\)</span>，则认为<span class="math inline">\(p\)</span>是角点</li>
<li><strong>快速测试</strong>。执行第3步前可以执行一种快速测试的方法：先测试点1和点9，如果这两个点与<span class="math inline">\(p\)</span>的像素值差都小于<span class="math inline">\(t\)</span>, 则<span class="math inline">\(p\)</span>不可能是角点，否则继续测试点5和点13。只有当1、5、9、13这4个点中至少有3个点与<span class="math inline">\(p\)</span>的像素差大于阈值<span class="math inline">\(t\)</span>才进行第3步的检测。</li>
</ol>
<p>上面这种判断方法叫做<code>Segment Test</code></p>
<h4 id="用机器学习的方法确定16个点的检查顺序">用机器学习的方法确定16个点的检查顺序</h4>
<p>使用上面的16个点的顺序检查不一定是最好的，所以在论文中使用了机器学习的方法确定这16个点的检查顺序。具体来说，这里面用了决策树来在训练集上进行训练，得到一个训练好的决策树。这个决策树用来对其他图片的点做判断是否采纳为角点。阅读这部分内容需要决策树的基础知识，否则很难看懂这部分内容（虽然很简单）。</p>
<p><code>PS:如果不清楚决策树是什么或者不清楚决策树构建过程的读者要先阅读文末的附录A</code><a href="#appendA">附录A</a></p>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>为目标域选择一个训练集</li>
<li>为训练集中的所有图片的所有像素计算圆圈的16个点（见图1）的像素值</li>
<li>对于像素<span class="math inline">\(p\)</span>，其旁边的16个点中的每一个像素<span class="math inline">\(x\)</span>可以根据下面的关系划分为3个状态</li>
</ol>
<p><span class="math display">\[
S_x =
\begin{cases}
    d, &amp; I_x \leq I_p - t &amp;         \text{(darker)}\\
    s, &amp; I_p - t &lt; I_x &lt; I_p + t &amp;  \text{(similar)}\\
    b, &amp; I_p+t \leq I_x &amp;           \text{(brighter)}
\end{cases}    
\]</span></p>
<ol start="4" type="1">
<li>这样子，每个像素就可以得到一个长度为16的特征向量，类似<code>[ddddddssbbbbddss]</code></li>
<li>使用上文中的<code>Segment test</code>的方法确定训练集中的角点（也就是为每个像素赋予了是否是角点的标签），令标签为<span class="math inline">\(K_p\)</span></li>
<li>定义数据集<span class="math inline">\(S\)</span>的熵如下：</li>
</ol>
<p><span class="math display">\[
H(S) = (c+\bar{c})log_2(c+\bar{c}) - clog_2c - \bar{c}log_2\bar{c}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(c\)</span> 指数据集中的角点数量</li>
<li><span class="math inline">\(\bar{c}\)</span> 指非角点的数量</li>
</ul>
<p>上面这个公式其实就是用熵的公式(A-1)计算出来的，相差一个常量而已</p>
<ol start="7" type="1">
<li>构建决策树，对于16个点中的每一个点<span class="math inline">\(x\)</span>，数据集可以分成三个子集（根据第3个步骤，每个点的特征是一个长度为16的向量）<span class="math inline">\(P_d,P_s,P_b\)</span>。对于构建决策树的过程，信息增益可以定义为如下公式：</li>
</ol>
<p><span class="math display">\[
IG(x) = H(P) - H(P_d) - H(P_s) - H(P_b)
\]</span></p>
<p>上面的公式与附录A中的公式(A-2)基本相同，不过少了每个子集的概率。</p>
<p>构建完决策树后对于新的角点，则可以直接使用决策树判定是否是角点。</p>
<h4 id="最大值抑制non-maximal-suppression">最大值抑制（Non-maximal Suppression）</h4>
<p>跟很多的角点监测器一样，需要增加最大值抑制取出相邻的角点。</p>
<h3 id="brief特征描述子">BRIEF特征描述子</h3>
<p>论文：<a target="_blank" rel="noopener" href="https://www.cs.ubc.ca/~lowe/525/papers/calonder_eccv10.pdf">Binary Robust Independent Elementary Features</a> 参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/dc/d7d/tutorial_py_brief.html">OpenCV BRIEF</a></p>
<p>BRIEF(Binary Robust Independent Elementary Features)，区别于其他很多描述子，BRIEF特征描述子使用二进制向量的形式作为特征的表达。一般是256位二进制向量，也就是只需要32字节（32x8=256）。</p>
<p><img src="./imgs/02-BRIEF_blur.png" alt="BRIEF描述子示意" /> 上图来源：https://www.cnblogs.com/alexme/p/11345701.html</p>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>先对图像进行高斯模糊，去除高频噪声对特征的干扰</li>
<li>在选择的关键点附近选取一个圆形范围;圆形范围的选择一般是以关键点为中心，边长为31个像素的正方形的内接圆</li>
<li>在圆内随机挑选点对，点对里第一个点像素值如果大于第二个点的像素值，则描述子对应位的值为1,否则为0</li>
<li>重复第3步，直到描述子长度符合要求（256位需要挑选256个点对）</li>
</ol>
<p><strong>特殊之处</strong></p>
<ol type="1">
<li>点对的挑选策略其实是有很多的，比如均匀分布采样、高斯分布采样、完全随机采样等，[BRIEF的原始论文][#BRIEF]里也有对这些采样方法举例;但是在ORB的论文<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ICCV.2011.6126544">ORB: an efficient alternative to SIFT or SURF</a>里，采用的是一种机器学习的方法来确定点对的挑选顺序，大概意思就是用不同的点对挑选顺序构建多个特征数据集，然后计算这些数据集的方差、特征的平均值，挑选出一种采样方法使得方差较大、平均值接近0.5的挑选顺序。<strong>另外要注意的是， 在OpenCV的视线中，256个点对的挑选顺序是硬编码进<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L380">代码</a>，ORB-SLAM也采用的是OpenCV的实现方式</strong></li>
<li>正方形内接圆的计算由于是在像素层面（离散）计算，为了保证对称性，计算的方式是先算0-45度角内的圆边界，然后对称到90度，再算到整个圆。这部分也可以参看<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L860-L876">OpenCV的实现</a></li>
</ol>
<h3 id="rbrief描述子">rBRIEF描述子</h3>
<p>BRIEF描述子的缺点是对旋转敏感。在做特征点配对过程中，我们希望的是特征描述子是与旋转无关的。为了解决BRIEF描述子对旋转敏感的问题，在ORB特征提取中加入了局部旋转计算操作，将局部图像旋转到主方向之后再计算BRIEF特征，称为<code>rBRIEF</code></p>
<p>局部旋转角（计算BRIEF特征计算时图像块的旋转）采用的方法叫<code>灰度质心法（intensity centroid)</code>，实现也十分简单，就是根据像素值计算图像块的质心<span class="math inline">\((m_{10}, m_{01})\)</span>，质心与几何中心的连线的方向就作为图像块的方向。公式如下：</p>
<figure>
<img src="./imgs/03-intensity_centroid.png" alt="" /><figcaption>灰度质心法计算图像块方向</figcaption>
</figure>
<p>计算出图像的方向后，在计算BRIEF特征描述子的时候，先将区块根据主方向旋转，然后再计算BRIEF特征。但是实现起来会显得很巧妙。<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L245-L250">OpenCV-ORB-旋转操作</a></p>
<h3 id="图像金字塔">图像金字塔</h3>
<p>为了提取出的特征点能够在多个尺度进行匹配，ORB特征提取采用图像金字塔的方式，将原始图像以一定层级缩放，在缩放后的图像后进行特征点提取（角点检测+描述子）。然后将所有特征点坐标放缩回原始分辨率图像坐标。这样得出的特征点就具有了尺度信息。 <a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L1128">Opencv-ORB-imagePyramid</a></p>
<h2 id="orb-slam-均匀分布的orb特征点">ORB-SLAM 均匀分布的ORB特征点</h2>
<p>ORB-SLAM中对于图像的特征提取，除了应用ORB特征提取器之外，还额外增加了让特征点尽量在图像中分布均匀的举措。</p>
<p><strong>在ORB-SLAM1中的实现：</strong> 将原始图像平均分成n/5个区块，n是特征点的数量。每个区块进行FAST特征点和rBRIEF描述子计算;特征点数量不足5的区块剩下的特征点平均分到其他区块。其他区块不足以补充的继续将不足的特征点再分到其他区块中，直到所有特征点数量分完。</p>
<p><strong>在ORB-SLAM2及之后的实现：</strong> 采用四叉树的方法，上下左右分割图像块，直到图像块数量等于目标特征点数量或者块中只有一个特征点则停止分割。</p>
<p>下面详解这两种实现</p>
<h3 id="均分切割法orb-slam1中使用">均分切割法（ORB-SLAM1中使用）</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/ORB_SLAM3_ROS2/blob/f18e41de580a2dbbd9bf00a186a53e7a12fb09fe/src/ORB/ORBextractor.cpp#LL1205C6-L1205C39">代码：ORBextractor::ComputeKeyPointsOld</a></p>
<p><strong>算法步骤：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">提前计算好每一层需要的关键点数量（根据图像金字塔放缩比例等比例分配）</span><br><span class="line">同时提前放缩图片计算图像金字塔</span><br><span class="line">对于每一层的图像单独进行特征点提取</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">1. 当前层的特征点数量nDesiredFeatures</span><br><span class="line">2. 当前金字塔层的图像img</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1. 均匀分布的关键点</span><br><span class="line"></span><br><span class="line">算法：</span><br><span class="line">1. 计算图像的长宽比例:imageRatio = img.width / img.height</span><br><span class="line">2. 计算应该切成多少个块</span><br><span class="line">    patchNumCols = sqrt(nDesiredFeatures / (5*imageRatio))</span><br><span class="line">    patchNumRows = imageRatio * patchNumCols</span><br><span class="line">3. 遍历图像块</span><br><span class="line">    3.1 对当前图像块提取FAST角点</span><br><span class="line">    3.2 如果FAST角点数量小于等于3,降低FAST角点阈值，重新提取FAST角点</span><br><span class="line">4. 分配关键点：while（当分配好的关键点总数小于目标数量）</span><br><span class="line">    4.1 根据缺少的关键点数量计算剩余区块每块需要分配多少关键点</span><br><span class="line">    4.2 遍历还有剩余关键点的图像块</span><br><span class="line">        4.2.1 如果该图像块剩余关键点数量小于需要分配的数量，标记该区块不许再次遍历，累计缺少的数量</span><br><span class="line">        4.2.2 如果该图像块剩余关键点数量大于需要分配的数量，不处理</span><br><span class="line">5. 经过第4步之后，计算出了每个图像块需要保留的关键点数量</span><br><span class="line">6. 遍历图像块，对图像块中的关键点分数排序，保留需要的关键点</span><br><span class="line">7. 将关键点坐标（原本是在图像切割的区块计算）还原到图像坐标系</span><br><span class="line">8. 计算关键点的角度（使用灰度质心法）</span><br></pre></td></tr></table></figure>
<h3 id="四叉树分配法orb-slam2及之后使用">四叉树分配法（ORB-SLAM2及之后使用）</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/ORB_SLAM3_ROS2/blob/f18e41de580a2dbbd9bf00a186a53e7a12fb09fe/src/ORB/ORBextractor.cpp#L1028">代码：ORBextractor::ComputeKeyPointsOctTree</a></p>
<p><strong>算法步骤：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">提前计算好每一层需要的关键点数量（根据图像金字塔放缩比例等比例分配）</span><br><span class="line">同时提前放缩图片计算图像金字塔</span><br><span class="line">对于每一层的图像单独进行特征点提取</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">1. 当前层的特征点数量nDesiredFeatures</span><br><span class="line">2. 当前金字塔层的图像img</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1. 均匀分布的关键点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算法步骤：</span><br><span class="line">1. 将图像分割成35x35像素的图像块，并对这些图像块做FAST角点提取</span><br><span class="line">2. 将原始图像从横轴方向分成尽可能正方形的区块。比如横轴和纵轴的比例是2：1则分成两个正方</span><br><span class="line">3. 将第一步提取的FAST角点根据x坐标分到第二步的区块中</span><br><span class="line">4. 将根节点（也就是第2步分割出来的区块）放入节点列表中</span><br><span class="line">5. 遍历节点列表</span><br><span class="line">    5.1 如果这个节点只剩下一个关键点，则停止分裂</span><br><span class="line">    5.2 如果总共的区块数已经达到要求的关键点数量，则停止分裂</span><br><span class="line">    5.3 将当前节点分裂成上下左右四个区域</span><br><span class="line">    5.4 如果分裂出的区块不包含关键点，则抛弃，否则放入节点列表中</span><br><span class="line">    5.5 从节点列表中删除当前节点</span><br><span class="line">6. 遍历节点列表，保留响应值最大的一个关键点</span><br><span class="line">7. 将关键点的坐标还原到图像坐标系</span><br><span class="line">8. 计算所有关键点的方向</span><br></pre></td></tr></table></figure>
<h3 id="实现中的一些细节">实现中的一些细节</h3>
<p>在这部分的实现中，有用到一些trick，这里顺便做一下记录：</p>
<ol type="1">
<li>四叉树分裂的过程并没有使用递归的方式实现，用递归的方式实现看起来代码可能简单很多，但是用for循环可能在效率上更快</li>
<li>在分裂的过程中会判断下一次分裂后节点的数量是否可能会大于目标特征点数量，如果会的话会进入另一个循环。但是仔细看实现后，感觉这部分逻辑是可以简化的。</li>
<li>实际实现并没有上面算法过程看起来这么“干净”。为了确保算出来的特征点可以计算出特征（rBRIEF特征需要在关键点周围扩展出31像素的正方形），需要在原始图像往内收缩一定的像素，在收缩后的区域进行关键点提取。同时，FAST角点需要在像素周围扩展3个像素，所以又需要往外扩展3个像素，确保能够正确计算FAST角点。这些内容细节单纯靠论文或者讲解是很难体会到的，只有亲自看一遍代码才知道这里面的奥妙。</li>
</ol>
<h2 id="完整代码">完整代码</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/ORB_SLAM3_ROS2/blob/main/src/ORB/ORBextractor.cpp">ORB_SLAM3_ROS2-ORBextractor</a></p>
<p><strong>默认参数：</strong></p>
<ol type="1">
<li>特征点数量：1000</li>
<li>图像金字塔层数：8</li>
<li>每层的缩放系数：1.2</li>
<li>ORB特征Patch大小：31（与原始ORB一致）</li>
<li>ORB特征计算的点对选取：与OpenCV实现相同（提前选定的固定的点对序列）</li>
</ol>
<h2 id="附录a决策树">附录A——决策树</h2>
<div id="appendA">

</div>
<p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ID3_algorithm">维基百科-ID3决策树</a></p>
<figure>
<img src="./imgs/A-01-decisiontree.png" alt="" /><figcaption>决策树</figcaption>
</figure>
<p>决策树（Decision Tree）在传统机器学习中是一种常见的分类方法。决策树是一种监督学习方法，需要在数据集上训练。 决策树构建一个树状结构用来分类。决策树中包含一个根节点、若干个内部节点和若干个叶节点</p>
<ul>
<li>每个内部节点表示对某一个属性进行判断分类。每个内部节点产生的分支数量是这个属性的可能取值的数量</li>
<li>每个叶节点代表一种分类结果</li>
</ul>
<p>在训练时，用数据集决定每一个内部节点应该采用哪一个属性进行分支，直到产生的节点里面的数据都是同一种类。</p>
<p>在预测时，根据训练好的决策树，对输入的样本按照决策树的顺序，根据属性进行分类，直到叶子节点。每个叶子节点对应一种 分类结果，走到叶子节点也就意味着成功进行分类。</p>
<h3 id="特征选择">特征选择</h3>
<p>如何在每一步决定要用哪个特征进行判断是决策树算法中难点。不同的算法会使用不同的策略根据训练集选择特征。这里主要介绍<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ID3_algorithm">ID3算法</a>, 这也是<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">FAST</a>中使用的决策树算法。</p>
<h3 id="熵entropy">熵（Entropy）</h3>
<p>熵表示不确定性，也是信息量的大小。熵大代表不确定性高，信息量也大。</p>
<p>对于数据集<span class="math inline">\(S\)</span>，熵的定义如下：</p>
<p><span class="math display">\[
H(S) = - \sum_{x \in X}p(x)log_2p(x)\tag{A-1}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(S\)</span>指数据集;在ID3迭代构建决策树的时候，S指的是当前的节点分配到的数据</li>
<li><span class="math inline">\(X\)</span>指总共的类别数量</li>
<li><span class="math inline">\(p(x)\)</span>指类别<span class="math inline">\(x\)</span>占<span class="math inline">\(S\)</span>总数的比例（概率）</li>
</ul>
<h3 id="信息增益information-gain">信息增益（Information gain）</h3>
<p>选择特征的时候，我们希望选择的特征能够最好地划分数据集，也就是带来最多的信息增益。 信息增益<span class="math inline">\(IG(A)\)</span>表示使用属性<span class="math inline">\(A\)</span>对数据集<span class="math inline">\(S\)</span>进行划分前后熵的减少量。也就是使用属性<span class="math inline">\(A\)</span>对数据集进行划分时，有 多少不确定性减少了。</p>
<p><span class="math display">\[
IG(S,A) = H(S) - \sum_{t\in T}p(t)H(t) = H(S) - H(S|A)\tag{A-2}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(T\)</span> 指由属性<span class="math inline">\(A\)</span>将集合<span class="math inline">\(S\)</span>划分成多少个集合，也就是属性<span class="math inline">\(A\)</span>的可能取值数量。<span class="math inline">\(S = \cup_{t\in T}t\)</span></li>
<li><span class="math inline">\(p(t)\)</span>指子集<span class="math inline">\(t\)</span>占<span class="math inline">\(S\)</span>的比例</li>
<li><span class="math inline">\(H(t)\)</span>指子集<span class="math inline">\(t\)</span>的熵，计算方式与公式(A-1)一样</li>
</ul>
<p><strong>PS: 要区分数据集的类别<span class="math inline">\(X\)</span>和根据属性划分的集合<span class="math inline">\(T\)</span>；数据集的类别是我们要将每个样本打上的标签，无论是哪个子集，类别数都是一样的。 但是不同的属性可能有不同的可能取值数量，比如属性<span class="math inline">\(A\)</span>可能取值<span class="math inline">\(1,2,3\)</span>，那么就会划分出三个不同的子集;属性<span class="math inline">\(B\)</span>可能取值<span class="math inline">\(0,1\)</span>，那么就会 划分出两个子集</strong></p>
<h3 id="伪代码id3算法">伪代码（ID3算法）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createID3Tree</span>(<span class="params">dataSet, attributeIndices</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建决策树</span></span><br><span class="line"><span class="string">    @input dataset NxM的矩阵，N是样本的数量，每一列的最后一位是样本的类别出，属性数量共有M-1个</span></span><br><span class="line"><span class="string">    @attributeIndices (M-1,1) 保存当前的数据集中的属性在原始属性中的索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    如果dataset中所有的数据属于同一个类别，当前节点的类别就是数据中的类别，直接返回；</span><br><span class="line"></span><br><span class="line">    如果attributeIndices中已经没有属性，也就是遍历完所有属性，选择数据集中占主要的类别作为当前节点类别，返回；</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历属性列表，根据信息增益选择信息增益最大的属性 -----------------------------------</span></span><br><span class="line">    计算数据集的熵H(S)</span><br><span class="line">    bestInfoGain = <span class="number">0</span></span><br><span class="line">    bestFeatAttrIdx = -<span class="number">1</span>    <span class="comment"># 最有的属性索引</span></span><br><span class="line">    <span class="keyword">for</span> attributeIdx <span class="keyword">in</span> attributeIndices:</span><br><span class="line">        featList = [sample[attributeIdx] <span class="keyword">for</span> sample <span class="keyword">in</span> dataSet]</span><br><span class="line">        featValSet = <span class="built_in">set</span>(featList)  <span class="comment"># 获取属性的所有可能取值</span></span><br><span class="line">        newEntropy = <span class="number">0</span>  <span class="comment"># 计算在当前属性的划分下的信息熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> featValSet:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, attributeIdx, value) <span class="comment"># 获取数据集的当前属性等于value的子集</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">len</span>(dataSet)   <span class="comment"># 子集占据数据集的比例</span></span><br><span class="line">            newEntropy += prob * H(subDataSet)      <span class="comment"># 公式（A-2)</span></span><br><span class="line">        infoGain = H(S) - newEntropy</span><br><span class="line">        <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeatAttrIdx = attributeIdx</span><br><span class="line">    <span class="comment"># bestFeatAttrIdx 是选择出的用来当前节点做切分的属性索引 ---------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用最有的属性切分数据集</span></span><br><span class="line">    subTree = &#123;bestFeatAttrIdx:&#123;&#125;&#125;</span><br><span class="line">    从attributeIndices中删除掉bestFeatAttrIdx</span><br><span class="line">    featValSet = 当前属性的所有可能取值</span><br><span class="line">    <span class="comment"># 递归计算决策树</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> featValSet:</span><br><span class="line">        subTree[bestFeatAttrIdx][value] = createID3Tree(splitDataSet(dataSet, bestFeatAttrIdx, value), attributeIndices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subTree</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Zeal
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/" title="ORB-SLAM3保姆级教程——详解特征点提取">https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/slam/" rel="tag"># slam</a>
              <a href="/tags/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E7%82%B9/" rel="tag"># 图像特征点</a>
              <a href="/tags/SLAM-Theory/" rel="tag"># SLAM_Theory</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/19/sensors/AllanVariance/" rel="prev" title="惯性测量单元Allan方差分析详解">
                  <i class="fa fa-chevron-left"></i> 惯性测量单元Allan方差分析详解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/05/29/slam-theory/MAP2LSP_01/" rel="next" title="SLAM基础——如何从最大后验概率到最小二乘（理论篇）">
                  SLAM基础——如何从最大后验概率到最小二乘（理论篇） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="SOHUCS" sid="a2b00e2b2d77cb00c0a5bbc2d15a6dd4"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"covS4Q3Q0SaMRjqI2VomagVm-gzGzoHsz","app_key":"iK7kdlu4InjORoPr3oksi1IM","server_url":"https://covs4q3q.lc-cn-n1-shared.com","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywzGuJ0w","appkey":"7c4a236bb42c7db38424a76bf68ccf99","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
