<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeal-up.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录及分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeal&#39;s Blog">
<meta property="og:url" content="https://zeal-up.github.io/archives/index.html">
<meta property="og:site_name" content="Zeal&#39;s Blog">
<meta property="og:description" content="学习记录及分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeal">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeal-up.github.io/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeal's Blog</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeal's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习～天天向上～</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zeal</p>
  <div class="site-description" itemprop="description">学习记录及分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——特征提取模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-22 20:03:12 / 修改时间：21:32:33" itemprop="dateCreated datePublished" datetime="2023-03-22T20:03:12+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——特征提取模块" href="/2023/03/22/lio_sam/featureExtraction-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::e84bd67344741c4da21c259e3e444c5d" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>、<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法，从原始点云中提取出边缘点和平面点。边缘点和平面点被下游模块用来做点云匹配和构建地图。 特征提取模块是比较简单的模块，只监听来自<code>imageProjection</code>发布出来的去畸变后点云，同时将提取特征后的点云发布出去。这里有几点需要注意：</p>
<ol type="1">
<li>特征点的提取根据点的平滑度，而平滑度则通过每个点与周围点距离的平均值做近似</li>
<li>实际上在提取完边缘点和平面点之后，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>在代码里又把所有非边缘点的点都加入了平面点集合。这是比较奇怪的地方。从这里看出也许特征提取也不是必要的， 因为平面点已经包含了大部分的点云。事实上，在Github的一个仓库<a target="_blank" rel="noopener" href="https://github.com/YJZLuckyBoy/liorf" title="Based LIO-SAM, remove featureExtraction">liorf</a>中，就将特征提取模块去掉。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该段中除了角点之外的点加入平面点集合</span></span><br><span class="line"><span class="comment">// ！！！ 这点让步骤2感觉是多余的，最终的结果可能只是原始点云降采样，可能特征点提取也是没有必要的！！！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        surfaceCloudScan-&gt;<span class="built_in">push_back</span>(extractedCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>cloudLabel</code>标识该点的性质，-1为平面点，0为非特征点，1为边缘点。</li>
</ol>
<h2 id="特征点提取原理">特征点提取原理</h2>
<p>关于特征点提取部分<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的论文基本略过，因为跟<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>和<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法基本相同，这里建议这部分可以阅读<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>论文。</p>
<h3 id="转换到rangemat">转换到RangeMat</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法，先把三维点全部投影到二维图片，图像像素保存每个点距离原点的距离，称做<code>RangeMat</code>，<code>RangeMat</code>是规则的，每一行代表一条激光线束扫射360度所产生的点，因此后面用这个<code>RangeMat</code>做特征提取更快速更简单。 PS：这部分是在<code>ImageProjection</code>就已经处理好，并且<code>RangeMat</code>也被展开成一维向量存储。</p>
<h3 id="平滑度估计">平滑度估计</h3>
<p>特征点提取通过每个点的平滑度来提取，平滑度高于某个阈值的认为是边缘点；平滑度小于某个阈值的认为是平面点。 而平滑度的估计则通过每一个点在该激光线成像的前后几个点的平均距离代替。 我们另时间<span class="math inline">\(t\)</span>的点云为<span class="math inline">\(P_t = \{p_i, i \in |P_t|\}\)</span>，同时我们可以根据每个点的坐标算出每个点距离原点的距离<span class="math inline">\(r_i\)</span>，对于每个点，我们取其同一条激光线上前后5个点构成集合<span class="math inline">\(S\)</span>，则，点<span class="math inline">\(p_i\)</span>的平滑度可以这样计算： <span class="math display">\[
c = \frac{1}{|S|\cdot||r_i||}\left|\left|\sum_{j\in S,j\neq i}(r_j-r_i)\right|\right|
\]</span></p>
<h3 id="分段提取及特征点数量数量限制">分段提取及特征点数量数量限制</h3>
<p>为了让特征点分布更均匀，采用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>，将整个360的图像在水平方向分成6个子图像，在每个子图像中进行特征点提取。并且，对于每一个子图像中的每一条激光线束，会限制边缘点数量不超过20个，平面点的数量则没有限制。</p>
<h3 id="特殊情况">特殊情况</h3>
<p>有3种特殊情况不能将该点设置为边缘点。 1. 当一个点被选择为特征点，则把该点左右5个点都排除在特征点选取范围 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对该角点左右各5个点，如果两点之间的列索引差距小于10，则抛弃周围的点，避免重复对同一块区域提取角点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>当该点可能是由于遮挡导致被选择为边缘点</li>
</ol>
<figure>
<img src="./imgs/illegal_feature_point.png" alt="" /><figcaption>不合格的特征点(from LOAM)</figcaption>
</figure>
<p>如上图（b）所示，点A是由于被平面遮挡而产生的边缘点，当视角变化后，点A就不再是边缘点。 这个逻辑的判断也是通过点与其周围点的range差距判断。如果是由于遮挡产生的边缘点，则其与左边或者右边会存在距离的图片。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// featureExtraction.cpp&gt;markOccludedPoints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markOccludedPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cloudSize = extractedCloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 标记被遮挡的点和与激光束平行的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记被遮挡的点</span></span><br><span class="line">        <span class="type">float</span> depth1 = cloudInfo.point_range[i];</span><br><span class="line">        <span class="type">float</span> depth2 = cloudInfo.point_range[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[i+<span class="number">1</span>] - cloudInfo.point_col_ind[i]));</span><br><span class="line">        <span class="comment">// 两个点的列索引相差10个像素之内，认为是同一块区域</span></span><br><span class="line">        <span class="keyword">if</span> (columnDiff &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前点距离大于右点距离0.3米，认为当前点及左边6个点无效</span></span><br><span class="line">            <span class="keyword">if</span> (depth1 - depth2 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前点距离小于右边点距离0.3米，认为右边6个点无效</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (depth2 - depth1 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记平行与激光束的点</span></span><br><span class="line">        <span class="type">float</span> diff1 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i<span class="number">-1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="type">float</span> diff2 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i+<span class="number">1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="comment">// 当前点与左右两点的距离均大于阈值，认为当前点是处于平行面的点</span></span><br><span class="line">        <span class="keyword">if</span> (diff1 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i] &amp;&amp; diff2 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i])</span><br><span class="line">            cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>当点处于跟激光线平行的平面上时，也可能被认为时边缘点，也需要排除 如上图中的(a)所示，点B位于一个跟激光线较为平行的面上，激光线扫过去，前后几个点的距离差距会很大，因此在处理时可能会被认为是边缘点。这些点也需要做标记，不要设置为边缘点。</li>
</ol>
<h2 id="特征点提取流程">特征点提取流程</h2>
<p>由于这部分代码和原理都比较简单，这里只说一下特征提取的流程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief</span></span><br><span class="line"><span class="comment">* cloudInfo话题的回调函数，这个模块的功能都是顺序进行</span></span><br><span class="line"><span class="comment">* 1. 接收到从imageProjection中发布出的一个去畸变点云信息cloudInfo(自定义格式)</span></span><br><span class="line"><span class="comment">* 2. 对每个点计算曲率。计算时是计算周围点的平均距离用来作为曲率的替代</span></span><br><span class="line"><span class="comment">* 3. 标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="comment">* 4. 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="comment">* 5. 整合信息，发布完整数据包</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param msgIn 从去畸变模块接受的数据包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 缓存全局变量，后面的函数可以直接读取cloudInfo和cloudHeader进行处理</span></span><br><span class="line">cloudInfo = *msgIn;</span><br><span class="line">cloudHeader = msgIn-&gt;header;</span><br><span class="line"><span class="comment">// 把ros2 PointCloud2转成PCL格式，方便后面处理</span></span><br><span class="line">pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_deskewed, *extractedCloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点云每一个点曲率</span></span><br><span class="line"><span class="built_in">calculateSmoothness</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="built_in">markOccludedPoints</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="built_in">extractFeatures</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合信息，发布完整数据包</span></span><br><span class="line"><span class="built_in">publishFeatureCloud</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/imageProjection-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——点云去畸变模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-22 15:55:36 / 修改时间：21:32:29" itemprop="dateCreated datePublished" datetime="2023-03-22T15:55:36+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——点云去畸变模块" href="/2023/03/22/lio_sam/imageProjection-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::92a09cadad63fefbcbc8404aeb27c1f1" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p>点云去畸变模块(imageProjection.cpp文件，文件命名应该是继承了<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>，其实我觉得应该叫做数据预处理模块更合适）主要有以下几个作用</p>
<ol type="1">
<li>去除激光雷达点云的运动畸变</li>
<li>检索每一帧点云对应的IMU输出角度、IMU里程计位姿（发布自ImuPreintegration），以便MapOptimization模块用这些信息作为该帧点云的初始位姿</li>
<li>转换点云格式，计算<code>Range</code>字段，方便特征提取模块进行边缘点、平面点提取</li>
</ol>
<p>总体的流程如下图：</p>
<figure>
<img src="./imgs/Design-imageProjection-pipeline.png" alt="" /><figcaption>pipeline</figcaption>
</figure>
<h2 id="消息订阅及发布">消息订阅及发布</h2>
<figure>
<img src="./imgs/Design-Node%26%26Topics-imageProjection.png" alt="" /><figcaption>消息订阅及发布</figcaption>
</figure>
<h2 id="cloudinfo数据类型">CloudInfo数据类型</h2>
<p>经过去畸变的点云通过<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>自定义的数据格式<code>CloudInfo.msg</code>(Simple-LIO-SAM/msg/CloudInfo.msg)发布；特征提取模块也是将特征点放入这个自定义数据格式发布。 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cloud Info</span></span><br><span class="line"><span class="string">std_msgs/Header</span> <span class="string">header</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在进行点云去畸变时，把range数据展开成一维向量</span></span><br><span class="line"><span class="comment"># ring代表第几条激光线数，比如16线的激光雷达有16个ring</span></span><br><span class="line"><span class="comment"># start_ring_index记录第一个ring在一维向量中的起始索引</span></span><br><span class="line"><span class="comment"># end_ring_index记录第一个ring在一维向量中的结束索引</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">start_ring_index</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">end_ring_index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录一维的Range数据中每一个点在原始range图片中属于那一个列</span></span><br><span class="line"><span class="string">int32[]</span>  <span class="string">point_col_ind</span> <span class="comment"># point column index in range image</span></span><br><span class="line"><span class="comment"># 所有点的range数值，展开为一维数组</span></span><br><span class="line"><span class="string">float32[]</span> <span class="string">point_range</span> <span class="comment"># point range </span></span><br><span class="line"></span><br><span class="line"><span class="string">int64</span> <span class="string">imu_available</span></span><br><span class="line"><span class="string">int64</span> <span class="string">odom_available</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attitude for LOAM initialization</span></span><br><span class="line"><span class="comment"># 从IMU原始数据获取的roll、pitch、yaw角初值</span></span><br><span class="line"><span class="comment"># 当上面的imu_avaliable为true，odom_available为false的时候，会被用来</span></span><br><span class="line"><span class="comment"># 当作这一帧点云的初值</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_roll_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_pitch_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_yaw_init</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial guess from imu pre-integration</span></span><br><span class="line"><span class="comment"># 从imuPreintegration，IMU预积分模块获取的与这一帧雷达最接近的初始位姿</span></span><br><span class="line"><span class="comment"># 当上面的odom_available标签被置为true的时候会被使用</span></span><br><span class="line"><span class="comment"># 优先级比imu_xxx_init高</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_x</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_y</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_z</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_roll</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_pitch</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_yaw</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Point cloud messages</span></span><br><span class="line"><span class="comment"># 去畸变后的原始点云</span></span><br><span class="line"><span class="comment"># 在经过imageProjection模块后，这个数据字段被填充。在经过特征提取之后这个字段被清空</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_deskewed</span> </span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云边缘点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_corner</span></span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云平面点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_surface</span></span><br></pre></td></tr></table></figure> 这里主要是前面几个数组类型会比较难理解，主要是要知道在去畸变模块中，将所有点的<code>range</code>信息（也就是点距离雷达的距离）拉成一个一维的数组，即<code>float32[] point_range</code>。 同时，<code>cloud_deskewed</code>里存储的是去完畸变后的点云，里面点的顺序与<code>point_range</code>的顺序是一样的。</p>
<p><code>cloud_corner</code>和<code>cloud_surface</code>两个字段在<code>imageProjection</code>模块中没有被放置数据。特征提取模块会将边缘点、平面点放置在这两个字段中，同时将<code>cloud_deskewed</code>字段清空。</p>
<h2 id="功能解读">功能解读</h2>
<h3 id="imu及imu里程计处理">IMU及IMU里程计处理</h3>
<p>ImageProjection监听IMU原始数据与从ImuPreintegration发布出来的IMU里程计数据，分别由两个回调函数处理，对于IMU原始数据，只是简单地将其旋转到雷达坐标系后塞入缓存队列。 对于IMU历程计，则是直接塞入缓存队列。</p>
<h3 id="去畸变流程">去畸变流程</h3>
<p>一句话说明点云运动畸变校正：根据每一帧点云中每一个点的时间戳，计算该点到该帧点云起始点的旋转平移变换，将每一个点变换到起始点的坐标系。</p>
<p>要注意的是，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中对运动畸变校正只做了旋转校正，没有做平移校正。</p>
<p>去畸变流程发生在点云的回调函数中 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection::cloudHandler</span></span><br><span class="line"><span class="comment">/** 原始雷达点云话题的回调函数，实际上真正做点云处理的函数</span></span><br><span class="line"><span class="comment">    * 实际处理流程是单线程流水线式处理，这个函数后面的所有函数都是为这个函数服务，因此需要了解</span></span><br><span class="line"><span class="comment">    * 点云去畸变的流程。</span></span><br><span class="line"><span class="comment">    * 订阅原始lidar数据</span></span><br><span class="line"><span class="comment">    * 1、转换点云为统一格式，提取点云信息</span></span><br><span class="line"><span class="comment">    *   1）添加一帧激光点云到队列，取出最早一帧作为当前帧</span></span><br><span class="line"><span class="comment">    *   2) 计算起止时间戳，检查数据有效性</span></span><br><span class="line"><span class="comment">    * 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line"><span class="comment">    *   imu数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu数据，初始时刻对应imu的姿态角RPY设为当前帧的初始姿态角</span></span><br><span class="line"><span class="comment">    *   2) 用角速度、时间积分，计算每一时刻相对于初始时刻的旋转量，初始时刻旋转设为0</span></span><br><span class="line"><span class="comment">    *   imu里程计数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu里程计数据，初始时刻对应imu里程计设为当前帧的初始位姿</span></span><br><span class="line"><span class="comment">    *   2) 用起始、终止时刻对应imu里程计，计算相对位姿变换，保存平移增量</span></span><br><span class="line"><span class="comment">    * 3、当前帧激光点云运动畸变校正</span></span><br><span class="line"><span class="comment">    *   1) 检查激光点距离、扫描线是否合规</span></span><br><span class="line"><span class="comment">    *   2) 激光运动畸变校正，保存激光点</span></span><br><span class="line"><span class="comment">    * 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line"><span class="comment">    * 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line"><span class="comment">    * 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cloudHandler</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::PointCloud2::SharedPtr laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、提取、转换点云为统一格式</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cachePointCloud</span>(laserCloudMsg))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">deskewInfo</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、当前帧激光点云运动畸变校正</span></span><br><span class="line">    <span class="built_in">projectPointCloud</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line">    <span class="built_in">cloudExtraction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line">    <span class="built_in">publishClouds</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line">    <span class="built_in">resetParameters</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>提取、转换点云为统一格式 <img src="./imgs/Design-imageProjection-cachePointCloud.png" alt="提取、转换点云为统一格式" /></p></li>
<li><p>提取去畸变信息 <img src="./imgs/Design-imageProjection-deskewInfo.png" alt="提取去畸变信息" /></p></li>
</ul>
<p>这里有几点要注意 1. 从IMU原始数据计算每一时刻的位姿变换用的是近似算法（因为一帧点云成像时间很短，一般小与100ms） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对角度做积分</span></span><br><span class="line"><span class="comment">// 再次强调，对角速度的积分不是简单的角速度乘以间隔时间</span></span><br><span class="line"><span class="comment">// 关于角速度的积分公式可以查阅：https://zhuanlan.zhihu.com/p/591613108</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> timeDiff;</span><br><span class="line">timeDiff = currentImuTime - imuTime[imuPointerCur<span class="number">-1</span>];</span><br><span class="line">imuRotX[imuPointerCur] = imuRotX[imuPointerCur<span class="number">-1</span>] + angular_x * timeDiff;</span><br><span class="line">imuRotY[imuPointerCur] = imuRotY[imuPointerCur<span class="number">-1</span>] + angular_y * timeDiff;</span><br><span class="line">imuRotZ[imuPointerCur] = imuRotZ[imuPointerCur<span class="number">-1</span>] + angular_z * timeDiff;</span><br><span class="line">imuTime[imuPointerCur] = currentImuTime;</span><br><span class="line">++imuPointerCur;</span><br></pre></td></tr></table></figure> 2. 对于速度较低，角度变化不那么剧烈的行驶系统，即使不做点云畸变校正也没有问题</p>
<ul>
<li><p>对点云做去畸变处理 <img src="./imgs/Design-imageProjection-projectPointCloud.png" alt="对点云做去畸变处理" /></p></li>
<li><p>提取有效点云并集合其他信息 这里主要是将经过去畸变处理后记录下来的有效点进行数据转换，并把各种信息填入准备发布的<code>cloud_info</code>消息中。</p></li>
<li><p>发布点云</p></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">Simple-LIO-SAM——utility文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-22 11:18:09 / 修改时间：21:32:22" itemprop="dateCreated datePublished" datetime="2023-03-22T11:18:09+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——utility文件解读" href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6ed3eebc09d2237963daad43bab3bc96" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<p>这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>里一个最基础的文件，主要有几个重要功能： 1. 作为所有其他节点的基类，放置所有从配置文件读取的配置字 2. 提供一些实用函数 3. 配置<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a></p>
<h2 id="配置基类">配置基类</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>为了方便配置，把所有节点的配置项都写在同一个文件<code>Simple-LIO-SAM/config/params.yaml</code>，同时构建了一个基类<code>ParamServer</code>统一读取该配置文件，其余模块都从该基类继承。 <img src="./imgs/Design-Class.png" alt="类图" /> 这可能不是最优的方式，不过从实现上来说的确是最简单的。</p>
<p>每个模块的具体配置项后面具体讲解到会逐一解释，目前只需要知道是在哪里配置就行。 <details class="note info no-icon"><summary><p>配置部分代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>
</td>
<td class="code">
<pre><span class="line">// Topics</span><br><span class="line">string pointCloudTopic;  // 原始点云数据话题（/points_raw）</span><br><span class="line">string imuTopic;         // 原始IMU数据话题（/imu_correct）</span><br><span class="line">string imuOdomTopic;     // IMU里程计，在imuPreintegration中对IMU做预积分得到（/lio_sam/imu/odometry）</span><br><span class="line">string lidarOdomTopic;   // 雷达里程计，在mapOptimization中得到（/lio_sam/mapping/odometry）</span><br><span class="line">string gpsTopic;         // 原始gps经过robot_localization包计算得到，暂未使用</span><br><span class="line"></span><br><span class="line">// Services</span><br><span class="line">string saveMapSrv;      // 保存地图service地址</span><br><span class="line"></span><br><span class="line">// Frames</span><br><span class="line">string imuFrame;        // IMU数据坐标系，如果IMU和激光雷达坐标系硬件对齐，可以认为IMU、Lidar、Chassis坐标系相同</span><br><span class="line">string lidarFrame;      // 激光雷达坐标系，点云数据坐标系，由激光雷达发布的数据指定。与lidarFrame相同，但是不同雷达有不同的名称</span><br><span class="line">string baseLinkFrame;   // 车辆底盘坐标系</span><br><span class="line">string odomFrame;       // 地图坐标系，在SLAM中一般也是世界坐标系，通常是车辆的起始坐标系</span><br><span class="line"></span><br><span class="line">// GPS Settings</span><br><span class="line">bool useImuHeadingInitialization;</span><br><span class="line">bool useGpsElevation;</span><br><span class="line">float gpsCovThreshold;</span><br><span class="line">float poseCovThreshold;</span><br><span class="line"></span><br><span class="line">// Save pcd</span><br><span class="line">bool savePCD;</span><br><span class="line">string savePCDDirectory;</span><br><span class="line"></span><br><span class="line">// Lidar Sensor Configuration</span><br><span class="line">SensorType sensor;</span><br><span class="line">int N_SCAN;</span><br><span class="line">int Horizon_SCAN;</span><br><span class="line">int downsampleRate;</span><br><span class="line">float lidarMinRange;</span><br><span class="line">float lidarMaxRange;</span><br><span class="line"></span><br><span class="line">// IMU</span><br><span class="line">float imuAccNoise;      // IMU加速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuGyrNoise;      // IMU角速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuAccBiasN;      // IMU加速度偏差，三轴统一</span><br><span class="line">float imuGyrBiasN;      // IMU角速度偏差，三轴统一</span><br><span class="line">float imuGravity;       // 重力加速度值</span><br><span class="line">float imuRPYWeight;     // 算法中使用IMU的roll、pitch角对激光里程计的结果加权融合</span><br><span class="line">vector&lt;double&gt; extRotV;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extRPYV;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extTransV;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Matrix3d extRot;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Matrix3d extRPY;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Vector3d extTrans;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Quaterniond extQRPY;     // IMU角速度向量到雷达坐标系的旋转（四元数形式）</span><br><span class="line"></span><br><span class="line">// LOAM</span><br><span class="line">float edgeThreshold;            // 边缘特征点提取阈值</span><br><span class="line">float surfThreshold;            // 平面特征点提取阈值</span><br><span class="line">int edgeFeatureMinValidNum;     // 边缘特征点数量阈值（default:10)</span><br><span class="line">int surfFeatureMinValidNum;     // 平面特征点数量阈值（default:100)</span><br><span class="line"></span><br><span class="line">// voxel filter paprams</span><br><span class="line">float odometrySurfLeafSize;</span><br><span class="line">float mappingCornerLeafSize;</span><br><span class="line">float mappingSurfLeafSize ;</span><br><span class="line"></span><br><span class="line">float z_tollerance;             // 限制z轴平移的大小</span><br><span class="line">float rotation_tollerance;      // 限制roll、pitch角的大小</span><br><span class="line"></span><br><span class="line">// CPU Params</span><br><span class="line">int numberOfCores;              // 在点云匹配中使用指令集并行加速（default:4）</span><br><span class="line">double mappingProcessInterval;  // 点云帧处理时间间隔（default:0.15s）</span><br><span class="line"></span><br><span class="line">// Surrounding map</span><br><span class="line">float surroundingkeyframeAddingDistThreshold;   // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingkeyframeAddingAngleThreshold;  // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingKeyframeDensity;               // 构建局部地图时对采用的关键帧数量做降采样</span><br><span class="line">float surroundingKeyframeSearchRadius;          // 构建局部地图时关键帧的检索半径</span><br><span class="line"></span><br><span class="line">// Loop closure</span><br><span class="line">bool  loopClosureEnableFlag;</span><br><span class="line">float loopClosureFrequency;                     // 回环检测独立线程的执行频率</span><br><span class="line">int   surroundingKeyframeSize;                  // 回环检测构建局部地图的最大关键帧数量</span><br><span class="line">float historyKeyframeSearchRadius;              // 执行回环检测时关键帧的检索半径</span><br><span class="line">float historyKeyframeSearchTimeDiff;            // 执行回环检测时关键帧的检索时间范围</span><br><span class="line">int   historyKeyframeSearchNum;                 // 执行回环检测时融合局部地图时对目标关键帧执行+-25帧的关键帧融合</span><br><span class="line">float historyKeyframeFitnessScore;              // 执行回环检测时使用ICP做点云匹配，阈值大于0.3认为匹配失败，不采纳当前回环检测</span><br><span class="line"></span><br><span class="line">// global map visualization radius</span><br><span class="line">float globalMapVisualizationSearchRadius;</span><br><span class="line">float globalMapVisualizationPoseDensity;</span><br><span class="line">float globalMapVisualizationLeafSize;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details></p>
<h2 id="实用函数">实用函数</h2>
<p>这里主要讲解其中一个<code>imuConverter</code>函数。该函数的功能主要是将<code>IMU</code>的原始数据<strong>旋转到</strong><code>Lidar</code>坐标系。这里要先知道，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中， 默认将雷达坐标系和小车的坐标系等同为同一个坐标系，同时，这里只做了<strong>旋转</strong>操作，没有做平移操作。代码中有很多处位置都用到这个函数，因此需要理解这个函数到底做了什么。 简单来说这个函数就是做了一个<strong>向量坐标变换</strong>。旋转矩阵操作空间中一个点有两种意义：1）三维旋转；2）坐标变换。这两种不同的操作在做连续的操作时，对应旋转矩阵的左乘和右乘。 由于笔者以前的研究方向是六自由度姿态估计，用三维旋转操作比较多，一开始被这里的<code>矩阵右乘</code>搞蒙了。关于旋转矩阵的左乘和右乘，可以看这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45632220/article/details/117735223">博客</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将原始IMU数据：三轴加速度、三轴角速度、三轴角度，与雷达坐标系进行旋转对齐</span></span><br><span class="line"><span class="comment">+ 对齐之后输出的加速度、角速度、角度的x，y，z就变成雷达坐标系的x，y，z</span></span><br><span class="line"><span class="comment">+ 这里的特殊之处在于允许IMU的加速度、角速度与角度的输出是两个不同的坐标系。但在算法中，角度的输出除了用来做第一帧的初始化和加权融合，似乎没有其他作用</span></span><br><span class="line"><span class="comment">+ 这里是将IMU的三个轴与雷达的三个轴在旋转上做对齐，不能加上平移</span></span><br><span class="line"><span class="comment">+ 对向量做坐标系变换，对多个变换的复合应该是右乘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sensor_msgs::<span class="function">msg::Imu <span class="title">imuConverter</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::Imu&amp; imu_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sensor_msgs::msg::Imu imu_out = imu_in;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对加速度向量做坐标系变换，注意这里要理解成坐标系变换，也就是同一个加速度在IMU坐标系和Lidar坐标系的不同表达。不能想象成对加速度做旋转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">acc</span><span class="params">(imu_in.linear_acceleration.x, imu_in.linear_acceleration.y, imu_in.linear_acceleration.z)</span></span>;</span><br><span class="line">    acc = extRot * acc;</span><br><span class="line">    imu_out.linear_acceleration.x = acc.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.linear_acceleration.y = acc.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.linear_acceleration.z = acc.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角速度做坐标系变换。将IMU坐标系下的向量变换到雷达坐标系。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">gyr</span><span class="params">(imu_in.angular_velocity.x, imu_in.angular_velocity.y, imu_in.angular_velocity.z)</span></span>;</span><br><span class="line">    gyr = extRot * gyr;</span><br><span class="line">    imu_out.angular_velocity.x = gyr.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.angular_velocity.y = gyr.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.angular_velocity.z = gyr.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角度做坐标系变换。</span></span><br><span class="line"><span class="comment">    + q_from是IMU在全局坐标系下的位姿，q_from: transformation_from_map_to_imu</span></span><br><span class="line"><span class="comment">    + extQRPY如果与extRot对应的话应该是lidar到imu的变换：transformation_from_lidar_to_imu</span></span><br><span class="line"><span class="comment">    + q_final是将雷达点云从雷达坐标系转换到map坐标系的变换，也是：transformation_from_map_to_lidar -&gt; pcd_in_map = q_final * pcd_in_lidar</span></span><br><span class="line"><span class="comment">    + 这里原代码是q_final = q_from * extQRPY；似乎有点问题，还是按照我的推导修改成q_final = q_from * extQRPT.inverse()；由于这里的extQRPY是</span></span><br><span class="line"><span class="comment">    + 直接从配置文件里面读取的，所以这里加不加逆只需要在配置文件里改就行。认为这里有问题的假设是认为extQRPY和extRot的坐标系关系的定义是一致的，也就是</span></span><br><span class="line"><span class="comment">    + 将imu坐标系下的向量转换到雷达坐标系下。如果作者对这两者的定义刚好是相反的，那这里就没有问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Quaterniond <span class="title">q_from</span><span class="params">(imu_in.orientation.w, imu_in.orientation.x, imu_in.orientation.y, imu_in.orientation.z)</span></span>;</span><br><span class="line">    Eigen::Quaterniond q_final = q_from * extQRPY.<span class="built_in">inverse</span>();</span><br><span class="line">    imu_out.orientation.x = q_final.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.orientation.y = q_final.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.orientation.z = q_final.<span class="built_in">z</span>();</span><br><span class="line">    imu_out.orientation.w = q_final.<span class="built_in">w</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sqrt</span>(q_final.<span class="built_in">x</span>()*q_final.<span class="built_in">x</span>() + q_final.<span class="built_in">y</span>()*q_final.<span class="built_in">y</span>() + q_final.<span class="built_in">z</span>()*q_final.<span class="built_in">z</span>() + q_final.<span class="built_in">w</span>()*q_final.<span class="built_in">w</span>()) &lt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Invalid quaternion, please use a 9-axis IMU!&quot;</span>);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imu_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="qosquality-of-service">QoS:Quality of Service</h2>
<p>关于ROS2中<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a>的基本介绍，参考官方文档学习。<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a>的设置中，有两个参数是最重要的。一个是<code>depth</code>，一个是<code>RELIABILITY</code>。<code>depth</code>可以简要理解成中间件DDS为这个消息预留的缓存队列长度。 <code>RELIABILITY</code>主要有两种选项<code>best_effort</code>和<code>reliable</code>，它们的关系类似<code>TCP</code>,<code>UDP</code>。<code>best_effort</code>不能保证每一个消息到到达接收端，但可以保持最好的实时信。<code>reliable</code>保证每一帧消息 都到达接收端，但是无法保证实时性。ROS2中专门为传感器预设了一个<a target="_blank" rel="noopener" href="https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1SensorDataQoS.html">SensorDataQoS</a>，里面采用的就是<code>best_effort</code> 的设置。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>设置了三种<code>QoS</code>，分别为：原始IMU数据、原始雷达数据、框架内部传输</p>
<ol type="1">
<li><p>原始IMU数据QoS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始IMU数据的QOS，因为IMU数据较小，所以depth可以设成较大</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_imu&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">2000</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_imu = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_imu.history,</span><br><span class="line">      qos_profile_imu.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_imu);</span><br></pre></td></tr></table></figure></p></li>
<li><p>原始雷达数据QoS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始雷达数据topic的QOS，主要是best_effort和depth起作用</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_lidar&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">5</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_lidar = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_lidar.history,</span><br><span class="line">      qos_profile_lidar.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_lidar);</span><br></pre></td></tr></table></figure></p></li>
<li><p>算法框架内部传输QoS 算法框架内部要求有最高的实时性，并且由于传输中有很多点云类型的数据（较大），因此作者把<code>depth</code>设置为1 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 算法框架中默认的QOS，主要是depth=1和reliability=best_effort起作用。对于传输实时性有要求，不要求每个数据可接收的消息，一般</span></span><br><span class="line"><span class="comment">/// 设成best_effort。在ROS2中对于传感器数据，有一个内置的QOS叫rclcpp::SensorDataQoS()</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> qos = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile.history,</span><br><span class="line">      qos_profile.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile);</span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/" class="post-title-link" itemprop="url">Simple-LIO-SAM——总体流程认识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-16 19:38:59" itemprop="dateCreated datePublished" datetime="2023-03-16T19:38:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-22 21:31:59" itemprop="dateModified" datetime="2023-03-22T21:31:59+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——总体流程认识" href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::152660a48ad07f280a45860dc663a523" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总体流程">总体流程</h2>
<p>话不多说，直接上干货。下图是整理出来的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>整体运行流程</p>
<figure>
<img src="./imgs/Design-Pipelines.png" alt="" /><figcaption>Pipeline</figcaption>
</figure>
<h3 id="整体认识">整体认识</h3>
<p>所谓的紧耦合，我是这么理解的：IMU本身就可以积分出来一个位姿，连续帧的点云匹配也可以计算出一个位姿，如果两者分别进行，然后再做一个加权融合，那么就属于松耦合。而从上面的框架图也可以看出，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的融合框架整体呈现一个<code>圈</code>，每个环节都为下一个环节提供信息，最后一个环节又为第一个环节提供信息。同时，耦合之处还在于以下几点： 1. 高频的IMU信息对激光雷达点云做了畸变矫正，做了畸变矫正后的点云被用来做匹配计算激光里程计 2. IMU的积分结果被用来当作该帧点云的初值，为点云匹配提供了较好的初始估计 3. 雷达里程计的结果被用来计算IMU的偏差，同时也被用来持续纠正IMU里程计</p>
<p>虽然<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中还可以融合<code>GPS</code>信息，但是主要还是对雷达点云和IMU信息，因此，可以认为输入是点云和IMU数据，输出是小车当前时刻的位姿，已经对历史时刻位姿的平滑。</p>
<ul>
<li><p>框架的入口是点云去畸变模块，主要的功能就是对激光雷达运动畸变做矫正，然后输出去完畸变的点云。</p></li>
<li><p>去完畸变的点云经过特征提取模块，提取出角特征点和平面特征点，被图优化模块中的点云匹配部分用来做点云匹配。</p></li>
<li><p>图优化模块利用去完畸变后的点云与历史帧构建的局部地图做匹配，得出较准确的里程计结果。同时利用图优化，加入回环检测因子，使得整体估计更为准确顺滑</p></li>
<li><p>IMU预积分模块从IMU和图优化模块接收数据，对IMU的原始数据做积分，得出每一帧点云的初始位姿，提供给图优化模块作为优化初始值。同时又从图优化模块拿出经过点云、图优化校正后的里程计结果校正本身的结果</p></li>
<li><p>坐标系发布主要是为了<code>RIVZ</code>显示中用的，主要就是将各种里程计结果转换成<code>TF</code>坐标关系发布出去。在原始<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中是与<code>imuPreintegration</code>放置在同一个文件</p></li>
</ul>
<h3 id="运动畸变矫正">运动畸变矫正</h3>
<ul>
<li>为什么激光雷达有运动畸变？ 激光雷达通过发射高能量激光线束，计算激光线束往返时间，得到该激光线打到的物体的距离。以机械式激光雷达为例，雷达在统一时刻可以发送多条激光线（32、64、128），这多条激光线在垂直方向上可以扫到三维空间中垂直的一条线，激光雷达通过环绕一周的方式可以对360的空间做三维成像 <img src="./imgs/lidar.webp" alt="lidar" /></li>
</ul>
<p>由于激光雷达是通过激光线束环绕一周的方式成像一帧的点云，那么这一帧点云的点就是在不同的时间探测的。如果激光线束在环绕一周的过程中，激光雷达是在运动的，那么这一帧点云就由于激光雷达的运动而变得不准确，因此需要对其做校正。 <img src="./imgs/livox_lidar_distortion.png" alt="livox_lidar_distortion_removal" /> （上面这幅图片引用自livox官网[Liovox_distortion_removal])</p>
<p>激光雷达输出的每一帧点云<span class="math inline">\(P\)</span>，里面的每一个点<span class="math inline">\(p_i\)</span>，都有一个属性<span class="math inline">\(t_i\)</span>，记录了该点距离该帧点云起始时刻的时间间隔，也就是下面代码段里的<code>time</code>字段。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection.cpp 49-60</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VelodynePointXYZIRT</span></span><br><span class="line">&#123;</span><br><span class="line">    PCL_ADD_POINT4D</span><br><span class="line">    PCL_ADD_INTENSITY;</span><br><span class="line">    <span class="type">uint16_t</span> ring;</span><br><span class="line">    <span class="type">float</span> time;</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">&#125; EIGEN_ALIGN16;</span><br><span class="line"><span class="built_in">POINT_CLOUD_REGISTER_POINT_STRUCT</span> (VelodynePointXYZIRT,</span><br><span class="line">    (<span class="type">float</span>, x, x) (<span class="type">float</span>, y, y) (<span class="type">float</span>, z, z) (<span class="type">float</span>, intensity, intensity)</span><br><span class="line">    (<span class="type">uint16_t</span>, ring, ring) (<span class="type">float</span>, time, time)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>由于IMU是非常高频的，因此我们可以得出该帧点云成像时间段内的激光雷达位移和旋转的变换，然后通过每一个点的时间<span class="math inline">\(t_i\)</span>，可以根据时间进行插值得出每一个点相对于起始点的转换关系<span class="math inline">\(T_i\)</span>。（注：LIOSAM里面是直接通过时间戳查找，而不是进行插值）。从而，我们就可以将每个点都转换到起始点的坐标系 <span class="math display">\[
p_i^0 = T_ip_i
\]</span></p>
<h3 id="点云特征提取">点云特征提取</h3>
<p>激光里程计中一般会涉及到点云匹配，如果用原始点云进行匹配由于点数过多的关系，会导致耗时太长，因此<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的方法进行<code>边缘点</code>,<code>平面点</code>两类特征点的提取，后面点云匹配部分使用这两种特征点进行<code>LM</code>优化求解出匹配关系。</p>
<p>这部分的代码相对简单，后面关于这个模块的详细内容会介绍，这里唯一要清楚的是，这里的点云特征点提取用的是每个点的曲率，选择曲率大的点作为边缘点，选择曲率小的点作为平面点。但是曲率的计算是用每个点周围的点到其平均距离作为近似。</p>
<h3 id="imu预积分模块">IMU预积分模块</h3>
<p>这一个模块虽然从原理和实现上来说稍微有一点点复杂，但是从功能上简单来说只有一个功能，就是实时对<code>IMU原始数据</code>做处理（积分），得到每一个时刻的IMU里程计（也是6自由度位姿），然后该位姿被用来作为该帧点云的初始估计位姿，这个初始估计位姿会被用来作为点云匹配的初始估计。</p>
<h3 id="点云匹配及图优化">点云匹配及图优化</h3>
<p>这是整个框架最复杂的一个模块（也许是没有很好解耦？）。这个模块主要包含了以下几个功能： 1. 点云匹配 2. 回环检测 3. 因子图构建及优化 4. 根据关键帧信息构建全局地图</p>
<p>具体内容会在后面的章节展开，这里应该要有几个感性认识： 1. 一般点云精细匹配（比如ICP算法）需要有一个良好的初始值，这里的初始值可以理解成采用IMU预积分模块的输出。 2. 点云匹配部分用的是沿用自LOAM-&gt;LeGO-LOAM的点云匹配算法，不是使用ICP。<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>也是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan" title="作者Github">TixiaoShan</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的上一篇相关论文 3. 回环检测根据里程计的x,y,z检索紧邻帧，然后通过ICP算法计算当前帧与近邻帧的转换关系 4. 经过点云匹配后的位姿会经过图优化得出更平滑的位姿 5. 地图和因子图的因子实际上是以关键帧的形态存在后端优化部分，关键帧的选取会比较稀疏，比如距离小与1米不会采用为关键帧。不采用为关键帧的点云会执行完点云匹配后就直接输出位姿。 6. 在有新的回环因子加入因子图后，会进行多次因子图优化器的更新步骤，然后将所有历史关键帧的位姿都更新一遍 7. 这个部分还支持<code>GPS里程计</code>的监听，并将<code>GPS里程计</code>也加入因子图进行优化</p>
<h2 id="坐标系规定">坐标系规定</h2>
<h3 id="坐标系规定-1">坐标系规定</h3>
<p>原有的<code>urdf</code>文件加入了太多额外没必要的关节，导致<code>rviz</code>中<code>tf-tree</code>关系太过复杂。为了简化坐标系关系，但同时又维持坐标系关系标准化并且与<code>ROS</code>的规定相同（<code>ROS</code>中关于姿态估计的坐标系关系主要参考：<a target="_blank" rel="noopener" href="http://docs.ros.org/en/melodic/api/robot_localization/html/preparing_sensor_data.html">robot_localization_coordinate_system</a>，这里对项目中的坐标系关系做了一些简化修改。 根据robot_localization包的规定，所有姿态都要转到世界坐标系，通常是<code>map</code>或者<code>odom</code>坐标系。所有的twist数据，都要转到base_link坐标系下处理。</p>
<h3 id="simple-lio-sam坐标系说明">Simple-LIO-SAM坐标系说明</h3>
<ol type="1">
<li>根据REP资料，一般有4个坐标系<code>earth</code>,<code>map</code>,<code>odom</code>,<code>base_link</code>。由于在SLAM中一般没有引入地球坐标系。所以在这里只有后三个坐标系。 同时，如果是以起始点作为地图原点，<code>map</code>,<code>odom</code>两个坐标系是重合的关系。</li>
<li>另外，为了可以在Rivz显示原始点云信息，则也加入一个雷达坐标系。</li>
<li>为了让坐标系定义自洽，虽然在算法中没有直接用到，但是IMU加速度速度和角速度应该定义在IMU坐标系，因此引入IMU坐标系</li>
<li>为了让定义更为标准，这里保留<code>map</code>坐标系，虽然在SLAM中<code>map</code>,<code>odom</code>大部分情况是重叠的</li>
<li>因此，整个spl_lio_sam框架可以简化成5个坐标系：<code>map</code>, <code>odom</code>,<code>base_link</code>,<code>lidar_link</code>,<code>imu_link</code>坐标系。其中， <code>map</code>是地图原点，在建图时是起始点，在重定位模式时，是地图原点。<code>odom</code>是里程计坐标系；<code>base_link</code>是车辆自身坐标系。<code>lidar_link</code>坐标系是雷达坐标系， 在lio_sam中是与<code>base_link</code>坐标系对齐的，但是<code>lidar_link</code>字段会根据雷达型号不同，被修改。<code>imu_link</code>坐标系是IMU坐标系，配置文件中 有指明IMU坐标系到Lidar坐标系的转换关系。</li>
</ol>
<h3 id="坐标系关系的其他说明">坐标系关系的其他说明</h3>
<ol type="1">
<li>ROS的Message Header只有一个frame_id字段，表明这个数据是在哪个坐标系下的。</li>
<li>nav_msgs/Odometry中还有一个child_frame_id字段，nav_msgs/Odometry中的twist数据应该是在child_frame_id坐标系下的数据 &gt; The twist in this message should be specified in the coordinate frame given by the child_frame_id</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">记一次解决rosbag2内存错误问题过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 18:28:01" itemprop="dateCreated datePublished" datetime="2023-03-15T18:28:01+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/ROS/" itemprop="url" rel="index"><span itemprop="name">ROS</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="记一次解决rosbag2内存错误问题过程" href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73e4783c1a71c1ae17cdb35318885253" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
</ul>
<h2 id="问题背景">问题背景</h2>
<p>由于工作需要，需要开发一个程序，根据记录的信息，从<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>保存的数据包根据打点的时间戳，提取出一段段单独的数据包。 为了存储空间考虑，保存时以及提取时都指定了使用<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#recording-with-compression">压缩的方式</a>进行存储。压缩器和压缩模式如下： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line"><span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>不仅有命令行工具，同时还开放API给开发者使用。<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>还提供了<code>convert</code>功能，可以对录下来的bagfile进行<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">二次提取</a>。因此开发这部分功能可以参考源码里面的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp">bag_rewriter.cpp</a></p>
<h2 id="开发环境">开发环境</h2>
<blockquote>
<p>ROS: ROS2-humble</p>
</blockquote>
<blockquote>
<p>OS: ubuntu 22.04</p>
</blockquote>
<blockquote>
<p>language: cpp17</p>
</blockquote>
<blockquote>
<p>rosbag2: 0.15.4-2jammy.20230118.031755</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p>完成上述数据提取功能后进行测试，发现提取的时候如果同时提取多个目标（构建多个writer，读取message后进行写操作，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L135">rosbag2源码参考部分</a>，并且都进行压缩的时候，会有<code>core dump</code>，错误信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corrupted size vs. prev_size</span><br><span class="line">[ros2run]: Aborted</span><br></pre></td></tr></table></figure></p>
<p>然而在其他情况：1.同时提取多个目标，但是不进行压缩；2.提取一个目标，进行压缩；的时候，程序都可以正常运行</p>
<p>为了确保不是自己编写的程序导致的问题，又使用<code>rosbag2 cli</code>进行类似的尝试。根据<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">converting-bags</a>的说明，我使用下面的<code>output_options.yaml</code>进行数据转换： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p>然后使用如下命令进行提取 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<p>果不其然，直接使用<code>rosbag2</code>的包也会有<code>core</code>问题，不过报的信息会有区别，不同次运行报的信息还不一样，主要是类似下面这样： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc(): unsorted double linked list corrupted</span><br><span class="line">free(): corrupted unsorted chunks</span><br><span class="line">corrupted double-linked list</span><br></pre></td></tr></table></figure></p>
<h2 id="问题复现">问题复现</h2>
<p>简单起见可以直接使用<code>rosbag2 cli</code>复现这个问题 1. 准备一个ros2的bag包 2. 新建一个配置文件命名为：<code>output_options.yaml</code>，并填入下面内容： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure> 3. 执行数据转换命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="问题定位">问题定位</h2>
<h3 id="增加日志">增加日志</h3>
<p>由于已经确认不是自己写的程序的问题，所以其实可以跳过这一步 ### gdb检查 cpp程序排查还是需要上gdb，不要自己瞎折腾瞎改代码。<a href="#appendA">文末记录</a>如何在<code>ubuntu</code>上生成<code>core文件</code>。 运行一次程序，生成<code>core文件</code>后使用gdb检查错误堆栈 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ros_ws/install/package/lib/package/excutable /path/to/corefile</span><br><span class="line"></span><br><span class="line">bt  <span class="comment"># gdb命令，打印错误堆栈</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到如下的报错信息</p>
<figure>
<img src="./imgs/backtraces.png" alt="" /><figcaption>backtraces</figcaption>
</figure>
<p>虽然是在子线程中出错，但是大概也能看到是在<code>rosbag2_compression::SequentialCompressonWriter::compression_thread_fn()</code>函数中出错。 这也符合了现象，只在进行压缩的时候会出错。</p>
<p>同时，从错误堆栈里可以看出应该是<code>rosbag2_compression_zstd::ZstdCompressor</code>在进行压缩处理的时候调用<code>rcutils_uint8_array_resize</code>函数出错。</p>
<h3 id="对比不同的writer">对比不同的writer</h3>
<p>由于在进行多个<code>writers</code>写数据，但是不执行压缩的时候并没有相关问题发生，所以可以对比一下普通的<code>writer</code>和<code>SequentialCompressonWriter</code>在写函数中的区别 #### 普通的writer，即rosbag2_cpp::SequentialWriter 普通的<code>writer</code>，即<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp">rosbag2_cpp::SequentialWriter</a>中，<code>void SequentialWriter::write(std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>函数比较简单，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp#L328-L337">核心代码</a>是这几行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (storage_options_.max_cache_size == <span class="number">0u</span>) &#123;</span><br><span class="line"><span class="comment">// If cache size is set to zero, we write to storage directly</span></span><br><span class="line">storage_-&gt;<span class="built_in">write</span>(converted_msg);</span><br><span class="line">++topic_information-&gt;message_count;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Otherwise, use cache buffer</span></span><br><span class="line">message_cache_-&gt;<span class="built_in">push</span>(converted_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>bag_rewrite</code>在调用<code>writer</code>的时候，<code>max_cache_size</code>始终<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L191">设置为0</a>，因此执行的是<code>if</code>分支，也就是直接调用底层的数据库封装类直接写入硬盘。</p>
<h4 id="带压缩的writer即rosbag2_compressionsequentialcompressionwriter">带压缩的writer即rosbag2_compression::SequentialCompressionWriter</h4>
<p>带压缩功能的writer这部分的逻辑增加了一个单独线程做压缩处理，函数<code>void SequentialCompressionWriter::write(   std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>的核心部分主要是<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L317-L321">这几行</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(compressor_queue_mutex_)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (compressor_message_queue_.<span class="built_in">size</span>() &gt; compression_options_.compression_queue_size) &#123;</span><br><span class="line">    compressor_message_queue_.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">compressor_message_queue_.<span class="built_in">push</span>(message);</span><br><span class="line">compressor_condition_.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>compressor_message_queue_</code>在另一个线程，即函数<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L63">void SequentialCompressionWriter::compression_thread_fn()</a>被处理。 这里面有一个对传入的<code>SerializedMessageSharedPtr</code>对象中的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L96">内存直接进行处理</a></p>
<h4 id="重新查看调用api的代码">重新查看调用API的代码</h4>
<p>调用<code>rosbag2 API</code>进行数据写操作的主要过程如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create rosbag2_storage::StorageOptions</span></span><br><span class="line">rosbag2_storage::StorageOptions storageOptions;</span><br><span class="line"><span class="comment">// create reader</span></span><br><span class="line"><span class="keyword">auto</span> inputReader = rosbag2_transport::ReaderWriterFactory::<span class="built_in">make_reader</span>(storageOptions);</span><br><span class="line"><span class="comment">// open file</span></span><br><span class="line">inputReader-&gt;<span class="built_in">open</span>(storageOptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create multiplt writers</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
<p><strong>可以看到，我们从<code>reader</code>中拿到的<code>SerializedBagMessage</code>是以共享指针的形式使用，当我们把共享指针传给不同的<code>writer</code>时，不同的<code>writer</code>内部同时对同一块内存进行数据压缩处理，因此也就导致了不同线程操作同一块地址空间的错误。</strong></p>
<h2 id="修复">修复</h2>
<p>由于不想更改<code>rosbag2</code>的代码，因此想办法在调用层解决。既然问题共享指针指向的内存被不同线程同时处理，那么我们就在每一次调用<code>writer-&gt;write(nextMsg)</code>的时候对<code>nextMsg</code>执行一次深拷贝，让不同的<code>writer</code>操作不同内存即可。 这里比较复杂的是<code>SerializedBagMessage</code>中使用一个指向<code>rcutils_uint8_array_t</code>的指针对内存进行管理。而<code>rcutils_uint8_array_t</code>里面又使用一个裸<code>uint8_t*</code>指针指向管理的内存。同时<code>rcutils</code>的文档不够详细，也没有提供函数对<code>rcutils_uint8_array_t</code>执行深拷贝操作。不过只要能够明白上面的内存管理关系，修复起来不太困难，关于<code>rcutils_uint8_array_t</code>的操作可以参考<code>rosbag2</code>里面的代码，最终修复的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">...create reader &amp;&amp; writer</span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg_copy = std::<span class="built_in">make_shared</span>&lt;rosbag2_storage::SerializedBagMessage&gt;();</span><br><span class="line">        <span class="comment">// 新建rcutils_uint8_array_t需要按照下面这样的操作</span></span><br><span class="line">        nextMsg_copy-&gt;serialized_data = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">rcutils_uint8_array_t</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">rcutils_uint8_array_t</span>,</span><br><span class="line">        [](<span class="type">rcutils_uint8_array_t</span> * msg) &#123;</span><br><span class="line">        <span class="keyword">auto</span> fini_return = <span class="built_in">rcutils_uint8_array_fini</span>(msg);</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">        <span class="keyword">if</span> (fini_return != RCUTILS_RET_OK) &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR_STREAM</span>(</span><br><span class="line">            rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rosbag2_cpp&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Failed to destroy serialized message: &quot;</span> &lt;&lt; <span class="built_in">rcutils_get_error_string</span>().str);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建后需要执行内存初始化</span></span><br><span class="line">        <span class="type">rcutils_allocator_t</span> allocator = <span class="built_in">rcutils_get_default_allocator</span>();</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">rcutils_uint8_array_init</span>(</span><br><span class="line">            nextMsg_copy-&gt;serialized_data.<span class="built_in">get</span>(),</span><br><span class="line">            nextMsg-&gt;serialized_data-&gt;buffer_capacity,</span><br><span class="line">            &amp;allocator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span> (ret != RCUTILS_RET_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Init arrry failed with ret code = %d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制内容</span></span><br><span class="line">        nextMsg_copy-&gt;topic_name = nextMsg-&gt;topic_name;</span><br><span class="line">        nextMsg_copy-&gt;time_stamp = nextMsg-&gt;time_stamp;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_capacity = nextMsg-&gt;serialized_data-&gt;buffer_capacity;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_length = nextMsg-&gt;serialized_data-&gt;buffer_length;</span><br><span class="line">        <span class="comment">// 复制内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)nextMsg_copy-&gt;serialized_data-&gt;buffer,</span><br><span class="line">                (<span class="type">void</span>*)nextMsg-&gt;serialized_data-&gt;buffer, nextMsg-&gt;serialized_data-&gt;buffer_length);</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg_copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<p>这个bug同时提交到<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>仓库<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/issues/1262">issues中</a>，看看后面有没有机会修复并提交PR</p>
<h2 id="附录aubuntu-core文件生成">附录A：ubuntu core文件生成</h2>
<div id="appendA">

</div>
<ol type="1">
<li><p>ubuntu有一个默认的错误搜集系统apport，必须要关掉之后才能生成core文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service apport status</span><br><span class="line">sudo service apport stop</span><br><span class="line">sudo systemctl apport disble  <span class="comment"># 似乎无法关闭开机启动，每次需要的时候需要手工确认是否关闭</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>设置core文件大小，默认是0，所以不会生成core文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c  <span class="comment"># 若结果是0，则不会生成core文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 不限制core文件大小</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 选择当前使用的终端</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></p></li>
<li><p>设置corefile路径(注意，路径必须普通用户可读！） <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /corefile</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /corefile</span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>CMakeLists.txt加上``Debug模式</code>下不进行编译器优化 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In CMakeLists.txt</span></span><br><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;<span class="variable">$ENV</span>&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb -Wno-unused-parameter&quot;</span>)  </span><br></pre></td></tr></table></figure> 注意在编译<code>ROS2</code>包的时候要指明<code>Debug</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select package_name --cmake-args -DCMAKE_BUILD_TYPE=Debug</span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-title-link" itemprop="url">Simple-LIO-SAM——环境搭建与运行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-14 19:49:06" itemprop="dateCreated datePublished" datetime="2023-03-14T19:49:06+08:00">2023-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——环境搭建与运行" href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::b824fa070f036b85c958cacd75daa48f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="运行环境搭建">运行环境搭建</h2>
<p>本项目提供基于<code>ROS2-humble</code>的镜像，并提供脚本可直接在镜像中启动可视化程序 ### 数据 本项目同时提供转为<code>rosbag2</code>格式的数据包，<a href="">下载地址</a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATA_DIR=/path/to/download/ros2bag/dir</span><br></pre></td></tr></table></figure> 本项目中默认的配置文件<code>params_default.yaml</code>可以直接运行下面的数据： - park_dataset - walking_dataset - garden_dataset</p>
<h3 id="环境部署">环境部署</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zeal-up/Simple-LIO-SAM.git</span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_run.sh -h  <span class="comment"># show help message</span></span><br><span class="line">./docker_run.sh -c /path/to/code/repo -d <span class="variable">$DATA_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./docker_into.sh  # enter the container next time</span></span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令在镜像中执行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws/</span><br><span class="line"><span class="built_in">mkdir</span> src &amp;&amp; <span class="built_in">cd</span> src &amp;&amp;<span class="built_in">ln</span> -s /home/splsam/codes ./</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">colcon build --packages-select spl_lio_sam</span><br></pre></td></tr></table></figure>
<h3 id="运行">运行</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker镜像下运行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws</span><br><span class="line"><span class="built_in">source</span> ./install/setup.bash</span><br><span class="line">ros2 launch spl_lio_sam run.launch.py </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开终端</span></span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"><span class="built_in">cd</span> data/ros2/</span><br><span class="line">ros2 bag play ./park_dataset/ --topics /points_raw /imu_raw</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行时画面： <img src="./imgs/runtime.gif" alt="SplRunParkDataset" /></p>
<h2 id="开发环境搭建">开发环境搭建</h2>
<p>由于本项目作者在使用<code>vscode</code>开发<code>c++</code>时经常会遇到无法快捷跳转问题（其实笔者发现有很多人在使用vscode开发时都会有这个问题）， 因此一并把解决方案写入项目中。</p>
<h3 id="vscode-cpp函数快捷跳转">vscode Cpp函数快捷跳转</h3>
<ol type="1">
<li>安装cpp扩展 vscode侧边栏进入扩展选项（ctrl+shift+x)，搜索<code>c++</code>，安装<code>C/C++ Extension Pack</code></li>
<li>打开项目 &gt; File-&gt;Open Folder</li>
<li>保存为工作区 &gt; File-&gt;Save Workspace as 选择目标目录及文件（默认以<code>.code-workspace</code>结尾）</li>
<li>打开刚才保存的工作区文件 &gt; File-&gt;Open File 选择刚才打开的工作区文件</li>
<li>对工作区添加<code>c++</code>库检索路径 在刚才打开的工作区文件中，参考以下格式编辑 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;folders&quot;:</span> [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;path&quot;:</span> <span class="string">&quot;../Simple-LIO-SAM&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.includePath&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/**&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/c++/9/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/8/include/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/include/**&quot;</span>,</span><br><span class="line"></span><br><span class="line">			<span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">//</span> <span class="string">重点！！这里的路径要设置为ros2工作空间下spl_lio_sam编译出来的头文件</span></span><br><span class="line">			<span class="string">&quot;/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam&quot;</span></span><br><span class="line"></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;C_Cpp.files.exclude&quot;:</span> &#123;</span><br><span class="line">			<span class="string">&quot;**/.vscode&quot;</span><span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">			<span class="string">&quot;**/.vs&quot;</span><span class="string">:</span> <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cStandard&quot;:</span> <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cppStandard&quot;:</span> <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;python.analysis.include&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.autoComplete.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.analysis.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="对工作区文件的解释">对工作区文件的解释</h3>
<p>其实主要起作用的是工作区文件中<code>settings-&gt;C_Cpp.default.includePath</code>字段内容，vscode的cpp扩展会读取该工作空间文件下 的这个字段，并将里面的路径进行解析加到头文件解析路径中。</p>
<p>这里有两个路径要注意的</p>
<ol type="1">
<li><code>"$&#123;workspaceFolder&#125;/include"</code>，也就是Simple-LIO-SAM仓库下的include路径</li>
<li><code>"/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam"</code>，这个要设置成你的ros工作空间对应的路径</li>
</ol>
<p>另外，如果发现自己路径设置完成，但是有些函数还提示下划线，要看看是不是那些函数是<code>c++17</code>或者更高的标准才支持的特性，在上面的配置文件中 设置c++/c标准为17</p>
<h3 id="其余注意">其余注意</h3>
<ol type="1">
<li>尽量不要用<code>/path/**</code>的格式添加include路径，虽然看起来很省事，但会影响检索效率</li>
<li>刚设置完路径需要等待vscode检索构建数据库，在vscode右下方状态条会提示正在进行检索</li>
<li>上面配置文件中<code>"python.analysis.extraPaths","python.autoComplete.extraPaths","python.analysis.include"</code>是设置python语法提示器的 库检索路径，不同的python提示器插件会使用不同的路径。</li>
</ol>
<h2 id="reference">Reference</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIO-SAM</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258">LIO-SAM paper</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">This Project</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note">LIO-SAM-note</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/lio_sam/intro/" class="post-title-link" itemprop="url">Simple-LIO-SAM——项目简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 19:45:58" itemprop="dateCreated datePublished" datetime="2023-03-13T19:45:58+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——项目简介" href="/2023/03/13/lio_sam/intro/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::d227db67a0df8ebb129db6bbfad2da40" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="liosam介绍">LIOSAM介绍</h2>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>（Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping），紧耦合激光——惯性里程计历程方法。 作者<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan" title="作者Github">TixiaoShan</a>是SLAM届大神，在LIOSAM之前发表过LeGO-LOAM，在LIOSAM之后发布了LVI-SAM，在LIOSAM基础上又加入了语义定位因子。 由于网上关于<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>的解读已经有很多了，这里不会进行太过详细的复述，具体的内容解析会放在后面讲解代码的时候慢慢仔细阐述。</p>
<p>简单来说，LIOSAM整体的框架与其他方法区别在与： 1. 使用因子图作为后端优化框架，将IMU预积分与雷达点云匹配及回环检测等紧耦合 1. 使用当前帧-局部地图匹配而不是对全局地图匹配来加速点云匹配速度 1. 基于位置关系选择回环帧，并使用点云匹配计算回环因子 1. 使用高频IMU并进行简单积分对点云做运动畸变校正</p>
<p>另外，LIOSAM作者的工程功底很好，LIOSAM代码库被github上很多SLAM开源项目作为code base</p>
<h2 id="本项目目的及特点介绍">本项目目的及特点介绍</h2>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>源代码虽然不能说庞大，甚至可以说简单，因为整个代码库主要只要5个文件。 <img src="./imgs/org_files.png" alt="原始src目录" /> 但是里面每个模块都通过ROS的topic与其他模块有紧密的联系。 整个的流程对新手十分不友好，下图是LIOSAM原本运行时的<code>rqt_graph</code></p>
<figure>
<img src="./imgs/org_rqtgraph.png" alt="" /><figcaption>原始rqt_graph</figcaption>
</figure>
<p>第二个复杂之处在与LIOSAM框架设计到的知识点和工具较多，至少要熟悉<code>ROS,gtsam,pcl</code>几个库，算法层面需要熟悉<code>点云匹配、IMU积分、因子图、三维转换</code>等。 对于熟悉SLAM的人来说可能较为简单上手，但是对于新入门的人来说则一开始会一头雾水。</p>
<p>基于上述这些原因，笔者进行了<a href="Simple%20Lio%20Sam">SPL-LIO-SAM</a>项目，希望能够以最大幅度帮助初学者理解<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>框架及里面的算法细节。 本项目对<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>做了如下改进</p>
<h3 id="基于最新的ros2-humble实现">基于最新的ROS2-humble实现</h3>
<p>虽然LIOSAM源码中有一个ros2分支，但该分支的维护者并不是原作者，而且已经长时间没有人维护，且该分支存在一些bug没有被修复。为了能够在进行本项目的学习过程中 熟悉最新的ROS2框架，笔者在LIOSAM的ros2分支基础上，修复了存在的bug，同时将功能较为独立的<code>Transformfusion</code>类抽取成独立的类。</p>
<p>为了便于上手及部署，笔者同时准备了适配的docker镜像供学习者使用。</p>
<h3 id="简化">简化</h3>
<h4 id="话题发布的简化">话题发布的简化</h4>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>原始代码中有很多中间结果的发布，这些中间结果可以用来可视化及调试程序，但是对于学习者和开发者而言不仅意义不大，而且会在初始学习源码阶段误导学习者。 本项目在话题发布上进行<code>大幅度简化</code>，简化后的设计如下： <img src="./imgs/Design-Node%26%26Topics.png" alt="节点及话题设计" /></p>
<p>简化后运行时的<code>rqt_graph</code>: <img src="./imgs/spl_liosam_rosgraph.png" alt="简化后的ros—grpah" /></p>
<h4 id="坐标系简化">坐标系简化</h4>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>中实用的坐标系并不复杂，但是作者提供的<code>urdf</code>包含了太多为了兼容性考虑的坐标系，这些坐标系对于实际运行和理解并没有用。因此，本项目基于ROS对坐标系的约束，将 坐标系关系树简化为如下： <img src="./imgs/Design-CoordinateSystem.png" alt="简化后的坐标系关系" /></p>
<h4 id="保留算法及定义完整性">保留算法及定义完整性</h4>
<p>虽然本项目去除了很多非必要话题，同时对于一些非必要代码也进行了简化，但对一些学习算法有帮助的细节依旧保留。比如激光里程计在发布的时候有<code>mapping/odometry</code>和<code>mapping/odometry_incremental</code>两个话题，两个话题虽然类似但是背后却有很不同的函数，但同时两者合一又不影响算法的运行。因此采取的做法时在代码中保留这部分代码，同时加以解释，但发布时只发布其中一个话题。</p>
<h3 id="完善的注释及流程图">完善的注释及流程图</h3>
<p>网上其实对<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>源码的注释并不少，比如<a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note" title="LIO-SAM-note">LIO-SAM-note</a>和<a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote" title="LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a>，还有一些blog也对源码做了解释，但是都不太完美，同时缺少流程性的组织。本项目借鉴了一些开源项目的注释，并加以完善，可以说，本项目是目前对<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>注释最完善的开源项目。 <img src="./imgs/comments.png" alt="部分注释图" /></p>
<p>为了最为清晰的展示<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>算法不同模块的流程，该项目还对各个模块流程进行梳理，建立了完善的流程图设计 <img src="./imgs/Design-Pipelines.png" alt="Pipeline" /> <img src="./imgs/Design-imageProjection_top0.png" alt="imageProjection_top0" /> <img src="./imgs/Design-imageProjection_top1.png" alt="imageProjection_top0" /></p>
<h2 id="后续章节">后续章节</h2>
<ol type="1">
<li>节一：开发环境搭建及运行</li>
<li>节二：总体流程及utility文件</li>
<li>节三：激光雷达运动畸变矫正模块</li>
<li>节四：点云特征提取模块</li>
<li>节五：Gtsam快速认识</li>
<li>节六：IMU预积分模块</li>
<li>节七：激光里程计模块</li>
<li>节八：坐标系发布模块</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">FastDDS关键概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 18:02:43" itemprop="dateCreated datePublished" datetime="2023-03-13T18:02:43+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/DDS/" itemprop="url" rel="index"><span itemprop="name">DDS</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="FastDDS关键概念" href="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73f7a0f706535d55ad531611b3af6c03" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="架构">架构</h1>
<p>架构图 <img src="./imgs/fast-dds-architecture.svg" alt="架构图" /></p>
<p>域（Domain）的概念 <img src="imgs/domain_concept.jpg" alt="Domain" /> <img src="imgs/dds_domain.svg" alt="Domain" /></p>
<p>数据中心收发模型（DCPS:Data Centric Publisher and Subscriber) <img src="imgs/DataCentricModel.png" alt="DCPS" /></p>
<h1 id="why-need-a-publisher-and-subscriber">Why need a publisher and subscriber</h1>
<blockquote>
<p>These publishers and subscribers don’t need to know about each other ahead of time; they discover each other dynamically at runtime. The data they share is described by a “topic,” and publishers and subscribers send and receive data only for the topics they are interested in. In this pattern, many publishers may publish the same topic, and many subscribers may subscribe to the same topic. Subscribers receive data from all of the publishers that they share a topic with. Publishers send data directly to subscribers, with no need for a broker or centralized application to mediate communications. (https://community.rti.com/static/documentation/connext-dds/6.0.1/doc/manuals/connext_dds/getting_started/cpp11/intro_pubsub_cpp.html)</p>
</blockquote>
<h1 id="notes">Notes</h1>
<p>Publisher 和 Subscriber 负责生成DataWriter&amp;&amp;DataReader，一个Publisher[Subscriber]可以绑定多个DataWriter[DataReader]。每一个DataWriter[DataReader]都会绑定到一个topic，同时可以指定对应的回调函数DataWriterListener[DataReaderListener]</p>
<h1 id="数据监控fastdds-monitor">数据监控——FastDDS Monitor</h1>
<p><a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/getting_started/tutorial.html">FastDDS Monitor Tutorial</a> ## 原理 FastDDS库有一个内嵌的Participant，叫做Statistic Participant，包含在FastDDS的Statistic Module中。该模块不是默认编译的，因此需要在编译FastDDS的时候指明CMake选项。 实际上是用户开发应用时，在构建<strong>DomainParticipants</strong>阶段，如果通过某种方式指明了要将数据统计信息往外发送，则Statistic Module模块就会自动收集信息，然后往固定的topic发送监控数据。FastDDS Monitor通过这些内嵌的topic，可以监控数据的收发情况。</p>
<p><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/statistics/statistics.html">如何打开Statistics DataWriters</a> <a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/getting_started/tutorial.html">如何使用FastDDS Monitor</a></p>
<p><strong>注意，如果编译FastDDS的时候打开Statistics Module模块，由于会发送额外的信息，所以会损失性能</strong> &gt; Consequently, by default, Fast DDS does not compile this module because it may entail affecting the application’s performance.(https://fast-dds.docs.eprosima.com/en/latest/fastdds/statistics/statistics.html)</p>
<figure>
<img src="imgs/monitor.jpg" alt="" /><figcaption>数据监控窗口</figcaption>
</figure>
<h1 id="record-replay">Record &amp;&amp; Replay</h1>
<blockquote>
<p>rosbag2 is a ROS 2 application that can be used to capture DDS messages and store them on an SQLite database which allows inspecting and replaying said messages at a later time.</p>
</blockquote>
<ol type="1">
<li>rosbag2可以将在Topic中传送的数据以SQLite的形式保存</li>
<li>FastDDS没有自己的数据保存和回放工具，官方说明用的是ROS2的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2">rosbag2</a>包。要使用该包来记录和回放FastDDS的数据需要安装ROS2环境和rosbag2</li>
<li>由于rosbag2是用来保存ros2的message的，并不是FastDDS的官方工具，因此如果要用rosbag2回放，需要做较多的配置</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/use_cases/rosbag_capture/rosbag_capture.html#rosbag-capture">使用rosbag-capture</a></p>
<h1 id="limitations">Limitations</h1>
<ol type="1">
<li>没有进程管理和启动工具。ROS/Apollo/XPilot都有属于自己的进程调度系统，可以直接按指定顺序启动多个进程并执行相关调度。</li>
<li>似乎无法实现像ROS的Service这种类似RPC的功能</li>
</ol>
<h1 id="reference-resources-link">Reference &amp;&amp; Resources link</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/eProsima/Fast-DDS">FastDDS Github</a></li>
<li><a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/installation/linux.html">FastDDS Monitor Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/use_cases/rosbag_capture/rosbag_capture.html#rosbag-capture">使用rosbag-capture</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/eProsima/Fast-DDS-python.git">Fast-DDS-Python</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/" class="post-title-link" itemprop="url">经久不衰的卡尔曼滤波器-基础知识及公式推导</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 17:59:59" itemprop="dateCreated datePublished" datetime="2023-03-13T17:59:59+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/%E6%BB%A4%E6%B3%A2/" itemprop="url" rel="index"><span itemprop="name">滤波</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/%E6%BB%A4%E6%B3%A2/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" itemprop="url" rel="index"><span itemprop="name">卡尔曼滤波</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="经久不衰的卡尔曼滤波器-基础知识及公式推导" href="/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::485da1f1f8066e1c77d786731c1e5117" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一卡尔曼滤波器的应用场景">一、卡尔曼滤波器的应用场景</h1>
<p>卡尔曼滤波器之前被广泛用来做动态系统的状态估计、预测。主要的目的就是用来从带噪声的观测量，比如各种传感器的观测（IMU、GPS、里程计等）估计出最优的系统状态（state）。不过要明确强调的是，由于测量都带有噪声，也就是随机性，所以真正准确的状态是无法获知的。</p>
<p>最小二乘法可以从一长串的测量值回归出一个最为匹配的模型。卡尔曼滤波相比于最小二乘法，采用了一种递归的计算方式，也就是每一时刻只需要保存上一时刻的状态。因此可以被用来处理实时任务。</p>
<p>虽然卡尔曼滤波器从美国阿波罗登月计划到如今已有几十年，且目前有更先进的因子图（Factor Graph）算法，但是在很多领域依旧可以看到卡尔曼滤波器的身影，特别是在自动驾驶的各个模块，比如：从IMU的数据（三轴加速度，三轴角速度）计算出运动物体的当前位置。</p>
<h1 id="二卡尔曼滤波器的两个步骤宏观认识">二、卡尔曼滤波器的两个步骤——宏观认识</h1>
<p>卡尔曼滤波包含两个步骤</p>
<ol type="1">
<li>预测（prediction）—— Dynamic model</li>
<li>更新（correction/measurment update）—— Observation model</li>
</ol>
<p>所谓<strong>预测</strong>，就是用一个数学模型，根据当前的传感器输入，直接计算此时系统的状态。可以理解为一个方程的计算就行。</p>
<p>所谓的<strong>更新</strong>，就是在某些时刻或者每一时刻，获取一些系统的状态输入（可以同样是传感器的值），甚至是<strong>预测</strong>阶段中同样的传感器的值，将其当作真值，我们将这个值叫做<strong>测量值</strong>。比较此刻<strong>预测</strong>的系统状态和<strong>测量</strong>的系统状态，对<strong>预测</strong>出的系统状态进行修正，因此也叫<strong>测量更新</strong>（measurment update）。</p>
<figure>
<img src="./imgs/framework.png" alt="" /><figcaption>framework</figcaption>
</figure>
<h1 id="三卡尔曼滤波的几大概念">三、卡尔曼滤波的几大概念</h1>
<h2 id="状态向量state-vector">1、状态向量State Vector</h2>
<p>系统的状态向量包含了系统中我们关心的状态变量，比如速度<span class="math inline">\(\textbf{v}=[v_x, v_y,v_z]\)</span>，距离<span class="math inline">\(\textbf{d}=[d_x, d_y,d_z]\)</span>，加速度<span class="math inline">\(\textbf{a}=[a_x,a_y,a_z]\)</span>等。我们用<span class="math inline">\(\textbf{x}\)</span>表示系统向量 <span class="math display">\[ \textbf{x} = \begin{bmatrix} \textbf{d}\\ \textbf{v}\\ \textbf{a} \end{bmatrix}\\\]</span></p>
<p>因为卡尔曼滤波有两个步骤，我们先以每个时刻都进行测量和修正这两个步骤作为讲解。那么，每一时刻的两个步骤的输出对应两个系统向量，一个是预测的系统向量<span class="math inline">\(\textbf{x}^-\)</span>，一个是修正后的系统向量<span class="math inline">\(\textbf{x}^+\)</span>。</p>
<p><strong><em><strong>ps</strong>:大写字母表示矩阵；小写加粗字母表示向量；小写字母表示变量</em></strong></p>
<h2 id="状态方程预测方程">2、状态方程&amp;&amp;预测方程</h2>
<h3 id="状态方程">状态方程</h3>
<p><strong>状态方程</strong>描述了将上一时刻的状态向量<span class="math inline">\(\textbf{x}_{t-1}\)</span>映射到当前的系统状态<span class="math inline">\(\textbf{x}_t\)</span> <span class="math display">\[ \textbf{x}_t = A_t\textbf{x}_{t-1}+ B_t\textbf{u}_t+\textbf{w}_t \tag{1}\]</span></p>
<p>其中，矩阵<span class="math inline">\(A\)</span>称为转换矩阵（Transition Matrix），<span class="math inline">\(\textbf{u}_t\)</span>是当前时刻的系统输入，矩阵<span class="math inline">\(B\)</span>称为控制矩阵（Control Matrix）反映了系统输入到系统状态的映射关系，<span class="math inline">\(\textbf{w}_t\)</span>是过程噪声，我们假定其符合均值为0，协方差矩阵为<span class="math inline">\(Q_t\)</span>的高斯噪声。这里要注意的有几点：</p>
<ol type="1">
<li>矩阵<span class="math inline">\(A、B\)</span>都随着时间演进进行更新</li>
<li>从公式1的形式可以看出，卡尔曼滤波的数学建模形式是线性方程，这也是卡尔曼滤波的限制之一。扩展卡尔曼滤波器（Extended Kalman Filter）支持非线性模型。</li>
<li>这里的状态方程是一个“准确”的表达，因为不准确的部分已经放在噪声项中，要跟下面的预测方程区分开来。这个“准确”的表达由于有噪声（随机向量），所以我们没办法使用它作为输出，只能用它来分析、推导。</li>
</ol>
<h3 id="预测方程">预测方程</h3>
<p><strong>预测方程</strong>跟状态方程基本一样，要强调的一点是，噪声<span class="math inline">\(\textbf{w}_t\)</span>是均值为0的高斯噪声，因此最大概率对应的值为0，因此我们在预测状态向量的时候其实不用管最后一项 <span class="math display">\[ \hat{\textbf{x}}^-_t = \textbf{A}_t\hat{\textbf{x}}^+_{t-1} + \textbf{B}_t\textbf{u}_t\tag{2}\]</span></p>
<p>这里对系统状态向量上面加上一个帽子表示这是一个估计量，也就是我们实际输出的量。其中<span class="math inline">\(\hat{\textbf{x}}^+ _{t-1}\)</span>表示上一时刻执行完步骤二<strong>更新</strong>后的状态向量，<span class="math inline">\(\hat{\textbf{x}}^- _{t}\)</span>表示当前时候只执行了步骤1<strong>预测</strong>的状态向量。</p>
<h3 id="理解预测方程">理解预测方程</h3>
<p>预测方程（公式2）从形式上看只是把状态方程（公式1）去掉了噪声项，但其中包含了很多含义。其中，要时刻记得的是我们把系统状态当作一个随机向量处理，严格的表述需要引入随机过程的相关知识，但其实没太大必要。由于公式（1）中状态向量是一个随机向量，且噪声项是均值为0的高斯噪声，那么状态向量<span class="math inline">\(\textbf{x}_t\)</span>也满足高斯分布，其最大概率的地方就对应这噪声为0的地方，因此我们有理由将这个概率最大处对应的值当作我们的<strong>预测</strong>。</p>
<figure>
<img src="./imgs/gaussian.png" alt="" /><figcaption>gaussian</figcaption>
</figure>
<h2 id="测量方程测量估计方程">3、测量方程&amp;&amp;测量估计方程</h2>
<h3 id="测量方程">测量方程</h3>
<p><strong>测量方程</strong>反映了系统的测量值和系统状态向量之间的关系 <span class="math display">\[ \textbf{z}_t=H_t\textbf{x}_t+v_t\tag{3}\]</span></p>
<p>其中，<span class="math inline">\(\textbf{z}_t\)</span>是当前时刻的测量值，<span class="math inline">\(H_t\)</span>称为测量矩阵（Measurement Matrix），描述了从系统状态到测量值的转换关系（举一个最简单的关系，系统状态是物体的直线距离，测量值是使用激光笔测出来的光从原点到物体的时间，那么<span class="math inline">\(H\)</span>就是光速的倒数）, <span class="math inline">\(\textbf{v}_t\)</span>是测量噪声，我们假定其符合均值为0，协方差为<span class="math inline">\(R_t\)</span>的高斯噪声。注意这里无论是状态向量还是测量向量都没有加帽子（<span class="math inline">\(\hat{.}\)</span>），表示这是个"准确"的表达式。</p>
<h3 id="测量估计方程">测量估计方程</h3>
<p>同样，我们如果忽略噪声项，就变成了对此时测量量的估计（注意状态向量的上标和角标）：</p>
<p><span class="math display">\[ \hat{\textbf{z}}_t=H_t\hat{\textbf{x}}^-_t\tag{4}\]</span></p>
<h2 id="测量更新方程">4、测量更新方程</h2>
<p>上面给出了对测量量的估计，但是现在的情况是，我们有了一个测量值（通过某些测量方式或者传感器数据），这是一个不需要计算得到的量，我们如何用这个测量得出的量来更新我们对状态向量的估计？这就涉及到测量更新方程，这也是卡尔曼滤波里最难的部分，这里先给出更新方程的形式。</p>
<p><span class="math display">\[ \hat{\textbf{x}}^+_t=\hat{\textbf{x}}^-_t+K_t(z_t-H_t\hat{\textbf{x}}^-_t)\tag{5}\]</span> <span class="math display">\[ K_t=\frac{P^-_tH_t^T}{H_tP^-_tH_t^T+R_t}\tag{6}\]</span></p>
<p>其中，<span class="math inline">\(K_t\)</span>叫做卡尔曼增益；<span class="math inline">\(P^-_t\)</span>是系统测量值<span class="math inline">\(\hat{\textbf{x}}^-_t\)</span>的误差协方差矩阵。</p>
<h1 id="四误差和协方差矩阵">四、误差和协方差矩阵</h1>
<p>根据公式（1）减去公式（2），我们可以得出误差的协方差矩阵的表达形式</p>
<p><span class="math display">\[ e^-_t \triangleq \textbf{x}_t - \hat{\textbf{x}}^-_t\\\]</span> <span class="math display">\[ P^-_t = \mathbb{E}[\textbf{e}^-_t {\textbf{e}^{-}_{t}}^T]\\\]</span></p>
<p>把公式（1）和（2）带入误差表达式，可以推导出系统状态的协方差矩阵的递归表达形式</p>
<p><span class="math display">\[
\begin{split}
P^-_t&amp;=\mathbb{E}[\big((A_tx_{t-1}+w_t)-A_tx_{t-1}^+\big)\big((A_tx_{t-1}+w_t)-A_tx_{t-1}^+\big)^T]\\&amp;=\mathbb{E}[\big(A_t(x_{t-1}-x_{t-1}^+)+w_t\big)\big(A_t(x_{t-1}-x_{t-1}^+)+w_t\big)^T]\\ &amp;=\mathbb{E}[A_t(x_{t-1}-x_{t-1}^+)(x_{t-1}-x_{t-1}^+)^TA_t^T]+\mathbb{E}[w_tw_t^T]\\ &amp;=A_tP_{t-1}^+A_t^T+Q_t
\end{split}\\\]</span></p>
<p>其中，从第二个等号到第三个等号利用了状态向量和随机噪声 的无关性（协方差为0）。因此我们可以得到下面的公式（7）</p>
<p><span class="math display">\[P^-_t=A_tP^+_{t-1}A^T_t+Q_t\tag{7}\]</span></p>
<h1 id="五更新方程的推导">五、更新方程的推导</h1>
<p>现在我们进行到了这样的情况，我们使用预测方程公式（2）得到了<span class="math inline">\(t\)</span>时刻的系统状态预测量<span class="math inline">\(\textbf{x}_t^-\)</span>；同时，我们在这个时刻得到了一个测量值，且根据测量方程，我们认为它与此时的状态向量满足公式（3）：<span class="math inline">\(\textbf{z}_t=H_t\textbf{x}_t+v_t\)</span> 。那么其实我们可以从公式（3）也得到此时系统状态的另一个估计，由公式（3）将 移动到等式左侧，可以得到：</p>
<p><span class="math display">\[\textbf{x}^2_t = \textbf{H}_t^{-1}\textbf{z}_t\\\]</span></p>
<p>这里之所以没有把噪声<span class="math inline">\(\textbf{v}_t\)</span>表示出来，是因为这里将 当作一个随机向量处理，其均值为<span class="math inline">\(\bar{z}_t\)</span>，也就是当前时刻测量得出的量；其方差为<span class="math inline">\(R_t\)</span>（在公式3中给出）</p>
<p>我们的状态方程也给出了状态向量的一个等式 <span class="math display">\[ \textbf{x}^1_t = \textbf{A}_t\textbf{x}_{t-1}+ \textbf{B}_t\textbf{u}_t+w_t\]</span></p>
<p>这里用<strong>上标1和2</strong>表示状态向量的两个来源。要强调的是，这两个等式里面都包含了一个随机噪声，因此$^1_t 、^2_t $都是随机向量。同时，他们的分布都符合高斯分布。它们的均值和方差分别是：</p>
<p><span class="math display">\[
\begin{split} &amp;\mu_1=x_t^-\\ &amp;\sigma_1^2=P_t^-\\ &amp;\mu_2=H_t^{-1}\bar{z}_t\\ &amp;\sigma_2^2=H_t^{-1}R_t(H_t^{-1})^T\\  \end{split}\\\]</span></p>
<p>现在有了两个关于状态向量的概率分布，那接下来的事情就简单了。因为这两个状态向量的来源我们可以认为是独立的，因此他们的联合概率分布是各自概率分布的乘积。重点是，高斯分布的乘积依旧是高斯分布！！！！新的高斯分布的均值和方差有如下表达形式：</p>
<figure>
<img src="./imgs/joint_gaussian.png" alt="" /><figcaption>joint gaussian</figcaption>
</figure>
<p>用上面的式子代入，可以得到联合概率分布的均值和方差： <strong>均值</strong> <span class="math display">\[ \begin{split} \mu_{fused}&amp;=\frac{\mu_1\sigma_2^2+\mu_2\sigma_1^2}{\sigma_1^2+\sigma_2^2}\\ &amp;=\mu_1+\frac{(\mu_2-\mu_1)\sigma_1^2}{\sigma_1^2+\sigma_2^2}\\ &amp;=x_t^-+\frac{(H_t^{-1}\bar{z}_t-x_t^-)P_t^-}{P_t^-+H_t^{-1}R_t(H_t^{-1})^T}\\ &amp;=x_t^-+\frac{P_t^-H_t^T}{H_tP_t^-H_t^T+R_t}(\bar{z}_t-H_tx_t^-)\\ &amp;=x_t^-+K_t(\bar{z}_t-H_tx_t^-) \end{split}\\\]</span></p>
<p><strong>方差</strong></p>
<p><span class="math display">\[
\begin{split} \sigma_{fused}^2 &amp;=\frac{\sigma_1^2\sigma_2^2}{\sigma_1^2+\sigma_2^2}\\ &amp;=\sigma_1^2-\frac{\sigma_1^4}{\sigma_1^2+\sigma_2^2}\\ &amp;=P_t^--\frac{P_t^-H_t^TH_tP_t^-}{H_tP_t^-H_t^T+R_t}\\ &amp;=P_t^--K_tH_tP_t^- \end{split}\\\]</span></p>
<p>这个<span class="math inline">\(\sigma_{fused}^2\)</span>就是更新后的系统状态误差的协方差矩阵，也就是得到下面的式子</p>
<p><span class="math display">\[ P^+_{t}=P^-_t-K_tH_tP^-_t\tag{8}\]</span></p>
<h1 id="六总结">六、总结</h1>
<p><strong>预测方程</strong> <span class="math display">\[ \hat{\textbf{x}}^-_t = \textbf{A}_t\hat{\textbf{x}}^+_{t-1} + \textbf{B}_t\textbf{u}(t)\tag{2}\]</span> <span class="math display">\[P^-_t=A_tP^+_{t-1}A^T_t+Q_t\tag{7}\]</span></p>
<p><strong>更新方程</strong> <span class="math display">\[ \hat{\textbf{x}}^+_t=\hat{\textbf{x}}^-_t+K_t(z_t-H_t\hat{\textbf{x}}^-_t)\tag{5}\]</span> <span class="math display">\[ K_t=\frac{P^-_tH_t^T}{H_tP^-_tH_t^T+R_t}\tag{6} \]</span> <span class="math display">\[ P^+_{t}=P^-_t-K_tH_tP^-_t\tag{8} \]</span></p>
<hr />
<h1 id="转载须知">转载须知</h1>
<ol type="1">
<li>请于文章标题注明转载</li>
<li>请于文章起始位置注明原始链接</li>
<li>请在推文文末的【阅读原文】链接上原始链接</li>
<li>感谢~</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/kalman_filter/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2-%E5%90%AB%E4%BE%8B%E5%AD%90%E5%8F%8A%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/kalman_filter/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2-%E5%90%AB%E4%BE%8B%E5%AD%90%E5%8F%8A%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">扩展卡尔曼滤波-含例子及代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 17:58:21" itemprop="dateCreated datePublished" datetime="2023-03-13T17:58:21+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/%E6%BB%A4%E6%B3%A2/" itemprop="url" rel="index"><span itemprop="name">滤波</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/%E6%BB%A4%E6%B3%A2/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" itemprop="url" rel="index"><span itemprop="name">卡尔曼滤波</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="扩展卡尔曼滤波-含例子及代码" href="/2023/03/13/kalman_filter/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2-%E5%90%AB%E4%BE%8B%E5%AD%90%E5%8F%8A%E4%BB%A3%E7%A0%81/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::625693331e78b31e9faa26065f21d020" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述">概述</h1>
<p>卡尔曼滤波器在1960年被卡尔曼发明之后，被广泛应用在动态系统预测。在自动驾驶、机器人、AR领域等应用广泛。卡尔曼滤波器使用类似马尔可夫链的性质，假设系统状态只与上一时刻的系统状态有关。基础的卡尔曼滤波器使用线型方程对系统状态进行建模。为了能够应用到非线性系统，扩展卡尔曼滤波器利用泰勒展开，并只保留一次项，抛弃高次项，将非线性关系近似为线性关系。</p>
<p>这一篇文章对扩展卡尔曼滤波器（EKF:Extended Kalman Filter）的具体步骤和公式进行讲解。由于EKF是KF在非线性关系下的扩展，因此必须要先对卡尔曼滤波有必要的认识：</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/578920168">卡尔曼滤波器的基础知识及公式推导</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf">Kalman Filter的原始论文</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kalman_filter#Derivations">准确的公式推导-wiki</a></li>
</ol>
<p>PS：上面的资料2原始论文较为学术化，资料1较为通俗易懂。维基百科中对公式推导部分较为完善。看其中任何一份资料都可以掌握对卡尔曼滤波的基本认识。</p>
<h1 id="卡尔曼滤波器回顾">卡尔曼滤波器回顾</h1>
<p><strong>状态方程和观测方程</strong> <span class="math display">\[x_t = A_tx_{t-1}+B_tu_t+w_t\tag{1}\]</span> <span class="math display">\[z_t = Hx_t+v_t\tag{2}\]</span> 其中<span class="math inline">\(x_t \in\mathbb{R}^n\)</span>是系统状态向量，<span class="math inline">\(z_t\in\mathbb{R}^m\)</span>是测量向量。<span class="math inline">\(w_t,v_t\)</span>分别是过程噪声和观测噪声，且满足高斯分布 <span class="math display">\[w_t\sim N(0,Q_t)\]</span> <span class="math display">\[v_t\sim N(0,R_t)\]</span> <strong>预测过程</strong> <span class="math display">\[\hat{x}_t^-=A_t\hat{x}_{t-1}^++B_tu_t\tag{3}\]</span> <span class="math display">\[P_t^-=A_tP_{t-1}^+A_t^T+Q_t\tag{4}\]</span> 其中，<span class="math inline">\(P_t^-\)</span>是先验状态的误差协方差矩阵 <span class="math display">\[P_t^-\triangleq \mathbb{E}[(x_t-\hat{x}_t^-)(x_t-\hat{x}_t^-)^T]\]</span></p>
<p><strong>更新过程</strong> <span class="math display">\[\tilde{y}_t=z_t-H_t\hat{x}_t^-\]</span> <span class="math display">\[S_t=H_tP_t^-H_t^T+R_t\]</span> <span class="math display">\[K_t=P_t^-H_t^TS_t^{-1}\tag{5}\]</span> <span class="math display">\[x_t^+=x_t^-+K_t\tilde{y}_t\tag{6}\]</span> <span class="math display">\[P_t^+=(I-K_tH_t)P_t^-\tag{7}\]</span></p>
<h1 id="扩展卡尔曼滤波器">扩展卡尔曼滤波器</h1>
<p>卡尔曼滤波器建立在线性的状态方程和测量方程也就是公式（1）和公式（2）。但是在实际应用中，更多的关系是非线形关系，比如如何从连续的角速度计算出车辆当前的姿态角等。为了能够利用基本卡尔曼滤波器的预测和更新过程，对于非线性的状态方程和观测方程，我们利用一阶的泰勒展开，将非线性公式近似为线性公式。</p>
<h2 id="状态方程及观测方程">状态方程及观测方程</h2>
<p><span class="math display">\[x_t=f(x_{t-1}, u_t, w_t)\tag{8}\]</span> <span class="math display">\[z_t=h(x_t,v_t)\tag{9}\]</span> 公式（8-9）可以类比基础卡尔曼滤波器中的公式（1-2） ## 一阶泰勒展开 我们先假设已知<span class="math inline">\(t-1\)</span>时刻滤波器的输出，也就是<span class="math inline">\(t-1\)</span>时刻的状态后验，以及对应的协方差矩阵为 <span class="math display">\[\hat{x}_{t-1}^+,P_{t-1}^+\]</span> 同时，我们令<span class="math inline">\(x_t\)</span>的先验为 <span class="math display">\[\hat{x}_t^-=f(\hat{x}_{t-1}^+, u_t, 0)\tag{10}\]</span> <strong>公式（10）可类比公式（3）</strong></p>
<p>对公式（8）在<span class="math inline">\(\hat{x}_{t}^-\)</span>这一点做展开，并只保留一次项 <span class="math display">\[x_t\approx \hat{x}_t^-+A_t(x_{t-1}-\hat{x}_{t-1}^+)+W_tw_t\tag{11}\]</span> 同时，对公式（9）在<span class="math inline">\(\hat{z}_t^-=h(\hat{x}_t^-,0)\)</span>这一点做泰勒展开，并只保留一次项 <span class="math display">\[z_t\approx \hat{z}_t^-+H(x_t-\hat{x}_t^-)+V_tv_t\tag{12}\]</span></p>
<p>在公式（11）和公式（12）中： - <span class="math display">\[A_{[i,j]}=\frac{\partial f_{i}}{\partial x_j}(\hat{x}_{t-1}^+, u_t, 0)\]</span> - <span class="math display">\[W_{[i,j]}=\frac{\partial f_i}{\partial w_j}(\hat{x}_{t-1}^+, u_t, 0)\]</span> - <span class="math display">\[H_{[i,j]}=\frac{\partial h_i}{\partial x_j}(\hat{x}_t^-,0)\]</span> - <span class="math display">\[V_{[i,j]}=\frac{\partial h_i}{\partial v_j}(\hat{x}_t^-,0)\]</span></p>
<p>经过泰勒展开后，我们得到了非线性的状态方程和观测方程的线性近似。同样，我们可以将公式（11-12）类比公式（1-2） ## 预测方程及状态协方差矩阵 <span class="math display">\[\hat{x}_t^-=f(\hat{x}_{t-1}^+,u_t,0)\tag{13}\]</span> <span class="math display">\[P_t^-=A_tP_{t-1}^-A_t^T+W_tQ_tW_t^T\tag{14}\]</span> 其中，公式（14）中的第二项，因为在线性近似方程（11）中，噪声项满足分布 <span class="math display">\[W_tw_t\sim N(0, W_tQW_t^T)\]</span> <strong><em>公式（13-14）可以类比公式（3-4）</em></strong></p>
<h2 id="更新方程及卡尔曼增益">更新方程及卡尔曼增益</h2>
<p><span class="math display">\[\tilde{y}_t=z_t-h(\hat{x}_t^-,0)\]</span> <span class="math display">\[S_t=H_tP_t^-H_t^T+V_tR_tV_t^T\]</span> <span class="math display">\[K_t=P_t^-H_t^TS_t^{-1}\tag{15}\]</span> <span class="math display">\[\hat{x}_t^+=\hat{x}_t^-+K_t\tilde{y_t}\tag{16}\]</span> <span class="math display">\[P_t^+=(I-K_tH_t)P_t^-\tag{17}\]</span></p>
<p><strong><em>公式（15-17）可以类比公式（5-7）</em></strong> # 加性噪声（addtive noise）形式 前面我们将噪声加在EKF的状态方程和观测方程的变量中，一种简化的形式是将噪声加在非线性函数外，变成如下形式 <span class="math display">\[x_t=f(x_{t-1}, u_t)+ w_t\tag{18}\]</span> <span class="math display">\[z_t=h(x_t)+v_t\tag{19}\]</span> 这种加性噪声的形式带来的改变只需要将<span class="math inline">\(P_t^-,S_t\)</span>中第二项的<span class="math inline">\(W_t,V_t\)</span>去掉即可，其余都一样 # 总结 ## 理解 重点还是要理解卡尔曼滤波器的中心思想，如何对预测方程和观测方程建立联系，从系统状态先验和测量得出系统状态的后验。扩展卡尔曼滤波器的最核心之处是利用了一阶泰勒展开，对状态方程上一时刻的后验处展开，对测量方程在状态先验处展开，抛弃高阶项，使得非线性方程能够用线性方程近似。近似后就又可以利用卡尔曼滤波器中的过程进行分析。 ## 缺点 1. EKF毕竟只是做一阶近似，如果近似的点与实际的点偏差较大，一阶近似可能误差就会很大。 2. KF和EKF都假设了马尔可夫性质，也就是此刻的状态只与上一时刻的状态有关，实际中可能不是如此 3. KF和EKF如果在系统状态变量数量太大的情况下，公式中的各个矩阵会呈变量数的平方增长，因此不适合状态变量规模大的情况。</p>
<h1 id="例子">例子</h1>
<p>详细代码可以移步：https://github.com/zeal-github/KalmanFilterTutorial ## 问题 假设有一个小车从原点出发，每个时间间隔<span class="math inline">\(\Delta T\)</span>，车上的传感器可以输出车此时的速度<span class="math inline">\(v_t\)</span>和角速度<span class="math inline">\(\omega_t\)</span>。同时，在原点处有一个探测器，同样可以每个<span class="math inline">\(\Delta T\)</span>的时间间隔，探测出车辆距离原点的距离<span class="math inline">\(d_t\)</span>。 我们希望能够求出小车每一时刻对应的x轴和y轴坐标<span class="math inline">\(a_t,b_t\)</span> <img src="./imgs/示例图.png" alt="例子图" /></p>
<h2 id="状态向量和观测向量">状态向量和观测向量</h2>
<p>我们另小车每一时刻的x，y坐标、此时小车的车身角度，速度和角速度这5个状态当作状态向量，于是 <span class="math display">\[x_t=\begin{bmatrix}a_t\\b_t\\\theta_t\\v_t\\\omega_t\end{bmatrix}\]</span> 同时，另观测向量为距离原点距离的平方、速度、角速度，于是 <span class="math display">\[z_t=\begin{bmatrix}d_t^2\\v_t\\\omega_t\end{bmatrix}\]</span></p>
<h2 id="加性噪声的形式">加性噪声的形式</h2>
<p>为了简化计算过程，我们这里将噪声项提到非线性方程外面，变成加性噪声的形式。也就是公式（18-19）</p>
<h2 id="状态方程观测方程即雅各比矩阵">状态方程、观测方程即雅各比矩阵</h2>
<h3 id="状态方程及求导">状态方程及求导</h3>
<p>小车的x坐标等于上一时刻的x坐标以及这个时间段小车行使过的距离在x轴的投影。小车在每个时间段形式的距离为<span class="math inline">\(v*\Delta T\)</span>；距离在x轴的投影相当于乘上<span class="math inline">\(cos(\theta)\)</span>。y坐标同理。角度则是每一时刻的角速度积分。于是，我们可以写出状态方程： <span class="math display">\[f(x_t,u_t)=\begin{bmatrix}a_t+v_t*\Delta T*cos(\theta_t)\\
b_t+v_t*\Delta T*sin(\theta_t)\\
\theta_t+\omega_t*\Delta T\\
v_t\\
\omega_t\end{bmatrix}\]</span></p>
<p>将函数<span class="math inline">\(f\)</span>相对于状态向量<span class="math inline">\(x_t\)</span>求偏导数，可以得到 <span class="math display">\[A_t=\begin{bmatrix}1,0,v_t*\Delta T*-sin(\theta_t),\Delta T*cos(\theta_t),0\\
0,1,v_t*\Delta T*cos(\theta_t),\Delta T*sin(\theta_t),0\\
0,0,1,0,\Delta T\\
0,0,0,1,0\\
0,0,0,0,1\end{bmatrix}\]</span></p>
<h3 id="观测方程及求导">观测方程及求导</h3>
<p>我们将小车与原点距离的平方、速度、角速度作为观测向量，即 <span class="math display">\[h(x_t)=\begin{bmatrix}a_t^2+b_t^2\\
v_t\\
\omega_t\end{bmatrix}\]</span> 将上述方程对状态方程求偏导数可以得到 <span class="math display">\[H_t=\begin{bmatrix}
2*a_t, 2*b_t, 0, 0, 0\\
0, 0, 0, 1, 0\\
0, 0, 0, 0, 1
\end{bmatrix}\]</span></p>
<h2 id="状态初始化">状态初始化</h2>
<p>系统状态我们可以简单以全0向量作为初始值，即 <span class="math display">\[x_0=[0,0,0,0,0]^T\]</span> 另一个需要初始化的值是状态向量协方差矩阵<span class="math inline">\(P_0\)</span>。经过实验发现在滤波过程对<span class="math inline">\(P_0\)</span>的值似乎有点敏感，主要是不能只有对角线有值。实际上，如果在实际应用中，可以先采集一段数据计算出各个变量的初始值。这里将<span class="math inline">\(P_0\)</span>设为如下值 <span class="math display">\[P_0 = \begin{bmatrix}
10, 10, 1, 0, 0\\
10, 10, 1, 0, 0\\
1, 1, 0.1, 0, 0\\
0, 0, 0, 1e-8, 0\\
0, 0, 0, 0, 1e-8\\
\end{bmatrix}\]</span></p>
<h2 id="过程噪声和观测噪声">过程噪声和观测噪声</h2>
<p>过程噪声的协方差和观测噪声的协方差矩阵我们设置为一个较小的值即可。只不过这里的<span class="math inline">\(Q\)</span>矩阵似乎比较敏感。而且由于我们用了速度和角速度做积分，而另外一个观测量距离并不能为角度提供更多的信息。因此，对于角度，这里并不能得到比简单的积分好很多的结果。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过程噪声的协方差，需要调整的参数</span></span><br><span class="line">Q = np.array([</span><br><span class="line">    [<span class="number">0.01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0001</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.01</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观测噪声协方差矩阵</span></span><br><span class="line">R = np.array([</span><br><span class="line">    [<span class="number">0.0001</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.</span>, <span class="number">0.0001</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0001</span>]</span><br><span class="line">]) <span class="comment"># 观测噪声的协方差，需要调整的参数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="卡尔曼滤波过程">卡尔曼滤波过程</h2>
<p>有了上面的雅各比矩阵推导，就可以利用公式（13-17）进行滤波过程。过程只用了到一些矩阵乘法，十分简单。具体可以看代码。</p>
<h2 id="结果">结果</h2>
<p>代码里生成了完美的观测量和带噪声的观测量，同时，利用直接的积分算法完美的状态和带噪声的状态，将其与卡尔曼滤波的结果做对比。结果如下 <img src="imgs/all_result.png" alt="所有结果" /></p>
<p>将完美的轨迹、直接对带噪声信号积分的轨迹和卡尔曼滤波的结果可视化 <img src="imgs/traj_result.png" alt="轨迹结果" /> 可以看出，卡尔曼滤波的轨迹还是要更贴近真实的轨迹很多</p>
<h1 id="思考">思考</h1>
<ol type="1">
<li>卡尔曼滤波的过程很像自动驾驶中多传感器融合的过程。每一个传感器的输出都是带噪声不完美的。同时，每一种传感器的输出形式都不一样。卡尔曼滤波可以将多传感器统一到状态向量的表达，同时求出一个满足各个传感器限制的最优量。比如例子中，实际上将距离原点的距离弥补到直接使用速度和角速度的积分结果中。</li>
<li>扩展卡尔曼滤波似乎对各个协方差的初始值和观测噪声的协方差更敏感，如何通过已有信息设置初始值目前还没有找到很好的方法。同时，在例子中使用加性噪声的形式，观测噪声协方差和观测噪声协方差均是常量。不知道用完整形式会不会更鲁棒。</li>
<li>如何设计状态向量和观测向量是门学问，不是简单思考就可以得出，还是得基于别人的公式和形式构造。</li>
</ol>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/578920168">卡尔曼滤波器的基础知识及公式推导</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf">Kalman Filter的原始论文</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/archives/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywzGuJ0w","appkey":"7c4a236bb42c7db38424a76bf68ccf99","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
