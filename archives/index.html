<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeal-up.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录及分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeal&#39;s Blog">
<meta property="og:url" content="https://zeal-up.github.io/archives/index.html">
<meta property="og:site_name" content="Zeal&#39;s Blog">
<meta property="og:description" content="学习记录及分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeal">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeal-up.github.io/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeal's Blog</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SE75EDBKX6","only_pageview":true}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/zeal-up" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeal's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习～天天向上～</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zeal</p>
  <div class="site-description" itemprop="description">学习记录及分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/06/12/slam-theory/manifold-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/12/slam-theory/manifold-integration/" class="post-title-link" itemprop="url">从IMU预积分理解最大后验概率问题及李代数应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-12 17:36:16" itemprop="dateCreated datePublished" datetime="2023-06-12T17:36:16+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 16:15:51" itemprop="dateModified" datetime="2023-06-14T16:15:51+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/06/12/slam-theory/manifold-integration/" class="post-meta-item leancloud_visitors" data-flag-title="从IMU预积分理解最大后验概率问题及李代数应用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="从IMU预积分理解最大后验概率问题及李代数应用" href="/2023/06/12/slam-theory/manifold-integration/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6de792b20332fd968c280dccbaee3292" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="本文内容">本文内容</h2>
<p>为了能够更深刻地理解</p>
<ol type="1">
<li>后端优化中的最小二乘问题</li>
<li>李代数在定位后端的应用</li>
</ol>
<p>这两个问题，本文使用IMU预积分作为一个实际问题来联系上面两个内容。IMU预积分可以在欧拉角表达下进行，但是更优的方法是在流形（特殊正交群<span class="math inline">\(SO(3)\)</span>是一种流形）上进行。因此，本文使用论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1512.02363">《On-Manifold Preintegration for Real-TimeVisual-Inertial Odometry》</a>提出的IMU预积分方法作为应用实例，在讲述方法的同时将上面两个问题结合其中，使得读者不止对理论基础能够有所了解，也能够明白最小二乘和李代数是如何被用来解决实际问题的。</p>
<h2 id="一基础理论知识">一、基础理论知识</h2>
<p>关于定位后端优化是如何从最大后验概率形式变成最小二乘问题，可以阅读笔者的两篇文章：《后端优化如何从最大后验概率到最小二乘（理论篇）/（应用篇）》</p>
<p>关于李代数基础知识可以阅读笔者这篇文章：《SLAM/定位中李代数基础概念及公式》（李代数基础知识也可以阅读SLAM十四讲的相应内容）</p>
<h3 id="重要定理性质备忘">重要定理/性质备忘</h3>
<p>PS:这部分直接跳过，后文推导过程中使用到这些性质再回头看即可</p>
<p><strong>斜对称矩阵性质</strong></p>
<p><span class="math display">\[
\begin{array}{lcl}
\boldsymbol{a}^{\wedge}\boldsymbol{b} = -\boldsymbol{b}^{\wedge}\boldsymbol{a} &amp;&amp; \forall \boldsymbol{a,b} \in \mathbb{R}^3
\end{array}\tag{1-1}
\]</span></p>
<p><strong>指数映射公式</strong></p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge}) = \mathbf{I}+\frac{\sin{(||\boldsymbol{\phi}||)}}{||\boldsymbol{\phi}||}\boldsymbol{\phi}^{\wedge}+\frac{1-\cos{(||\boldsymbol{\phi}||)}}{||\boldsymbol{\phi}||^2}(\boldsymbol{\phi}^{\wedge})^2\tag{1-2}
\]</span></p>
<p><strong>指数映射一阶近似</strong></p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge})\approx \mathbf{I}+\boldsymbol{\phi}^{\wedge}\tag{1-3}
\]</span></p>
<p><strong>向量形式的指数/对数映射</strong></p>
<p>为了方便，我们记<span class="math inline">\(\operatorname{Exp}(\cdot)\)</span>和<span class="math inline">\(\operatorname{Log}(\cdot)\)</span>为向量形式的对数和指数映射</p>
<p><span class="math display">\[
\begin{array}{}
\operatorname{Exp}:&amp;\mathbb{R}^3 \rightarrow SO(3)\\
\operatorname{Log}:&amp;SO(3)\rightarrow \mathbb{R}^3
\end{array}\tag{1-4}
\]</span></p>
<p><strong>BCH一阶近似</strong></p>
<p><span class="math display">\[
\operatorname{Exp}(\phi+\delta{\phi})\approx \operatorname{Exp}(\phi)\operatorname{Exp}(J_r(\phi)\delta{\phi})\tag{1-5}
\]</span></p>
<p>其中，<span class="math inline">\(J_r(\phi)\)</span>称为右雅可比矩阵</p>
<p>BCH一阶近似还有另一种写法</p>
<p><span class="math display">\[
\operatorname{Log}\left(\operatorname{Exp}(\phi)\operatorname{Exp}(\delta{\phi})\right)\approx 
\phi + J_r^{-1}(\phi)\delta{\phi}\tag{1-6}
\]</span></p>
<p><strong>指数映射性质</strong></p>
<p><span class="math display">\[
R\operatorname{Exp}(\phi)R^T=\operatorname{Exp}(R\phi^{\wedge}R^T)=\operatorname{Exp}(R\phi)\tag{1-7}
\]</span></p>
<p>上式也可得</p>
<p><span class="math display">\[
\operatorname{Exp}(\phi)R = R\operatorname{Exp}(R^T\phi)\tag{1-8}
\]</span></p>
<p>另有，当<span class="math inline">\(\delta{\phi}\)</span>为微小量</p>
<p><span class="math display">\[
\operatorname{Exp}(-\delta{\phi})^T=\operatorname{Exp}(\delta{\phi})\tag{1-9}
\]</span></p>
<p><strong>右雅可比矩阵性质</strong></p>
<p>在公式（1-5）中的<span class="math inline">\(J_r(\phi)\)</span>，如果<span class="math inline">\(\phi\)</span>是微小量，则其近似为单位矩阵。记为</p>
<p><span class="math display">\[
J_r(\delta{\phi})\approx\mathbf{I},\quad \text{when }\delta{\phi}\text{ is small}\tag{1-10}
\]</span></p>
<p><strong>旋转矩阵的扰动模型</strong></p>
<p>当旋转矩阵的分布具有如下形式：</p>
<p><span class="math display">\[
\tilde{R}=R\operatorname{Exp}(\epsilon),\quad \epsilon \sim \mathcal{N}(0,\Sigma)\tag{1-11}
\]</span></p>
<p>其负对数似然（negative log-likelihood）有如下形式</p>
<p><span class="math display">\[
\begin{split}
\mathcal{L}(R)&amp;=\frac{1}{2}||\operatorname{Log}(R^{-1}\tilde{R})||^2_{\Sigma}+const\\
&amp;=\
\frac{1}{2}||\operatorname{Log}(\tilde{R}^{-1}R)||^2_{\Sigma}+const
\end{split}\tag{1-12}
\]</span></p>
<h2 id="二问题引出">二、问题引出</h2>
<p>目前SLAM方案包含前端和后端。前端使用视觉/激光，融合IMU数据输出一个里程计;后端尝试从历史轨迹和回环检测中优化出更准确的历史位姿。IMU在前后端都承担一个比较重要的角色。IMU数据进行积分，可以的到旋转和位置的估计，这个估计可以用来做视觉/点云匹配的初始位姿。IMU积分需要以某一帧的状态作为基础往下持续累加，但是SLAM后端的优化会改变历史轨迹位姿，导致IMU积分需要重新计算。为了避免重复积分的问题，可以将IMU的积分形式变化为对两个关键帧之间数据进行累积，获得两帧之间的相对状态变化，此称为<strong>IMU预积分</strong></p>
<figure>
<img src="./imgs/01-keyframes_imu_pre.png" alt="" /><figcaption>IMU预积分</figcaption>
</figure>
<h3 id="imu预积分积分">IMU预积分/积分</h3>
<p><strong>IMU积分</strong> : 以某一时刻的状态为基础（位姿、速度），对后续的IMU输出（角速度、加速度）进行积分（累加），得到后续时刻的状态（位姿、速度）</p>
<p><strong>IMU预积分</strong> ： 将两帧之间的IMU输出（角速度、加速度）进行积分（累加），得到两帧之间的相对状态（相对旋转、相对速度、相对位置）</p>
<h3 id="坐标系">坐标系</h3>
<figure>
<img src="./imgs/02-coordinate_system.png" alt="" /><figcaption>坐标系定义</figcaption>
</figure>
<p>本文以视觉惯性SLAM为应用场景。IMU坐标系又称作Body坐标系，相机坐标系（Cam）与Body坐标系有一个固定位姿变换<span class="math inline">\(T_{BC}\)</span>。车辆位姿为车辆在世界（World）坐标系下的姿态<span class="math inline">\(T_{WB}=(R_{WB},_W\boldsymbol{p})\)</span></p>
<h3 id="推导的最终目的重要">推导的最终目的（重要！！）</h3>
<p><strong>推导最终目的是为了能够将预积分后的结果（状态State）构造成最小二乘形式，也就是误差的平方</strong></p>
<p>为了能够获得最小二乘形式，需要将状态构造成真值+高斯噪声的形式，也就是测量值的似然函数，这样，只需要对似然函数取负对数即可。注意，还需要获得噪声的协方差表达，因为协方差的倒数，即信息矩阵，需要用来对二次项加权</p>
<p><span class="math display">\[
\begin{array}{lcl}
\tilde{\mathcal{X}} = \mathcal{X} \oplus \epsilon, &amp;&amp; \epsilon \sim \mathcal{N}\left(0,\Sigma\right)\tag{2-1}
\end{array}
\]</span></p>
<p>上述中<span class="math inline">\(\mathcal{X}\)</span>表示状态，通常是旋转、平移、速度、IMU偏差等。上面公式之所以用复合符号<span class="math inline">\(\oplus\)</span>是因为有些状态变量，比如旋转是不能直接相加的，对于旋转矩阵，<span class="math inline">\(\oplus\)</span>是矩阵乘法</p>
<p>只要我们推导出公式（2-1），就可以将高斯分布用负对数的形式变化为最小二乘形式</p>
<p><span class="math display">\[
\underset{\mathcal{X}}{\operatorname{argmin}}||\tilde{\mathcal{X}}\ominus\mathcal{X}||^2_{\Sigma}\tag{2-2}
\]</span></p>
<p><strong>重申，我们需要推导出以下内容</strong></p>
<ol type="1">
<li>状态向量的高斯分布形式（真值+高斯噪声）</li>
<li>噪声的协方差表达</li>
</ol>
<h3 id="方法要点重要">方法要点（重要！！）</h3>
<ol type="1">
<li>所有的推导都在流形（李群）上推导。本文的推导只用到了特殊正交群<span class="math inline">\(SO(3)\)</span>。这样，优化过程可以在李代数空间上进行，不用考虑旋转矩阵的约束</li>
<li>为了避免优化的时候每一个IMU测量就需要增加一个优化因素，将两个关键帧之间的的所有IMU数据积分作为一个约束加入后端优化。（常见做法）</li>
<li>将IMU的积分公式重新推导成IMU预积分形式，使得当后端优化改变历史位姿时，不需要重新执行积分过程</li>
</ol>
<h3 id="推导过程总述">推导过程总述</h3>
<ol type="1">
<li>根据IMU模型，构造IMU积分形式（在流形上进行推导，使得优化可以在李代数空间上进行，不需要考虑旋转的约束）</li>
<li>将IMU积分公式变化为在两个关键帧之间所有IMU测量的积分</li>
<li>构造状态变化的预积分形式，使得积分过程在历史位姿由于后端优化变化之后不需要重新执行。此时还依赖历史时刻的IMU偏差</li>
<li>将噪声从预积分公式从预积分公式中剥离出来，构造（2-1）的标准形式</li>
<li>推导协方差的递推形式</li>
<li>将历史时刻的Bias从预积分公式中剥离，使得预积分公式完全不依赖历史时刻的状态</li>
<li>推导当IMU偏差更新的时候，如何更新预积分结果，避免重复计算</li>
</ol>
<h2 id="三状态向量及优化目标">三、状态向量及优化目标</h2>
<p>状态向量（State）描述<span class="math inline">\(i\)</span>时刻车辆的旋转、位置、速度、IMU偏差</p>
<p><span class="math display">\[
\textbf{x}_i\overset{\cdot}{=}[\text{R}_i,\textbf{p}_i,\textbf{v}_i,\textbf{b}_i]\tag{3-1}
\]</span></p>
<p>车辆（Body）坐标系与IMU坐标系假设为相同坐标系，因此上式也是<span class="math inline">\(i\)</span>时刻的IMU状态</p>
<p>其中</p>
<ul>
<li><span class="math inline">\(\textbf{v}_i \in \mathbb{R}^3\)</span></li>
<li><span class="math inline">\(\textbf{b}_i = [\textbf{b}_i^g \quad \textbf{b}_i^a] \in \mathbb{R}^6\)</span>是角速度（gyroscope）和加速度（accelerometer）的偏差</li>
</ul>
<hr />
<p><strong>记下列符号</strong></p>
<ul>
<li><p><span class="math inline">\(\mathcal{K}_k\)</span>为<span class="math inline">\(k\)</span>时刻之前的所有关键帧</p></li>
<li><p>并记状态集合为</p></li>
</ul>
<p><span class="math display">\[
\mathcal{X}_k \overset{\cdot}{=}\{\textbf{x}_i\}_{i\in \mathcal{K}_k}\tag{3-2}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathcal{I}_{ij},(i,j)\in \mathcal{K}_k\)</span>为关键帧<span class="math inline">\(i,j\)</span>之间的所有IMU测量</li>
</ul>
<hr />
<p>似然函数</p>
<p><span class="math display">\[
\begin{split}
p(\mathcal{X}_k|\mathcal{I}_k) &amp; \propto p(\mathcal{X}_0)p(\mathcal{I}_k|\mathcal{X}_k)\\
&amp;=\
p(\mathcal{X}_0)\prod_{(i,j)\in \mathcal{K}_k}p(\mathcal{I}_{ij}|\textbf{x}_i, \textbf{x}_j)
\end{split}\tag{3-3}
\]</span></p>
<p>其中用到了独立同分布性质和马尔可夫假设</p>
<hr />
<p>优化的最小二乘形式</p>
<p><span class="math display">\[
\begin{split}
\mathcal{X}^{*}_k
&amp;=\
\underset{\mathcal{K}_k}{\operatorname{argmin}} -\log_ep(\mathcal{X}_k|\mathcal{I}_k)\\
&amp;=\
\underset{\mathcal{K}_k}{\operatorname{argmin}}\sum_{(i,j)\in \mathcal{K}_k}||\mathbf{r}_{\mathcal{I}_{ij}}||^2_{\Sigma_{ij}} + ||\textbf{r}_0||^2_{\Sigma_0}
\end{split}\tag{3-4}
\]</span></p>
<h2 id="四imu模型">四、IMU模型</h2>
<p><span class="math display">\[
_\text{B}\tilde{\boldsymbol{\omega}}(t)= {_\text{B}\boldsymbol{\omega(t)}} + \textbf{b}^g(t)+ \boldsymbol{\eta}^g(t)\tag{4-1}
\]</span></p>
<p><span class="math display">\[
_\text{B}\tilde{\textbf{a}}(t)=R^T_{\text{WB}}(t)\left({_\text{W}\textbf{a}(t)} - {_\text{W}\textbf{g}}\right) + \textbf{b}^a(t) + \boldsymbol{\eta}^a(t)\tag{4-2}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(_\text{B}\)</span> 前下标意味着该量是在Body坐标系下。如 <span class="math inline">\(_\text{B}\tilde{\boldsymbol{\omega}}(t)\)</span>是在Body坐标系下的角速度，也就是IMU陀螺仪的输出</li>
<li><span class="math inline">\(\textbf{b}^g,\textbf{b}^a\)</span>是IMU角速度和加速度的偏差，这两者也是一个随着时间缓慢变化的量</li>
<li><span class="math inline">\(\boldsymbol{\eta}^g, \boldsymbol{\eta}^a\)</span>是角速度和加速度的噪声。均值为0的高斯噪声</li>
</ul>
<p>对于离散（discret）形式的高斯噪声<span class="math inline">\(\boldsymbol{\eta}^{gd}, \boldsymbol{\eta}^{ad}\)</span>，他们的协方差与连续形式高斯噪声的功率谱强度具有如下关系</p>
<p><span class="math display">\[
\text{Cov}(\boldsymbol{\eta}^{gd}) = \frac{1}{\Delta{t}}\text{Cov}(\boldsymbol{\eta}^{g})\tag{4-3}
\]</span></p>
<p>其中<span class="math inline">\(\Delta{t}\)</span>是采样时间周期</p>
<h2 id="五运动模型及积分">五、运动模型及积分</h2>
<p><strong><em>为了使得整体思路清晰，简化推导过程，后文都会重点放在状态向量中的旋转部分</em></strong></p>
<h3 id="运动模型">运动模型</h3>
<p><span class="math display">\[
\begin{split}
&amp;\dot{R}_{\text{WB}}=R_{\text{WB}}\ {_{\text{B}}\boldsymbol{\omega}^{\wedge}}\\
\end{split}\tag{5-1}
\]</span></p>
<p>上式中<span class="math inline">\(\dot{R}_{\text{WB}}\)</span>表示<span class="math inline">\({R}_{\text{WB}}\)</span>的导数。上式是旋转矩阵角运动方程，具体推导过程读者可以查找旋转矩阵求导相关资料</p>
<h3 id="运动模型的积分">运动模型的积分</h3>
<p>假设<span class="math inline">\(_{\text{B}}\boldsymbol{\omega}\)</span>在时间间隔<span class="math inline">\([t,t+\Delta{t}]\)</span>内保持不变，则公式（5-1）的<strong>离散形式积分</strong> 为</p>
<p><span class="math display">\[
R_{\text{WB}}(t+\Delta{t})=R_{\text{WB}}(t)\operatorname{Exp}\Big({_{\text{B}}\boldsymbol{\omega}}(t)\Delta{t}\Big)\tag{5-2}
\]</span></p>
<p>公式（5-2）是微分方程（5-1）的解。如果这里思维卡住了，不要深究，记住（5-2）的结论即可</p>
<p>将IMU模型——公式（4-1）带入公式（5-1），可得</p>
<p><span class="math display">\[
R(t+\Delta{t})=R(t)\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}(t)-\textbf{b}^g(t)-\boldsymbol{\eta}^{gd}(t)\right)\Delta{t}\Big) \tag{5-3}
\]</span></p>
<p>上式中<span class="math inline">\(\boldsymbol{\eta}^{gd}(t)\)</span>是高斯噪声的离散形式，且协方差与连续形式的功率谱强度有公式（4-3）的联系</p>
<p>公式（5-3）去掉了上下标，不过现在应该不会引起歧义了</p>
<p><strong><em>要注意的是</em></strong> ，公式（5-3）是假设在IMU的采样周期<span class="math inline">\(\Delta{t}\)</span>内角速度是不变的，这一点虽然不是事实，但是可以通过较高频率的IMU避免由于这一点引起的误差。（常见的IMU频率为200-500Hz）</p>
<h3 id="运动模型积分的累积形式">运动模型积分的累积形式</h3>
<p>公式（5-3）是对一个IMU的测量数据做积分，为了得到两个关键帧之间的积分，我们将关键帧<span class="math inline">\((i,j)\)</span>之间的所有IMU测量都累计起来，可以得到如下形式</p>
<p><span class="math display">\[
R_j = R_i\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{5-4}
\]</span></p>
<p>由于偏差是缓慢变化的（所谓的布朗运动，也就是白噪声的积分），所以在本文中，我们令关键帧<span class="math inline">\((i,j)\)</span>之间的偏差保持不变</p>
<p><span class="math display">\[
\boldsymbol{\eta}^{gd}_i=\boldsymbol{\eta}^{gd}_{i+1}=...=\boldsymbol{\eta}^{gd}_{j-1}\tag{5-5}
\]</span></p>
<h2 id="六预积分相对增量形式">六、预积分/相对增量形式</h2>
<p>公式（5-4）让我们根据IMU的输出得到了两帧之间旋转的约束，但是公式（5-4）等号的右侧与<span class="math inline">\(i\)</span>时刻的旋转和 <strong>偏差</strong> 相关，也就是与<span class="math inline">\(i\)</span>时刻的状态 <span class="math inline">\(\textbf{x}_i\)</span>相关。这里的缺憾在于，当我们在后端优化对历史轨迹优化之后，<span class="math inline">\(\textbf{x}_i\)</span>会改变，这样公式（5-4）就需要重新计算。为了避免重复计算，我们将公式（5-4）进行调整为相对增量形式</p>
<p><span class="math display">\[
\Delta{R_{ij}}\overset{\cdot}{=}\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{6-1}
\]</span></p>
<p><strong><em>要注意的是</em></strong> ，公式（6-1）依旧与<span class="math inline">\(i\)</span>时刻的偏差<span class="math inline">\(\boldsymbol{\eta}^{gd}_i\)</span>。我们暂时忽略这一点。在第九节，我们推导当偏差改变的时候，如何避免重复计算公式（6-1）</p>
<h2 id="七将噪声项独立构造高斯分布形式">七、将噪声项独立构造高斯分布形式</h2>
<p>公式（6-1）已经使用IMU的输出将<span class="math inline">\(i,j\)</span>时刻的旋转联系起来。但是公式（6-1）之中将噪声项杂糅在各个累积项之中，这导致了我们无法简单地写出<span class="math inline">\(\Delta{R_{ij}}\)</span>的概率分布函数。回顾第二节，我们的目标是构造标准的测量方程形式（2-1），这样我们才可以将MAP问题改写为最小二乘问题。为了达到这一个目的，我们进一步将噪声项独立出来</p>
<p>我们首先利用BCH一阶近似公式，即公式（1-5），将噪声项独立。公式（6-1）可以写成</p>
<p><span class="math display">\[
\Delta{R_{ij}}\overset{eq(1-5)}{\approx}\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_i\right) \Delta{t} \Big)\
\operatorname{Exp}\left(-J_r^k\boldsymbol{\eta}^{gd}_k\Delta{t}\right)\tag{7-1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
J_r^k \overset{\cdot}{=}J_r^k\left(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_i\right)\Delta{t}\right)\tag{7-2}
\]</span></p>
<p>我们记</p>
<p><span class="math display">\[
\Delta{\tilde{R}_{ij}} \overset{\cdot}{=}\
\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_i\right)\Delta{t}\Big)\tag{7-3}
\]</span></p>
<p>观察公式（7-1），我们将累积中的最后两项抽出来</p>
<p><span class="math display">\[
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 2}-\textbf{b}^g_i\right) \Delta{t} \Big)\
\Bigg[\
\operatorname{Exp}\left(-J_r^{j \text{-} 2}\boldsymbol{\eta}^{gd}_{j \text{-} 2}\Delta{t}\right)\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 1}-\textbf{b}^g_i\right) \Delta{t} \Big)\
\Bigg]\
\operatorname{Exp}\left(-J_r^{j \text{-} 1}\boldsymbol{\eta}^{gd}_{j \text{-} 1}\Delta{t}\right)\tag{7-3}
\]</span></p>
<p>利用公式（1-8）<span class="math inline">\(\operatorname{Exp}(\phi)R = R\operatorname{Exp}(R^T\phi)\)</span>，我们可以将中间两项改写如下</p>
<p><span class="math display">\[
\begin{split}
&amp;\operatorname{Exp}\left(-J_r^{j \text{-} 2}\boldsymbol{\eta}^{gd}_{j \text{-} 2}\Delta{t}\right)\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 1}-\textbf{b}^g_i\right) \Delta{t} \Big)\\
=&amp;\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 1}-\textbf{b}^g_i\right) \Delta{t} \Big)\
\operatorname{Exp}\Big(-\Delta{\tilde{R}^T_{j\text{-}1j}}J_r^{j \text{-} 2}\boldsymbol{\eta}^{gd}_{j \text{-} 2}\Delta{t}\Big)
\end{split}\tag{7-4}
\]</span></p>
<p>对公式（7-1）从后往前应用公式（7-4），我们可以将噪声项独立出来</p>
<p><span class="math display">\[
\begin{split}
\Delta{R_{ij}}\
&amp;=\
\Delta{\tilde{R}_{ij}}\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(-\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\Big)\\
&amp;\overset{\cdot}{=}\
\Delta{\tilde{R}_{ij}}\
\operatorname{Exp}(-\delta\phi_{ij})
\end{split}\tag{7-5}
\]</span></p>
<p>于是，我们可以将<span class="math inline">\(\Delta{\tilde{R}_{ij}}\)</span>写为如公式（2-1）的标准形式，回顾公式（1-9）<span class="math inline">\(\operatorname{Exp}(-\delta{\phi})^T=\operatorname{Exp}(\delta{\phi})\)</span></p>
<p><span class="math display">\[
\begin{split}
\Delta{\tilde{R}_{ij}}\
=\
\Delta{R_{ij}}\
\operatorname{Exp}(\delta\phi_{ij})\
\end{split}\tag{7-6}
\]</span></p>
<h2 id="八协方差矩阵的递归形式">八、协方差矩阵的递归形式</h2>
<p>公式（7-6）推导出了如公式（2-1）的标准形式，但是还差一点，就是噪声项<span class="math inline">\(\operatorname{Exp}(-\delta\phi_{ij})\)</span>是否符合0均值的高斯分布，以及它的协方差是怎么样的。</p>
<p>这一节的目的是推导噪声项的分布以及协方差的增量形式</p>
<p>让我们从公式（7-5）摘录噪声项</p>
<p><span class="math display">\[
\operatorname{Exp}(-\delta\phi_{ij})\
=\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(-\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\Big)\tag{8-1}
\]</span></p>
<p>记</p>
<p><span class="math display">\[
\xi_k=\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\tag{8-2}
\]</span></p>
<p>由于<span class="math inline">\(\boldsymbol{\eta}^{gd}_{k}\)</span>是个极微小量，而且<span class="math inline">\(\delta{\phi}_{ij}\)</span>也是个微小量，所以<span class="math inline">\(\xi_k\)</span>整体也是微小量，因此，根据性质（1-9）</p>
<p><span class="math display">\[
J_r(\xi_k)\approx \mathbf{I}\tag{8-3}
\]</span></p>
<p>因此，我们根据公式（1-6），将（8-1）可以写成</p>
<p><span class="math display">\[
\operatorname{Exp}(-\delta\phi_{ij})\
=\
\operatorname{Exp}\left(-\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\right)\tag{8-4}
\]</span></p>
<p>即</p>
<p><span class="math display">\[
\delta\phi_{ij}\
\approx\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\tag{8-5}
\]</span></p>
<hr />
<p>从公式（8-5）我们可以看到，公式（7-6）的噪声项是高斯噪声<span class="math inline">\(\boldsymbol{\eta}^{gd}\)</span>的线性组合，因此其本身也是高斯噪声</p>
<p>我们接下来进一步推导这个噪声的协方差的表达形式</p>
<p><span class="math display">\[
\begin{split}
\delta\phi_{ij}\
&amp;\approx\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\\
&amp;=\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k+1,j}}J_r^k\boldsymbol{\eta}^{gd}_k\Delta{t}\
+\
\overset{=\mathbf{I}_{3\times 3}}{\overbrace{\Delta{\tilde{R}^T_{j,j}}}}\
J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}\\
&amp;=\
\sum^{j-1}_{k=i}(\overset{=\Delta{\tilde{R}_{k+1,j}}}{\overbrace{\Delta{\tilde{R}_{k+1,j-1}}\Delta{\tilde{R}_{j-1,j}}}})\
+\
J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}\\
&amp;=\
\Delta{\tilde{R}^T_{j-1,j}}\sum^{j-2}_{k=i}\Delta{\tilde{R}^T_{k+1,j-1}}J_r^k\boldsymbol{\eta}^{gd}_k\Delta{t}\
+\
J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}\\
&amp;=\
\Delta{\tilde{R}^T_{j-1,j}}\delta{\phi}_{ij-1}+J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}
\end{split}\tag{8-6}
\]</span></p>
<p>根据高斯分布协方差的性质</p>
<p><span class="math display">\[
\Sigma_{ij}\
=\
\Delta{\tilde{R}^T_{j-1,j}}\
\Sigma_{ij-1}\
\Delta{\tilde{R}_{j-1,j}}\
+\
(J_r^{j-1}\Delta{t})\
\Sigma_{\boldsymbol{\eta}}\
(J_r^{j-1}\Delta{t})^T\tag{8-7}
\]</span></p>
<p>同时我们可以令协方差的初始值<span class="math inline">\(\Sigma_{ii}=\textbf{0}_{9\times 9}\)</span></p>
<p>于是，我们就得出了协方差的递归形式</p>
<h2 id="九偏差项bias更新">九、偏差项Bias更新</h2>
<h3 id="暂时性总结">暂时性总结</h3>
<p>到目前位置，我们已经推导出了如下内容</p>
<ol type="1">
<li>测量方程的标准表达形式，即公式（7-6）</li>
<li>测量方程噪声协方差的递归表达形式，即公式（8-7）</li>
</ol>
<p>但是要注意，公式（7-6）里面还偏差项<span class="math inline">\(\textbf{b}_i^g\)</span>。也就是其依旧依赖<span class="math inline">\(i\)</span>时刻的系统状态。那么如何在偏差更新的时候，避免测量方程的重复计算？这就是本节要推导的内容</p>
<h3 id="纳入偏差更新">纳入偏差更新</h3>
<p>当偏差项更新</p>
<p><span class="math display">\[
\hat{\textbf{b}} \leftarrow \bar{\textbf{b}}+\delta{\textbf{b}}\tag{9-1}
\]</span></p>
<p>我们希望计算更新后的测量<span class="math inline">\(\Delta{\tilde{R}_{ij}(\hat{\textbf{b}}^g_i)}\)</span>，相比与原先的值<span class="math inline">\(\Delta{\tilde{R}_{ij}(\bar{\textbf{b}}^g_i)}\)</span>的更新量</p>
<p>这样我们就不需要重复计算<span class="math inline">\(\Delta{\tilde{R}_{ij}}\)</span></p>
<p>把<span class="math inline">\(\hat{\textbf{b}}^g_i\)</span>代入<span class="math inline">\(\Delta{\tilde{R}_{ij}}\)</span>的表达式（7-3）</p>
<p><span class="math display">\[
\Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
=\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(
    \left(
        \tilde{\boldsymbol{\omega}}_k-\hat{\textbf{b}}^g_i
    \right)\Delta{t}
    \Big)\tag{9-2}
\]</span></p>
<p>将公式（9-1）代入（9-2），并利用BCH一阶近似公式（1-5）展开</p>
<p><span class="math display">\[
\begin{split}
    \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
        &amp; = \prod^{j-1}_{k=i}\
            \operatorname{Exp}\Big(
                \left(
                    \tilde{\boldsymbol{\omega}}_k-(\bar{\textbf{b}}^g_i+\delta{\textbf{b}}^g_i)
                \right)\Delta{t}
            \Big)\\
        &amp; = \prod^{j-1}_{k=i}\
            \operatorname{Exp}\Big(
                \left(\tilde{\boldsymbol{\omega}}_k-\bar{\textbf{b}}^g_i\right)\Delta{t}
            \Big)\
            \operatorname{Exp}\Big(
                -J_r^k\delta{\textbf{b}}^g_i\Delta{t}
            \Big)
\end{split}\tag{9-3}
\]</span></p>
<p>采用推导公式（7-1）到（7-5）的方式，从后往前推，并利用公式（1-8），上式可以写为</p>
<p><span class="math display">\[
\begin{split}
  \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
    =\Delta{\bar{R}_{ij}}\prod^{j-1}_{k=i}\
      \operatorname{Exp}\Big(
        -\Delta{\bar{R}}_{k+1,j}^TJ_r^k\delta{\textbf{b}^g_i}\Delta{t}
      \Big)
\end{split}\tag{9-4}
\]</span></p>
<p>我们再采用类似（8-1）到（8-5）的推导方法，（<span class="math inline">\(\delta{\textbf{b}}\)</span>是一个极小量，所以展开时的右雅可比接近单位矩阵）</p>
<p>公式（9-4）可以写为</p>
<p><span class="math display">\[
\begin{split}
  \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
    &amp; \approx \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \sum^{j-1}_{k=i}-\Delta{\bar{R}}_{k+1,j}^TJ_r^k\delta{\textbf{b}^g_i}\Delta{t}
      \Big)\\
    &amp; \overset{\cdot}{=} \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
        \delta{\textbf{b}^g_i}
      \Big)
\end{split}\tag{9-5}
\]</span></p>
<h2 id="十最小二乘形式误差">十、最小二乘形式/误差</h2>
<p>从公式（1-12）我们提前构造好了旋转的最大似然的负对数形式</p>
<p><span class="math display">\[
\begin{split}
  \mathcal{L}(R) &amp; =
    \frac{1}{2}||\operatorname{Log}(\tilde{R}^{-1}R)||^2_{\Sigma}+const
\end{split}
\]</span></p>
<p>我们已经构造了相对旋转的表达形式（9-5），因此我们可以进一步得出了旋转的误差模型</p>
<p><span class="math display">\[
\begin{split}
  \textbf{r}_{\Delta{R}_{ij}} = 
    \operatorname{Log}\left(
        \bigg(
          \Delta{\bar{R}_{ij}}\
            \operatorname{Exp}\big(
                \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
                \delta{\textbf{b}^g_i}
            \big)
        \bigg)^T
        R_i^TR_j
    \right)
\end{split}\tag{10-1}
\]</span></p>
<h2 id="总结">总结</h2>
<p>本文主要从论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1512.02363">《On-Manifold Preintegration for Real-TimeVisual-Inertial Odometry》</a>出发，挑选其中的旋转矩阵相关内容，目的是为了能够从实际应用出发，联系后端优化的非线性最小二乘优化问题和李群李代数知识，加深理论知识的印象。</p>
<p>再次强调，本文需要拥有一定的李群李代数基础知识，以及后端优化中如何将最大后验概率问题转化到最小二乘问题，没有这两个部分的知识可以参考笔者整理的两篇笔记。</p>
<p><strong>本文只挑选了系统状态中的旋转分量相关的内容。实际上原论文对位置、速度的推导也十分详细。但是太过杂乱的内容不仅对理解整个推导过程思路是如何来的没有帮助，还会让读者一头雾水。</strong></p>
<p>本文首先给出一些基础知识和后续推导用的性质（第一节）</p>
<p>第二节的重点是让读者要明白这么长篇大论的推导过程的线索是什么，最终目的是什么？我们的最终目的是将测量与真实值能够写成如公式（2-1）的标准形式，这样可以直接根据高斯分布的性质将最大似然问题通过负对数转化为最小二乘问题。</p>
<p><span class="math display">\[
\begin{array}{lcl}
\tilde{\mathcal{X}} = \mathcal{X} \oplus \epsilon, &amp;&amp; \epsilon \sim \mathcal{N}\left(0,\Sigma\right)\tag{2-1}
\end{array}
\]</span></p>
<p>第三节到第五节，我们推导了如何根据IMU的输出数据，将关键帧<span class="math inline">\((i,j)\)</span>的位姿中的旋转分量联系起来，即通过公式（5-4）</p>
<p><span class="math display">\[
R_j = R_i\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{5-4}
\]</span></p>
<p>为了避免优化过后关键帧<span class="math inline">\(i\)</span>的状态改变，积分需要重复计算的问题，我们在第六节推导了IMU预积分形式，也就是两帧之间的相对运动形式，即公式（6-1）</p>
<p><span class="math display">\[
\Delta{R_{ij}}\overset{\cdot}{=}\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{6-1}
\]</span></p>
<p>为了构造标准形式（2-1），我们在第七节中将噪声项独立出来，成功构造标准形式，即公式（7-6）</p>
<p><span class="math display">\[
\begin{split}
\Delta{\tilde{R}_{ij}}\
=\
\Delta{R_{ij}}\
\operatorname{Exp}(\delta\phi_{ij})\
\end{split}\tag{7-6}
\]</span></p>
<p>为了在最小二乘问题中使用噪声的协方差矩阵加权，我们在第八节推导了噪声的分布及方差的递归形式，即公式（8-5）</p>
<p><span class="math display">\[
\delta\phi_{ij}\
\approx\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\tag{8-5}
\]</span></p>
<p>最后，我们来解决如何在IMU偏差更新的时候，避免积分过程需要重复计算的问题，即公式（9-5）</p>
<p><span class="math display">\[
\begin{split}
  \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
    &amp; \approx \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \sum^{j-1}_{k=i}-\Delta{\bar{R}}_{k+1,j}^TJ_r^k\delta{\textbf{b}^g_i}\Delta{t}
      \Big)\\
    &amp; \overset{\cdot}{=} \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
        \delta{\textbf{b}^g_i}
      \Big)
\end{split}\tag{9-5}
\]</span></p>
<p>剩下的问题也就自然解决，我们可以根据标准形式构造误差函数的表达，即公式（10-1）</p>
<p><span class="math display">\[
\begin{split}
  \textbf{r}_{\Delta{R}_{ij}} = 
    \operatorname{Log}\left(
        \bigg(
          \Delta{\bar{R}_{ij}}\
            \operatorname{Exp}\big(
                \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
                \delta{\textbf{b}^g_i}
            \big)
        \bigg)^T
        R_i^TR_j
    \right)
\end{split}\tag{10-1}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/06/08/cv/surround-view-projection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/08/cv/surround-view-projection/" class="post-title-link" itemprop="url">超详细！从单应矩阵推导到自动驾驶环视投影应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-08 09:38:44" itemprop="dateCreated datePublished" datetime="2023-06-08T09:38:44+08:00">2023-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 12:07:02" itemprop="dateModified" datetime="2023-06-14T12:07:02+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
    <span id="/2023/06/08/cv/surround-view-projection/" class="post-meta-item leancloud_visitors" data-flag-title="超详细！从单应矩阵推导到自动驾驶环视投影应用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="超详细！从单应矩阵推导到自动驾驶环视投影应用" href="/2023/06/08/cv/surround-view-projection/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::f13a6e5ecc3be4fc943645106759d469" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="本文内容">本文内容</h2>
<p>本文的主要目的在于介绍自动驾驶中环视投影，也就是所谓的俯瞰图/鸟瞰图/BEV图，其背后的计算机视觉原理。环视投影的背后理论基础就是单应矩阵（Homography Matrix）。为了建立从直观到一般形式，本文从以下章节内容展开</p>
<p>在第一节中先规定相机坐标系和图像坐标系，以及介绍常用的车辆坐标系的规定。同时，对相机投影中常使用的齐次坐标做了简要介绍，顺带回顾相机投影方程。</p>
<p>第二节先对单应矩阵做介绍。对于一个空间中一个平面，以及两个不同姿态的相机，两个相机的对该平面的成像之间的联系是单应矩阵。但是如何从相机间的关系推导单应矩阵的具体形式？该节从特殊化形式和一般化形式两个角度对单应矩阵的表达进行推导。</p>
<p>环视投影是多个方向的地面成像结果到一个位于车辆上方，平行于地面往下成像的虚拟相机的成像结果的变换。第三节详细推导这个应用中的投影过程以及相机内外参与单应矩阵的关系。</p>
<p>第四节介绍如何在不知道相机内外参的情况下通过点对匹配的方法求解单应矩阵。</p>
<h2 id="基础知识及相关定义">基础知识及相关定义</h2>
<h3 id="相机坐标系与图像坐标系">相机坐标系与图像坐标系</h3>
<p>在计算机视觉的一般任务中，我们规定<strong>相机坐标系</strong>为光轴（经过相机原点）往前为<span class="math inline">\(Z\)</span>轴正方向，右为<span class="math inline">\(X\)</span>，下为<span class="math inline">\(Y\)</span> 对空间中的点放缩到归一化平面，归一化平面的坐标系定义也类似相机坐标系。 但是在图像中，我们一般令图片的左上角为坐标原点，横轴往右为<span class="math inline">\(u/X\)</span>正方向，竖轴往下为<span class="math inline">\(v/Y\)</span>正方向，又叫<strong>像素坐标系</strong></p>
<p>如下图所示</p>
<figure>
<img src="./imgs/01-pinhole.png" alt="" /><figcaption>相机及像素坐标系</figcaption>
</figure>
<h3 id="车辆坐标系">车辆坐标系</h3>
<p>我们一般规定车的后轮横轴中心在地面的点为坐标系原点，<span class="math inline">\(X\)</span>正方向指向车头，<span class="math inline">\(Y\)</span>轴正方向指向车左</p>
<figure>
<img src="./imgs/02-vehical_coordinate.png" alt="" /><figcaption>车辆坐标系</figcaption>
</figure>
<h3 id="齐次坐标homogeneous-coordinate">齐次坐标（Homogeneous Coordinate）</h3>
<p>当我们对三维空间中一个点<span class="math inline">\(P_1=[X_1,Y_1,Z_1]^T\)</span>做旋转平移变换到另一个点<span class="math inline">\(P_2\)</span>，可以用下面的公式</p>
<p><span class="math display">\[
P_2 = RP_1+\boldsymbol{t}
\]</span></p>
<p>其中<span class="math inline">\(R\in \mathbb{R}^{3\times3}\)</span>为旋转矩阵，<span class="math inline">\(\boldsymbol{t}\in \mathbb{R}^{3\times 1}\)</span>为平移向量</p>
<p>上式也可以将点坐标写为<span class="math inline">\(P_1=[X_1,Y_1,Z_1,1]^T\)</span>的形式，然后用变换矩阵对点做坐标变换</p>
<p><span class="math display">\[
P_2 = T_{21}P_1
\]</span></p>
<p><span class="math display">\[
T_{21} =
\begin{bmatrix}
R&amp;\boldsymbol{t}\\
\boldsymbol{0}&amp;1
\end{bmatrix}\in \mathbb{R}^{4\times 4}
\]</span></p>
<p><span class="math inline">\(T_{21}\)</span>称为变换矩阵;<span class="math inline">\(P_1=[X_1,Y_1,Z_1,1]^T\)</span>这种形式也叫齐次坐标（Homogeneous Coordinate）</p>
<p><strong>注意</strong>：齐次坐标其实有严格的定义，具体形式可以参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87">Wiki:Homogeneous Coordinate</a></p>
<p>同理，在做像素坐标的逆变换，也通常将像素坐标<span class="math inline">\([u,v]^T\)</span>后面添加一个1变为齐次坐标<span class="math inline">\(p=[u,v,1]^T\)</span></p>
<p><span class="math display">\[
p_n=K^{-1}p
\]</span></p>
<h3 id="投影方程">投影方程</h3>
<p>空间中的一个点<span class="math inline">\(P_W\)</span>投影到图像上的点<span class="math inline">\(\boldsymbol{p}\)</span>，我们直接记这个过程为</p>
<p><span class="math display">\[
\begin{split}
\lambda \boldsymbol{p}
&amp;=\
KT_{CW}P_W\\
&amp;=\
\begin{bmatrix}
u&amp;v&amp;1
\end{bmatrix}^T
\end{split}
\]</span></p>
<p>这里面包含了一次齐次坐标的转换（<span class="math inline">\(T_{CW}P_W \in \mathbb{R}^{4\times 1}\)</span>,<span class="math inline">\(K\in \mathbb{R}^{3\times 1}\)</span>），但是不会对理解有歧义</p>
<h2 id="单应矩阵homography-matrix">单应矩阵（Homography Matrix）</h2>
<p>在计算机视觉中，两个相机对于空间中的同一个平面的成像结果可以通过单应矩阵进行映射（相差一个常量系数）</p>
<p>另<span class="math inline">\([x,y,1]^T\)</span>为图片1的像素齐次坐标，<span class="math inline">\([x^{\prime},y^{\prime},1]^T\)</span>为同一个点在图片2的像素齐次坐标，则上面那句话可以等价为如下关系：</p>
<p><span class="math display">\[
\lambda
\begin{bmatrix}
x^{\prime}\\
y^{\prime}\\
1
\end{bmatrix}=
\boldsymbol{H}
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}=
\begin{bmatrix}
h_{00} &amp; h_{10} &amp; h_{20}\\
h_{01} &amp; h_{11} &amp; h_{21}\\
h_{02} &amp; h_{12} &amp; h_{22}
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}\tag{2-1}
\]</span></p>
<p>公式（2-1）中的系数<span class="math inline">\(\lambda\)</span>用来将变换后的坐标归一化（将第三个维度的值放缩为1） <strong>同时要注意，单应矩阵虽然有9个元素，但自由度只有8，可以除以<span class="math inline">\(h_{22}\)</span>进行归一化</strong></p>
<p>下面我们分别从用形象化的解释和一般化的推导来建立单应矩阵与相机内参、外参的关系</p>
<h3 id="特殊形式推导">特殊形式推导</h3>
<p>我们假设空间中有一平面，两个相机<span class="math inline">\(C_1,C_2\)</span>在两个不同的姿态下对这个平面进行成像。同时，我们令世界坐标系（<span class="math inline">\(O_G\)</span>)<span class="math inline">\(的\)</span>Z<span class="math inline">\(轴垂直于该平面，并且令该平面刚好位于世界坐标系的\)</span>XY<span class="math inline">\(平面，这样这个平面上的点\)</span>z$坐标等于0。可以用下图帮忙理解</p>
<figure>
<img src="./imgs/03-multi_camera.png" alt="" /><figcaption>双相机成像统一平面</figcaption>
</figure>
<p>同时，我们记世界坐标系到相机<span class="math inline">\(C_1\)</span>的变换矩阵为<span class="math inline">\(T_{C_1W}\)</span>，到相机<span class="math inline">\(C_2\)</span>的变换矩阵为<span class="math inline">\(T_{C_2W}\)</span>;<span class="math inline">\(K_1,K_2\)</span>为两个相机的内参。</p>
<p>我们现在对平面上的一个点<span class="math inline">\(P_W=[X_w,Y_w,Z_w=0,1]^T\)</span>进行投影，得到在两个相机成像的图片上对应的像素点<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2\)</span>。投影过程具有如下形式</p>
<p><span class="math display">\[
\begin{split}
\lambda_1\boldsymbol{p}_1
&amp;=\
\begin{bmatrix}
u_1\\
v_1\\
1
\end{bmatrix}
=\
K_1T_{C_1W}P_W\\
&amp;=\
K_1
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; r_{02} &amp; t_0\\
r_{10} &amp; r_{11} &amp; r_{12} &amp; t_1\\
r_{20} &amp; r_{21} &amp; r_{22} &amp; t_2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_W\\
Y_W\\
0\\
1
\end{bmatrix}\\
&amp;=\
K_1
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; t_0\\
r_{10} &amp; r_{11} &amp; t_1\\
r_{20} &amp; r_{21} &amp; t_2
\end{bmatrix}
\begin{bmatrix}
X_W\\
Y_W\\
1
\end{bmatrix}\\
&amp;=\
K_1T_{C_1W}^{0:3;0:2,3}P_W
\end{split}
\]</span></p>
<p>上式中<span class="math inline">\(T^{0:3;0:2,3}\)</span>表示变换矩阵前3行的0,1,3列。为了方便记号，我们将<span class="math inline">\(T_{C_1W}^{0:3;0:2,3}\)</span>记为<span class="math inline">\(J_{C_1W}\)</span></p>
<p>同理，我们可以得到图像2的类似投影方程，我们整理如下</p>
<p><span class="math display">\[
\begin{split}
\lambda_1\boldsymbol{p}_1 &amp;= K_1J_{C_1W}P_W\\
\\
\lambda_2\boldsymbol{p}_2 &amp;= K_2J_{C_2W}P_W\\
\end{split}\tag{2-2}
\]</span></p>
<p>注意上式中<span class="math inline">\(P_W=[X_W,Y_W,1]\)</span>，且上式中矩阵相乘的行列数量都是对应的</p>
<p>我们将上式（2-2）重新整理一下，将<span class="math inline">\(P_W\)</span>写为<span class="math inline">\(p_1\)</span>的函数，有</p>
<p><span class="math display">\[
P_W=\lambda_1J_{C_1W}^{-1}K_1^{-1}\boldsymbol{p}_1\tag{2-3}
\]</span></p>
<p>将（2-3）带入（2-2）中的相机2方程</p>
<p><span class="math display">\[
\lambda_2\boldsymbol{p}_2=\lambda_1K_2J_{C_2W}J_{C_1W}^{-1}K_1^{-1}\boldsymbol{p}_1
\]</span></p>
<p>其中<span class="math inline">\(\lambda_1,\lambda_2\)</span>只是为了将投影后的值进行放缩，使得第三个元素的值为1,所以两者可以写成一个，最后我们可以得到如下形式</p>
<p><span class="math display">\[
\begin{split}
&amp;\lambda\boldsymbol{p}_2=\boldsymbol{H}_{21}\boldsymbol{p}_1\\
&amp; \boldsymbol{H}_{21} = K_2J_{C_2W}J_{C_1W}^{-1}K_1^{-1}\\
&amp;J=T^{0:3,0:2,3}
\end{split}\tag{2-4}
\]</span></p>
<p>可以看到，公式（2-4）的形式和公式（2-1）是一样的，同时将单应矩阵与相机的内参外参联系起来</p>
<h3 id="单应矩阵与相机内外参关系的一般形式">单应矩阵与相机内外参关系的一般形式</h3>
<p>上一个小节我们对单应矩阵与相机的内外参之间的关系建立了公式化的联系和直观上的理解。上一小节的推导可以看出，对于空间中的一快平面，存在一个<span class="math inline">\(3 \times 3\)</span>的矩阵（自由度为8）将两个相机对这块平面的成像结果联系起来。</p>
<p>在上一小节中，我们假设世界坐标系与成像平面对齐。我们在这一小节中继续推导更一般的表达形式，这一小节的内容主要参考<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Homography_(computer_vision)">Wiki:Homography (computer vision)</a></p>
<p>由于一般情况下，我们都是知道相机的外参（也就是世界坐标系到相机坐标系的变换关系），所以我们这一节不假设平面的坐标系与世界坐标系对齐，我们假设平面在相机<span class="math inline">\(C_1\)</span>下的法向量为<span class="math inline">\(\boldsymbol{n}\)</span>，平面到相机<span class="math inline">\(C_1\)</span>的距离为<span class="math inline">\(d\)</span>，且对于法向量的方向，我们做如下规定：对于平面上的点<span class="math inline">\(P_{C_1}\)</span>，满足<span class="math inline">\(\boldsymbol{n}^TP_{C_1}+d=0\)</span>，其中<span class="math inline">\(\boldsymbol{n}^TP_{C_1}\)</span>为点到法向量的投影</p>
<figure>
<img src="./imgs/04-homo_general.png" alt="" /><figcaption>单应矩阵的一般形式推导</figcaption>
</figure>
<p>假设相机<span class="math inline">\(C_1\)</span>的外参为<span class="math inline">\(T_{C_1W}=[R_1|\boldsymbol{t}_1]\)</span>，相机<span class="math inline">\(C_2\)</span>的外参为<span class="math inline">\(T_{C_2W}=[R_2|\boldsymbol{t}_2]\)</span>，由变换矩阵的性质，我们可以得到</p>
<p><span class="math display">\[
\begin{split}
T_{WC_1} &amp;= T_{C_1W}^{-1}\\
&amp;= 
\begin{bmatrix}
R_1&amp;\boldsymbol{t}_1\\
\boldsymbol{0}&amp;1
\end{bmatrix}^{-1}\\
&amp;=\
\begin{bmatrix}
R_1^{-1}&amp;-R_1^{-1}\boldsymbol{t}_1\\
\boldsymbol{0}&amp;1
\end{bmatrix}
\end{split}\tag{2-5}
\]</span></p>
<p>所以相机1到相机2的变换矩阵为</p>
<p><span class="math display">\[
\begin{split}
T_{C_2C_1} &amp;= T_{C_2W}T_{WC_1}\\
&amp;= 
\begin{bmatrix}
R_2&amp;\boldsymbol{t}_2\\
\boldsymbol{0}&amp;1
\end{bmatrix}
\begin{bmatrix}
R_1^{-1}&amp;-R_1^{-1}\boldsymbol{t}_1\\
\boldsymbol{0}&amp;1
\end{bmatrix}\\
&amp;=\
\begin{bmatrix}
R_2R_1^{-1}&amp;-R_2R_1^{-1}\boldsymbol{t}_1+\boldsymbol{t}_2\\
\boldsymbol{0}&amp;1
\end{bmatrix}\\
&amp;=\
\begin{bmatrix}
R_{21}&amp;\boldsymbol{t}_{21}\\
\boldsymbol{0}&amp;1
\end{bmatrix}
\end{split}\tag{2-6}
\]</span></p>
<p>根据相机投影关系，我们有</p>
<p><span class="math display">\[
\begin{split}
&amp;\boldsymbol{p}_1=\frac{1}{Z_{C_1}}K_1P_1\\
&amp;\boldsymbol{p}_2=\frac{1}{Z_{C_2}}K_2P_2\\
\end{split}\tag{2-7}
\]</span></p>
<p><span class="math display">\[
P_1 = Z_{C_1}K_1^{-1}\boldsymbol{p}_1\tag{2-8}
\]</span></p>
<p>又<span class="math inline">\(P_1,P_2\)</span>为点<span class="math inline">\(P_W\)</span>在两个相机坐标系下的坐标，这两个点又可以通过下面的变换联系</p>
<p><span class="math display">\[
P_2 = R_{21}P_1 + \boldsymbol{t}_{21}\tag{2-9}
\]</span></p>
<p>联合（2-7）到（2-9），我们可以得出</p>
<p><span class="math display">\[
\boldsymbol{p}_2=\frac{1}{Z_{C_2}}K_2(R_{21}Z_{C_1}K_1^{-1}\boldsymbol{p}_1+\boldsymbol{t}_{21})\tag{2-10}
\]</span></p>
<p>对于平面，我们已经做了如下规定： 在相机<span class="math inline">\(C_1\)</span>坐标系下，对于平面上的点<span class="math inline">\(P_{1}\)</span>，满足<span class="math inline">\(\boldsymbol{n}^TP_{1}+d=0\)</span>，其中<span class="math inline">\(\boldsymbol{n}^TP_{1}\)</span>为点到法向量的投影。即</p>
<p><span class="math display">\[
\frac{\boldsymbol{n}^TP_1}{-d}=1\tag{2-11}
\]</span></p>
<p>将（2-11）带入公式（2-10）中的<span class="math inline">\(\boldsymbol{t}_{21}\)</span>可以得到</p>
<p><span class="math display">\[
\begin{split}
\boldsymbol{t}_{21}
&amp;=\
\boldsymbol{t}_{21}\frac{\boldsymbol{n}^TP_1}{-d}\\
&amp;=\
\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{-d}P_1\\
&amp;\overset{2-8}{=}\
-\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{d}Z_{C_1}K_1^{-1}\boldsymbol{p}_1
\end{split}\tag{2-12}
\]</span></p>
<p>将（2-12）代入公式（2-10）中，我们可以得到</p>
<p><span class="math display">\[
\begin{split}
\boldsymbol{p}_2&amp;=\frac{1}{Z_{C_2}}K_2\left(R_{21}-\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{d}\right)Z_{C_1}K_1^{-1}\boldsymbol{p}_1\\
&amp;=\
\frac{Z_{C_1}}{Z_{C_2}}K_2H_{21}K_1^{-1}\boldsymbol{p_1}
\end{split}\tag{2-13}
\]</span></p>
<p>于是，我们可以得到单应矩阵的表达形式</p>
<p><span class="math display">\[
H_{21} = R_{21}-\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{d}\tag{2-14}
\]</span></p>
<p>如果我们将<span class="math inline">\(R_{21}\)</span>与<span class="math inline">\(t_{21}\)</span>的展开形式，即公式（2-6），则我们可以得到</p>
<p><span class="math display">\[
H_{21} = R_2R_1^{-1} - \frac{\left(-R_2R_1^{-1}\boldsymbol{t}_1+\boldsymbol{t}_2\right)\boldsymbol{n}^T}{d}\tag{2-15}
\]</span></p>
<hr />
<p>这篇论文<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1145/3343031.3350885">Online Camera Pose Optimization for the Surround-viewSystem</a>，中关于环视图的地平面投影一章的公式推导很详细，作为基础理论学习很不错。</p>
<h2 id="环视投影bev">环视投影/BEV</h2>
<h3 id="基础概念">基础概念</h3>
<p>从前文中我们可以得出，对于空间中的一个平面，不同位姿的相机成像的图片可以通过单应矩阵在不同的图片中进行变换。对于自动驾驶车辆来说，环绕车周的多个摄像头(一般是4个及以上)会同时拍摄到地面。同时，我们可以假设有一个虚拟相机位于车辆正上方往下拍摄。这样，车周的摄像头可以根据地平面对应的单应矩阵投影到虚拟相机，得到所谓的俯瞰图/鸟瞰图，也就是 <strong>BEV(Bird Eye View)</strong></p>
<h3 id="图示说明">图示说明</h3>
<hr />
<figure>
<img src="./imgs/05-ground_coor.png" alt="" /><figcaption>地面坐标系与环视图片坐标系的联系</figcaption>
</figure>
<p>上图中<span class="math inline">\(O_G\)</span>是地面坐标系，这里与第一节中说明的车辆坐标系有一点不同，主要是为了方便后文进行公式推导。实际中只需要把图中的地面坐标系与车辆坐标系根据车身参数简单计算出变换矩阵即可。</p>
<p>上图中<span class="math inline">\(O_I\)</span>是图像坐标系，以左上角为坐标原点，<span class="math inline">\(u,v\)</span>为像素的横轴、纵轴坐标值。<span class="math inline">\(H,W\)</span>为我们希望得到的地平面投影图像的投影范围，单位是<span class="math inline">\(米\)</span>。同时，我们令<span class="math inline">\(d_W,d_H\)</span>为图像每个像素对应的实际中方格的大小，单位也是<span class="math inline">\(米\)</span></p>
<hr />
<h3 id="地平面点到相机投影">地平面点到相机投影</h3>
<p>假设车周有4个相机<span class="math inline">\(C_1,C_2,C_3,C_4\)</span>，4个相机的与地面坐标系的位姿关系为<span class="math inline">\(T_{C_1G}, T_{C_2G}, T_{C_3G}, T_{C_4G}\)</span></p>
<p>对于一个地面坐标系下的点<span class="math inline">\(P_{G}=[X_G,Y_G,Z_G,1]^T\)</span>，在通过投影方程投影在相机<span class="math inline">\(C_i\)</span>上的图像像素坐标<span class="math inline">\(\boldsymbol{p}_i\)</span>有如下关系：</p>
<p><span class="math display">\[
\begin{split}
P_{C_i}&amp;=T_{C_iG}P_G\\
&amp;=
\begin{bmatrix}
X_{C_i} &amp; Y_{C_i} &amp; Z_{C_i} &amp; 1
\end{bmatrix}^T
\end{split}
\]</span></p>
<p>则<span class="math inline">\(P_G\)</span>在相机<span class="math inline">\(C_i\)</span>中对应的像素坐标为</p>
<p><span class="math display">\[
\begin{split}
\lambda_{C_i} \boldsymbol{p}_{C_i} 
&amp;=\
K_{C_i}P_{C_{i}}\\
&amp;=\
K_{C_i}T_{C_iG}P_G
\end{split}\tag{3-1}
\]</span></p>
<p><span class="math inline">\(K_{C_i}\)</span>是相机<span class="math inline">\(C_i\)</span>的内参，<span class="math inline">\(\lambda_{C_i}\)</span>是放缩系数，确保最后<span class="math inline">\(\boldsymbol{p}_{C_i}\)</span>的第三个维度值为1,也就是具有如下形式：<span class="math inline">\(\boldsymbol{p}_{C_i}=[u,v,1]^T\)</span>。另外，要注意（3-1）中包含一个齐次坐标的变换。</p>
<p>现在假设点<span class="math inline">\(P_G\)</span>的<span class="math inline">\(Z\)</span>轴坐标是0,也就是点位于地面，则 <span class="math inline">\(P_{G}=[X_G,Y_G,0,1]^T\)</span>，上面<span class="math inline">\(P_{C_i}=T_{C_iG}P_G\)</span>展开会变成</p>
<p><span class="math display">\[
\begin{split}
P_{C_i}&amp;=T_{C_iG}P_G\\
&amp;=
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; r_{02} &amp; t_0\\
r_{10} &amp; r_{11} &amp; r_{12} &amp; t_1\\
r_{20} &amp; r_{21} &amp; r_{22} &amp; t_2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_{G_i}\\
Y_{G_i}\\
0\\
1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; t_0\\
r_{10} &amp; r_{11} &amp; t_1\\
r_{20} &amp; r_{21} &amp; t_2\\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_{G_i}\\
Y_{G_i}\\
1
\end{bmatrix}
\end{split}
\]</span></p>
<p>我们可以重新记公式（3-1）为</p>
<p><span class="math display">\[
\begin{split}
\lambda_{C_i}\boldsymbol{p}_{C_i}=K_{C_i}T_{C_iG}^{0:3;0:2,3}P_G
\end{split}\tag{3-3}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
T_{C_iG}^{0:3;0:2,3} =
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; t_0\\
r_{10} &amp; r_{11} &amp; t_1\\
r_{20} &amp; r_{21} &amp; t_2
\end{bmatrix}
\]</span></p>
<p>表示变换矩阵的前三行，第0,1,3列</p>
<p>公式（3-3）实际就是第二节中推导出的公式（2-2）</p>
<h3 id="地平面点虚拟相机投影">地平面点虚拟相机投影</h3>
<p>根据上图，假设我们想要投影以地面坐标系原点为中心，<span class="math inline">\(H\times W\)</span>的地面区域。同时，我们希望投影后的像素分辨率为一个像素对应横轴、长轴为<span class="math inline">\(d_W,d_H\)</span>长度的地面方格。<strong>（PS:实际上相机的焦距的定义就是每个像素对应的实际尺寸，焦距的单位为<span class="math inline">\(pixel/meter\)</span>）</strong>。对于地平面投影，我们可以假设有一个虚拟相机位于地面上1米，这样<span class="math inline">\(u=f_xX_G+c_x\)</span>，<span class="math inline">\(f_x=\frac{1}{d_W}\)</span>，<span class="math inline">\(c_x=\frac{W}{2d_W}\)</span>。我们可以写成如下的形式</p>
<p><span class="math display">\[
\begin{bmatrix}
u_G\\
v_G\\
1
\end{bmatrix}=
\begin{bmatrix}
\frac{1}{d_W} &amp; 0 &amp; \frac{W}{2d_W}\\
0 &amp; \frac{1}{d_H} &amp; \frac{H}{2d_H}\\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_G\\
Y_G\\
1
\end{bmatrix}\tag{3-4}
\]</span></p>
<p>上式可以写成矩阵形式，我们记<span class="math inline">\(K_G\)</span>为上式中的矩阵（虚拟相机的内参）</p>
<p><span class="math display">\[
\boldsymbol{p}_G = K_GP_G\tag{3-5}
\]</span></p>
<p>联立公式（3-3）和公式（3-5）可以写为如下形式</p>
<p><span class="math display">\[
\lambda \boldsymbol{p}_G=K_G\left(T_{C_iG}^{0:3;0:2,3}\right)^{-1}K_{C_i}^{-1}\boldsymbol{p}_{C_i}\tag{3-6}
\]</span></p>
<p>其中，<span class="math inline">\(\lambda\)</span>系数只是为了将<span class="math inline">\(\boldsymbol{p}_G\)</span>的最后一个维度归一化，不需要具体形式。</p>
<h2 id="直接估计环视投影的单应矩阵">直接估计环视投影的单应矩阵</h2>
<p>除了根据第三节的推导，从相机内外参直接推导出车周相机到地平面的投影矩阵，还可以直接人工选点估计单应矩阵。这一点跟透视矫正（Perspective Correction）任务基本类似。所谓的透视矫正，就是对于同一个平面的不同成像结果（两张图片），我们选择两张图片上的对应点构建对应点集，根据单应矩阵的定义</p>
<p><span class="math display">\[
\boldsymbol{p}_2 = H_{21}\boldsymbol{p}_1
\]</span></p>
<p>我们可以从对应的点集中求解出单应矩阵。由于前面第二节我们知道单应矩阵的实际自由度为8，而一个对应点对可以构建两个约束方程（<span class="math inline">\(x,y\)</span>），所以我们一共最少需要4个点对来求解单应矩阵。</p>
<h3 id="示例图">示例图</h3>
<p>还是以上文的简笔图来说明</p>
<figure>
<img src="./imgs/06-perspective_correction.png" alt="" /><figcaption>透视矫正示意图</figcaption>
</figure>
<p>上图中两个相机对同一个平面成像，得到两张图片。两张图片中<span class="math inline">\(A,B,C,D\)</span>四个点是一一对应的关系，记这些点对为<span class="math inline">\(\boldsymbol{p}_i,\boldsymbol{p}_i^{\prime}\)</span>，则我们可以建立方程</p>
<p><span class="math display">\[
\begin{split}
\lambda \boldsymbol{p}_i^{\prime}&amp;=H\boldsymbol{p}_i
\end{split}
\]</span></p>
<p>即 <span class="math display">\[
\lambda
\begin{bmatrix}
u_i^{\prime}\\
v_i^{\prime}\\
1
\end{bmatrix}
=\
\begin{bmatrix}
h_{00}&amp;h_{01}&amp;h_{02}\\
h_{10}&amp;h_{11}&amp;h_{21}\\
h_{20}&amp;h_{21}&amp;h_{22}\\
\end{bmatrix}
\begin{bmatrix}
u_i\\
v_i\\
1
\end{bmatrix}\tag{4-1}
\]</span></p>
<h3 id="单应矩阵求解">单应矩阵求解</h3>
<p>公式（4-1）的求解可以用最小二乘法，或者最小二乘法+RANSAC等算法，优化目标为：</p>
<p><span class="math display">\[
J = \sum_{i}\left(u_i^{\prime}-\frac{h_{00}u_i+h_{01}v_i+h_{02}}{h_{20}u_i+h_{21}v_i+h_{22}}\right)^2+\left(v_i^{\prime}-\frac{h_{10}u_i+h_{11}v_i+h_{21}}{h_{20}u_i+h_{21}v_i+h_{22}}\right)^2
\]</span></p>
<p>这部分的求解可以使用OpenCV的函数<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780">OpenCV:findHomography</a></p>
<h3 id="环视投影单应矩阵求解">环视投影单应矩阵求解</h3>
<p>在环视投影中，我们需要一些额外的标定物要求解单应矩阵。主要的原理就是我们将地面上的坐标和图像中的坐标联立写成如公式（4-1）的形式，然后调用接口计算单应矩阵。图像中的坐标可以通过手工选点，也可以通过一些角点检测程序。</p>
<figure>
<img src="./imgs/07-compute-homo.png" alt="" /><figcaption>环视单应矩阵求解</figcaption>
</figure>
<p>上图引用自：https://www.guyuehome.com/39649</p>
<p>上图中0,1,2,3四个点是在图片上选择的点，因此知道像素值。同时，我们又可以通过标定布的几何属性以及我们提前设定的投影图的分辨率，得出这四个点在BEV上的等效像素值，于是我们就可以求解方程（4-1）得出单应矩阵</p>
<h2 id="单应矩阵的其他应用">单应矩阵的其他应用</h2>
<p>单应矩阵还可以用在求解平面标定板的位姿、全景图拼接等应用，<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html">OpenCV的这一篇教程</a>写得十分详细，这里就不再赘述。</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Homography_(computer_vision)">Wiki:Homography_(computer_vision)</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780">OpenCV:findHomography</a></li>
<li><a target="_blank" rel="noopener" href="https://www.guyuehome.com/39649">古月居:AVM 环视拼接方法介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html">OpenCV：Basic concepts of the homography explained with code</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/06/05/cv/camera-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/05/cv/camera-model/" class="post-title-link" itemprop="url">吐血整理：从相机模型（针孔、鱼眼、全景）到OpenCV源码实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-05 17:35:04" itemprop="dateCreated datePublished" datetime="2023-06-05T17:35:04+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-12 15:42:27" itemprop="dateModified" datetime="2023-06-12T15:42:27+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
    <span id="/2023/06/05/cv/camera-model/" class="post-meta-item leancloud_visitors" data-flag-title="吐血整理：从相机模型（针孔、鱼眼、全景）到OpenCV源码实现" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="吐血整理：从相机模型（针孔、鱼眼、全景）到OpenCV源码实现" href="/2023/06/05/cv/camera-model/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::7f7d0e7ebf1819ceb3ada055941a8a17" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="本文内容">本文内容</h2>
<p>本文旨在较为直观地介绍相机成像背后的数学模型，主要的章节组织如下：</p>
<ol type="1">
<li>第一章用最简单的针孔投影模型为例讲解一个三维点是如何映射到图像中的一个像素</li>
<li>第二章介绍除了针孔投影模型外其他一些经典投影模型，旨在让读者建立不同投影模型之间的建模过程</li>
<li>第三章介绍如何把不同的投影模型用一个统一的投影过程表达</li>
<li>第四章进一步补充第三章的统一投影模型，并介绍畸变的定义和去畸变的原理</li>
<li>第五章针对全景相机的基本概念和两种应用广泛的全景相机模型做出介绍</li>
<li>第六章用代码示例介绍如何使用OpenCV的接口对图像去畸变</li>
</ol>
<h2 id="一相机是如何成像的">一、相机是如何成像的？</h2>
<p>祭上一张经典图</p>
<figure>
<img src="./imgs/01-pinhole.png" alt="" /><figcaption>针孔相机模型</figcaption>
</figure>
<h3 id="一个三维空间中的点怎样映射到图片上的一个像素">一个三维空间中的点怎样映射到图片上的一个像素？</h3>
<p>我们从一个最简单的问题开始：一个三维空间中的点<span class="math inline">\(P=[X,Y,Z]\)</span>是如何经过相机成像变为图像上的一个像素<span class="math inline">\(\boldsymbol{p}=[u,v]\)</span>的？</p>
<p>我们最常见的投影模型<strong>Perspective Projection Model</strong> 描述的就是<strong>针孔相机</strong> 的成像原理。从上面的图根据相似三角形可以得出</p>
<p><span class="math display">\[
\frac{X_c}{Z_c} = \frac{u - c_x}{f}\tag{1-1}
\]</span></p>
<p>其中<span class="math inline">\(c_x\)</span>为光轴在图像中的<span class="math inline">\(x\)</span>坐标，如果相机的光轴与感光元器件完全对齐的话，<span class="math inline">\(c_x = \frac{1}{2}W\)</span>, <span class="math inline">\(W\)</span>是图像的宽度（单位是像素）</p>
<p>从上面的关系可以得出，将一个三维点投影到像素坐标系的时候，可以直接使用下面的公式。对应的就是针孔相机模型。<strong>下标<span class="math inline">\((\cdot)_c\)</span></strong> 表示这个点是在相机坐标系下的点</p>
<p><span class="math display">\[
\begin{split}
\lambda
\begin{bmatrix}
u\\
v\\
1
\end{bmatrix}=
\begin{bmatrix}
f_x&amp;0&amp;c_x\\
0&amp;f_y&amp;c_y\\
0&amp;0&amp;1
\end{bmatrix}
\begin{bmatrix}
X_c\\
Y_c\\
Z_c\\
\end{bmatrix}
\end{split}\tag{1-2}
\]</span></p>
<p>公式（1-2）在代码中也经常对<span class="math inline">\(u,v\)</span>分开进行计算</p>
<p><span class="math display">\[
\begin{split}
u = f_x \frac{X_c}{Z_c} + c_x
\\
\\
v = f_y \frac{Y_c}{Z_c} + c_y
\end{split}\tag{1-3}
\]</span></p>
<p>当然，为了简化记号，公式（1-2）也通常记为矩阵相乘的形式</p>
<p><span class="math display">\[
\lambda\boldsymbol{p}=KP_c\tag{1-4}
\]</span></p>
<p>如果我们提前对<span class="math inline">\(P_c\)</span>做归一化处理，也就是除以<span class="math inline">\(Z_c\)</span>（假设点位于相机前，即<span class="math inline">\(Z_c&gt;0\)</span>），则可以去掉<span class="math inline">\(\lambda\)</span>系数，即如下形式：</p>
<p><span class="math display">\[
\begin{split}
&amp;\boldsymbol{p}_n=\frac{P_c}{Z_c}=
\begin{bmatrix}
\frac{X_c}{Z_c}&amp;\frac{Y_c}{Z_c}&amp;1
\end{bmatrix}^T
\\
&amp;\boldsymbol{p}=K\boldsymbol{p}_n
\end{split}\tag{1-5}
\]</span></p>
<p>公式（1-4）中<span class="math inline">\(\boldsymbol{p}_n\)</span>位于<span class="math inline">\(Z=1\)</span>的平面，又叫归一化平面（nomalized plane），后文会再次讲到这个平面。</p>
<p>公式（1-2）到公式（1-5）其实都是等价的</p>
<p>如果给的三维点是在世界坐标系下，也就是<span class="math inline">\(P_w=[X_w,Y_w,Z_w]\)</span>，那么我们只需要先把该点用相机的外参转换到相机坐标系下（刚性变换）即可：</p>
<p><span class="math display">\[
\begin{split}
\lambda\boldsymbol{p} = KT_{cw}P_w\\
\\
T_{cw} = [R|t]
\end{split}\tag{1-6}
\]</span></p>
<p>由于刚性变换过程不影响对相机投影模型的讨论，因此后面都假设三维点是处于相机坐标系</p>
<h3 id="相机坐标系">相机坐标系</h3>
<p>在OpenCV中以及大部分视觉处理库中，相机坐标系的规定都与上述的图一致，就是相机光轴往前为<span class="math inline">\(Z\)</span>，图像水平往右为<span class="math inline">\(X\)</span>，图像垂直往下为<span class="math inline">\(Y\)</span>。不过要注意的是在一些仿真渲染器或者特定任务的数据集中可能会规定图像垂直往上为<span class="math inline">\(Z\)</span>，前为<span class="math inline">\(X\)</span>，朝左为<span class="math inline">\(Y\)</span>，但是这一点是无关紧要的，这一点差别可以反映在相机的外参里，也就是公式（1-6）中的<span class="math inline">\(T_{cw}\)</span>，只要按照OpenCV的方式规定相机坐标系，总是可以找到一个外参矩阵<span class="math inline">\(T_{cw}\)</span>将世界坐标系下的点变换到相机坐标系（前<span class="math inline">\(Z\)</span>右<span class="math inline">\(X\)</span>下<span class="math inline">\(Y\)</span>）</p>
<h3 id="大白话总结">大白话总结</h3>
<p>问：相机是如何成像的？ 答：光束从物体表面反射，经过相机镜头，到达感光原件，这一系列物理过程可以通过数学公式表达，最终变成一个简单的矩阵操作将三维空间中的点对应到图片的一个像素。</p>
<h2 id="二不同的相机投影模型">二、不同的相机投影模型</h2>
<p>第一节介绍的是针孔投影模型，但是事实上相机镜头都是多种多样的，不可能都是符合针孔投影模型。本节会介绍经典的相机投影模型，并从直观感受和形式化定义上介绍不同的投影模型是如何联系在一起的</p>
<h3 id="什么是相机投影模型">什么是相机投影模型</h3>
<p><strong>相机投影模型用数学的方式描述了一个真实世界中的三维点到图像上像素坐标的映射关系</strong></p>
<p>相机投影模型实际上就是对相机成像过程（物理）的数学建模。建模的目的是为了能够尽量符合真实的成像过程。不同的建模方式就对应不同的相机投影模型</p>
<h3 id="经典的相机投影模型">经典的相机投影模型</h3>
<p>我们回头看看公式（1-3），并暂时<strong>只关注<span class="math inline">\(X\)</span>轴的映射关系</strong></p>
<p><span class="math display">\[
\begin{split}
u = f_x \frac{X_c}{Z_c} + c_x
\end{split}\tag{1-3}
\]</span></p>
<p>上式中<span class="math inline">\(f_x\)</span>称为相机焦距，反应了一个单位长度应该映射为几个像素，单位是<span class="math inline">\(pixels/m\)</span>，<span class="math inline">\(c_x\)</span>是相机坐标系（以光轴点为原点）到图像坐标系（以左上角为原点），这两个参数都是相机的固有参数。 而上式轴<span class="math inline">\(\frac{X_c}{Z_c}\)</span>刚好是点<span class="math inline">\(P_c\)</span>到相机光心连线与光轴角度的正切值，我们记光束与光轴的夹角为<span class="math inline">\(\theta\)</span>，并将图片原点移动到图片中心，则公式（1-3）可以写为</p>
<p><span class="math display">\[
u^{\prime}=f_x\tan(\theta)\tag{2-1}
\]</span></p>
<p>上式的示意图如下（图中的<span class="math inline">\(r\)</span>在只考虑<span class="math inline">\(X\)</span>轴的时候就是<span class="math inline">\(u^{\prime}\)</span>）：</p>
<figure>
<img src="./imgs/02-theta_projection.jpg" alt="" /><figcaption>光束与光轴夹角</figcaption>
</figure>
<p>在公式（2-1）中，<span class="math inline">\(X\)</span>轴的投影坐标是<span class="math inline">\(\theta\)</span>的函数，于是，我们是否可以用不同的函数表达这个过程？答案是肯定的！不同的函数就对应了不同的投影模型。下图就给出了在经典投影模型中对<span class="math inline">\(\theta\)</span>的不同映射方式</p>
<figure>
<img src="./imgs/03-classic_projection.jpg" alt="" /><figcaption>经典投影模型</figcaption>
</figure>
<p>事实上，<span class="math inline">\(f\)</span>作为相机的焦距，在上图中的不同投影模型都统一出现，于是我们可以舍弃焦距符号。于是，上图中不同的函数关系与投影模型的对应关系如下：</p>
<ul>
<li><span class="math inline">\(r(\theta)=\tan(\theta)\)</span>，perspective projection/针孔投影模型/rectilinear model</li>
<li><span class="math inline">\(r(\theta)=2\tan{\big(\frac{\theta}{2}\big)}\)</span>, stereographic projection</li>
<li><span class="math inline">\(r(\theta)=\theta\)</span>, equidistant projection</li>
<li><span class="math inline">\(r(\theta)=\sin{(\theta)}\)</span>, sine-law projection</li>
<li><span class="math inline">\(r(\theta)=2\sin{\big(\frac{\theta}{2}\big)}\)</span>, equi-solid angle projection</li>
</ul>
<p>上面两幅图出自:<a target="_blank" rel="noopener" href="http://michel.thoby.free.fr/Fisheye_history_short/Projections/Models_of_classical_projections.html">Models for the various classical lens projections</a>，这篇文章比较形象地介绍各种经典的相机投影模型，并给出他们的函数曲线分析。不过总体偏形象化，没有引入更形式化的描述。</p>
<h2 id="三相机投影模型的统一表达形式">三、相机投影模型的统一表达形式</h2>
<p>上一节我们将投影关系限制在<span class="math inline">\(X\)</span>轴，并且给出了较为直观的图示。目的在于两个：1）给读者建立更深刻的相机投影过程;2）让读者对几种经典的投影模型有初步的直观了解。在这一小节中，我们给出更为统一的相机投影表达方式，同时为后文讨论相机的<strong>畸变</strong> 建立必要的理论基础。</p>
<p>我们将相机的投影过程拆分为三个过程：1）将空间中的点投影到单位球表面;2）将单位球上的点投影到归一化平面;3）将归一化平面上的点利用针孔模型投影到图像坐标系。下面详细介绍这几个过程</p>
<h3 id="单位球投影">单位球投影</h3>
<p>想象一下一束光束从相机光心射出，经过图像中的一个像素然后往外无限延伸，可以想象到，这个光束经过的任何点到图像的投影都是经过的那个像素。这个简单的事实告诉我们，我们可以对一个三维点进行任意的放缩，其在图像上的成像点都不会改变。于是，我们将三维点<span class="math inline">\(P_c\)</span>除以它自身的膜，将其投影到一个单位球，其投影坐标为<span class="math inline">\(P_s\)</span></p>
<p><span class="math display">\[
\begin{split}
P_s = \frac{P_c}{||P_c||}=
\begin{bmatrix}
\frac{X_c}{||P_c||}&amp;\frac{Y_c}{||P_c||}&amp;\frac{Z_c}{||P_c||}
\end{bmatrix}^T
\end{split}\tag{3-1}
\]</span></p>
<p>示意图如下：</p>
<figure>
<img src="./imgs/04-unit_sphere.png" alt="" /><figcaption>单位球投影示意图</figcaption>
</figure>
<p>在上图中，<span class="math inline">\(\theta\)</span>是光束与光轴的夹角，<span class="math inline">\(\alpha\)</span>为光束与水平轴的夹角。</p>
<p>两个角度有如下关系：</p>
<p><span class="math display">\[
\begin{split}
&amp;\rho = \sqrt{(X_s^2+Y_s^2)}\\
&amp;\theta=\operatorname{atan}(\frac{\rho}{Z_s})=\operatorname{asin}(\rho)\\
&amp;\alpha=\operatorname{atan}(\frac{Y_s}{X_s})
\end{split}\tag{3-2}
\]</span></p>
<p>之所以构建<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\alpha\)</span>是因为，我们后续可以将投影过程建立为这两个角度的函数，也就是只与光束的角度有关，而与具体的点坐标无关，这也是符合直观的。</p>
<p>另外，从前面的叙述以及常识，我们知道针孔成像结果是一个倒立的像，为了方便叙述，我们可以将相机做一个镜像，如下图所示：</p>
<figure>
<img src="./imgs/05-mirror_camera.png" alt="" /><figcaption>对相机做镜像</figcaption>
</figure>
<p>这个单位球有时候又叫视球（Viewing Sphere）</p>
<h3 id="归一化平面模型平面">归一化平面&amp;&amp;模型平面</h3>
<p>将世界坐标系的点投影到单位球后，我们进一步将其映射到<span class="math inline">\(Z=1\)</span>的平面上，这个平面又叫归一化平面（Normalized Plane）。 此时不同的投影模型会对在归一化平面上的点到原点的连线做放缩<span class="math inline">\(r(\theta)\)</span>，为了后文叙述的统一性，我们再拆分出一个模型平面。在归一化平面上的点只是<span class="math inline">\(P_c\)</span>与光心点的连线和平面的交点，即：</p>
<p><span class="math display">\[
p_n = \frac{P_c}{||Z_c||}\tag{3-3}
\]</span></p>
<p>在模型平面上（Model Plane），对归一化平面上的点做半径放缩，即</p>
<p><span class="math display">\[
\begin{split}
\boldsymbol{p}_d=
\begin{bmatrix}
r(\theta)\cos(\alpha)\\
r(\theta)\sin(\alpha)\\
1
\end{bmatrix}=
\begin{bmatrix}
u_d\\
v_d\\
1
\end{bmatrix}
\end{split}\tag{3-4}
\]</span></p>
<p>这两个平面的变换过程如下图所示</p>
<figure>
<img src="./imgs/06-normalized_plane.png" alt="" /><figcaption>归一化平面投影&amp;&amp;模型平面</figcaption>
</figure>
<p>从第二节中经典的投影模型我们发现，其实不同的投影模型都没有对<span class="math inline">\(\alpha\)</span>产生影响，而是对投影点到原点的距离<span class="math inline">\(r(\theta)\)</span>建立不同的函数形式</p>
<p>稍后我们会看到，为了能够将所有模型都统一为针孔投影模型，会将模型平面变为畸变平面，用更具有一般性的多项式代替前面<span class="math inline">\(r(\theta)\)</span>的表达形式。（因此，现在模型平面上的点用下标<span class="math inline">\(d\)</span>标明，表示distortion）</p>
<h3 id="透视变换">透视变换</h3>
<p>得到模型平面上的坐标<span class="math inline">\(\boldsymbol{p}_d=[u_d,v_d,1]^T\)</span>后，我们可以用相机内参<span class="math inline">\(K\)</span>将其变换到图像平面，这个步骤实际上就只是坐标的变换了。</p>
<p><span class="math display">\[
\begin{split}
u = f_xu_d+c_x\\
v = f_yv_d+c_y
\end{split}\tag{3-5}
\]</span></p>
<p>最后，我们可以得到一张完整地表达相机投影模型的示意图：</p>
<figure>
<img src="./imgs/07-unified_model.png" alt="" /><figcaption>相机投影模型统一表达形式</figcaption>
</figure>
<h3 id="将针孔投影带入上述统一模型">将针孔投影带入上述统一模型</h3>
<p>我们可以将针孔模型，即<span class="math inline">\(r(\theta)=\tan(\theta)\)</span>代入上面的模型，联立公式（3-1）-（3-5）,最后可以发现，公式（3-5）的结果其实就是公式（1-3），也就是针孔投影模型的公式。这个过程比较简单，就不再展开公式。读者自己推导一下这个过程非常有利于理解上述的过程。</p>
<h3 id="不同投影模型的函数图">不同投影模型的函数图</h3>
<p>我们可以将不同的经典投影模型的函数画出来（横轴为<span class="math inline">\(\theta\)</span>，纵轴为<span class="math inline">\(r(\theta)\)</span>），结果如下</p>
<figure>
<img src="./imgs/07-classic_proj_plot.jpg" alt="" /><figcaption>经典投影模型的函数曲线</figcaption>
</figure>
<p>从上图我们应该至少要观察到一个重要的事实：针孔投影模型无法对<span class="math inline">\(&gt;=90\degree\)</span>的视野成像。因为<span class="math inline">\(\tan(\cdot)\)</span>在90度的时候会趋于无穷大。实际上，从上面的函数图可以看到，针孔投影模型只能在大约水平140度以内的视野成像</p>
<h3 id="相机投影模型总结">相机投影模型总结</h3>
<p>到目前位置，我们应该建立至少以下几个方面的认识：</p>
<ol type="1">
<li>统一化的投影模型经过：单位球投影-&gt;归一化平面-&gt;透视变换几个过程，将一个三维点投影到图像上的像素</li>
<li>不同的经典投影模型在投影过程中不会改变光束与<span class="math inline">\(X\)</span>轴的夹角，只是对像素到图像原点的距离建立不同的方程</li>
</ol>
<h2 id="四相机的畸变">四、相机的畸变</h2>
<h3 id="针孔模型的优越性">针孔模型的优越性</h3>
<p>首先描述一下我们人类直观上对于“标准的图像”这个词的一个感性认识，是不是我们会觉得横平竖直，真实中是直线则图像中也是直线，这样的图片会比较“标准”？事实上，针孔投影模型就刚好具有这样的性质。这个性质也可以从其投影方程看出来。经过针孔成像的物体，好像就是把整个物体缩小放在图片上，因此圆是圆，直线是直线。而其他投影模型就可能会呈现膨胀、紧缩的成像效果。如下图</p>
<figure>
<img src="./imgs/08-image_affect.png" alt="" /><figcaption>标准的针孔成像与其他投影模型的图像</figcaption>
</figure>
<h3 id="定义">定义</h3>
<p>“畸变”这个词从词语上应该理解成由于镜头加工等因素造成镜头与投影模型的差异。但实际上，<strong>相机畸变现在描述的是相机成像过程与针孔投影模型的差异（a deviation from the pinhole model）</strong> ，也就是：针孔投影+畸变模型=实际成像</p>
<p>而“去畸变”则是使用畸变模型对图像进行逆操作，使得图像就像用针孔投影模型成像出来的一样。</p>
<h3 id="在归一化平面插入畸变模型">在归一化平面插入畸变模型</h3>
<p>为了能够利用针孔模型的性质，我们在前文给出的统一相机投影模型中将模型平面用畸变平面代替。这里的核心思想是，<strong>用一个更具一般性的多项式替代各个投影模型中的模型函数，以此达到用一个方程表达多个投影模型的目的。</strong></p>
<p>替换后的示意图如图所示：</p>
<figure>
<img src="./imgs/09-distortion_plane.png" alt="" /><figcaption>加入畸变平面的投影模型</figcaption>
</figure>
<p>注意上图与上一节最后的统一投影模型其实是一样的，不过Model Plane名字换成Distortion Plane</p>
<p>我们这一节采用<a href="#OpenCV2.4">OpenCV实现的畸变模型</a>来讲解畸变过程</p>
<p>我们还是先将<span class="math inline">\(P_c\)</span>点投影到归一化平面得到<span class="math inline">\(\boldsymbol{p}_n=[u_n,v_n]\)</span>，并令其到原点的半径为<span class="math inline">\(r=\sqrt{(u_n^2+v_n^2)}\)</span></p>
<h3 id="径向畸变radial-distortion">径向畸变（Radial Distortion）</h3>
<p>所谓的径向畸变（Radial Distortion）就是指只对点<span class="math inline">\(p_n\)</span>做半径上的伸缩变化，这一点其实就跟经典投影模型一样用一个函数建立半径的变化，在OpenCV中，标准镜头的径向畸变可以用如下方程表达：</p>
<p><span class="math display">\[
\begin{split}
&amp;u^{\prime}=u_n(1+k_1r^2+k_2r^4+k_3r^6)\\
&amp;v^{\prime}=v_n(1+k_1r^2+k_2r^4+k_3r^6)
\end{split}\tag{4-1}
\]</span></p>
<p>径向畸变对于环绕光轴一周的改变是一致的，因此也叫做半径对称畸变（Radial Symmetric Distortion）或者畸变的对称部分（Symmetric Part Of Distortion Model）</p>
<h3 id="切向畸变tangential-distortion">切向畸变（Tangential Distortion）</h3>
<p>真实的镜头由于加工误差和安装误差，会导致镜头与感光原件的中心不是完全对齐的，因此在平行的方向上会与标准的针孔成像模型有差异，这种差异对于光轴不是旋转对称的，也叫做切向畸变（Tangential Distortion）</p>
<p>OpenCV中镜头的切向畸变方程如下：</p>
<p><span class="math display">\[
\begin{split}
u_{d}=u^{\prime}+2p_1u_nv_n+p_2(r^2+2u_n)\\
v_{d}=v^{\prime}+p_1(r^2+2{v_n}^2) + 2p_2u_nv_n
\end{split}\tag{4-2}
\]</span></p>
<p>公式（4-1）和公式（4-2）中的<span class="math inline">\(k_1,k_2,k_3,p_1,p_2\)</span>叫做畸变参数（Distortion Coefficients）</p>
<h3 id="去畸变">去畸变</h3>
<p>有了畸变模型之后，我们就可以将一个三维点经过：单位球投影-&gt;归一化平面投影-&gt;畸变模型-&gt;透视变换，得到该点在图像中的像素位置。我们可以通过一些标定物，经过求解得到上述的畸变系数，进而得到畸变过程的反过程。我们将图像上的点先经过透视变换的反变换得到在畸变平面上的点，再经过畸变过程的反过程，再投回图像中，这样我们就得到一副没有畸变的图像，其看起来就像是用完全标准的针孔投影模型成像的照片。</p>
<p>下面的图片展示了从畸变到去畸变的图像变化</p>
<figure>
<img src="./imgs/10-distorted_to_undistorted.png" alt="" /><figcaption>去畸变图像变化</figcaption>
</figure>
<p>做完去畸变后，整个的成像过程就像直接用针孔投影模型（公式1-3）成像一般，就像下图一样。</p>
<figure>
<img src="./imgs/11-undistorted_model.png" alt="" /><figcaption>去畸变的等效投影过程</figcaption>
</figure>
<p>提出畸变模型的文章需要给出如何标定出畸变参数，同时如何计算从畸变点到非畸变点，这里面主要是一些数学求解，这里就不展开讨论，有兴趣的可以看看<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction">wiki:Distortion</a></p>
<h2 id="五全景相机omidirectional-camera">五、全景相机（Omidirectional Camera）</h2>
<p>所谓的全景相机广泛概念上指成像角度能够大于等于180度的相机，他们看起来大概像是下面这样</p>
<figure>
<img src="./imgs/12-omni_cam.png" alt="" /><figcaption>全景相机类型</figcaption>
</figure>
<p>从第二节（不同的相机投影模型）我们可以知道，根据针孔投影模型设计出的镜头无法对大于等于90度（左右）的视野成像，通常由于进光量等问题，这类相机一般只有140度左右的成像视野。</p>
<p>一般的畸变模型的设计以针孔相机模型为基础，通过参数模型修正真实的成像与针孔成像的差异，因为在很多的应用中我们希望能够通过“去畸变”的方式，将图片变成“直线还是直线（Straight lines are straight），在<a href="#KannalaBrandt">KannalaBrandt论文</a>中是这样描述的：</p>
<blockquote>
<p>It is impossible to project the hemispherical field of view on a finite image plane by a perspective projection so fish-eye lenses are designed to obey some other projection model.This is the reason why the inherent distortion of a fish-eye lens should not be considered only as a deviation from the pinhole model</p>
</blockquote>
<p>于是，就有很多专门针对全景相机（<strong>Omidirection Camera/Fisheye Camera/Wide-Angle camera</strong>）的建模研究出现。</p>
<p>重新理清一下我们的目的：</p>
<ol type="1">
<li>拥有一种统一的表达方式能够尽量拟合真实的全景相机的成像过程</li>
<li>这种表达方式应该简洁有效</li>
<li>能够对模型的参数求解，并将图像通过“去畸变”变成像是由针孔相机拍摄出来的横平竖直的图像</li>
</ol>
<p>OpenCV中针对全景相机的标定和去畸变给出了两种实现</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/TPAMI.2006.153">KannalaBrandt模型</a>.对应实现<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/db/d58/group__calib3d__fisheye.html">OpenCV::Fisheye</a></li>
<li><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ROBOT.2007.364084">CMei模型</a>. 对应实现<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/dd/d12/tutorial_omnidir_calib_main.html">OpenCV::Omnidir</a></li>
</ol>
<p>下面简单介绍这两种模型</p>
<h3 id="kannalabrandt模型">KannalaBrandt模型</h3>
<p>第一步还是先将点投影到单位球模型，这样我们就得出了<span class="math inline">\(\theta,\alpha\)</span>两个角度，后续的畸变模型就是关于这两个角度的函数</p>
<p>这里这里摘录OpenCV的描述方式<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/db/d58/group__calib3d__fisheye.html">OpenCV_Fisheye</a>，相比于论文，在模型参数上简化了很多</p>
<p>KannalaBrandt模型使用一个多项式描述径向畸变（畸变的对称部分）</p>
<p><span class="math display">\[
\begin{split}
&amp;\boldsymbol{p}_n=\frac{P_c}{P_z}=[u_n,v_n,1]^T\\
\\
&amp;r = \sqrt{u_n^2+v_n^2}\\
\\
&amp;\theta_d = k_1\theta + k_2\theta^3 + k_3\theta^5+k_4\theta^7+k_5\theta^9+....
\end{split}\tag{5-1}
\]</span></p>
<p>径向畸变后坐标变为：</p>
<p><span class="math display">\[
\begin{split}
u^{\prime} = \frac{\theta_d}{r}u_n\\
v^{\prime} = \frac{\theta_d}{r}v_n
\end{split}\tag{5-2}
\]</span></p>
<p>最后再进行非对称畸变</p>
<p><span class="math display">\[
\begin{split}
&amp;u_d=u^{\prime}+\alpha v^{\prime}\\
&amp;v_d=v^{\prime}
\end{split}\tag{5-3}
\]</span></p>
<p>最后再经过公式（3-5）变换到图像坐标系</p>
<h3 id="cmei模型">CMei模型</h3>
<p>CMei模型相比于其他模型有一个较大不同之处在于在从单位球投影到归一化平面时将相机光心往后移动了距离<span class="math inline">\(\xi\)</span>，总体的投影过程如下图：</p>
<figure>
<img src="./imgs/13-cmei_model.png" alt="" /><figcaption>CMei投影模型</figcaption>
</figure>
<p>上图出自引用CMei的一篇论文：Design and Calibration of an Omni-RGB+D Camera</p>
<h2 id="六代码实例">六、代码实例</h2>
<h3 id="实例一针孔投影模型去畸变">实例一：针孔投影模型去畸变</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># undistort image</span></span><br><span class="line">h,  w = img.shape[:<span class="number">2</span>]</span><br><span class="line">newcameramtx, roi = cv2.getOptimalNewCameraMatrix(K, distortions, (w,h), alpha, (w,h))</span><br><span class="line">undistorted_img = cv2.undistort(img, K, distortions, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">x, y, w, h = roi</span><br><span class="line">undistorted_img = undistorted_img[y:y+h, x:x+w]</span><br><span class="line"></span><br><span class="line"><span class="comment"># undistort image points</span></span><br><span class="line"><span class="keyword">if</span> points2d.ndim == <span class="number">2</span>:</span><br><span class="line">    points2d = points2d[:, <span class="literal">None</span>, :]</span><br><span class="line">undistorted_points = cv2.undistortPoints(points2d, K, distortions, P=K)</span><br><span class="line">undistorted_points = undistorted_points.reshape(-<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="实例二cmei模型去畸变">实例二：CMei模型去畸变</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># undistort image</span></span><br><span class="line"><span class="keyword">if</span> newK:</span><br><span class="line">        K_new = np.zeros((<span class="number">3</span>,<span class="number">3</span>), np.float64)</span><br><span class="line">        h,w = img.shape[:<span class="number">2</span>]</span><br><span class="line">        K_new[<span class="number">0</span>, <span class="number">0</span>] = w/<span class="number">4</span></span><br><span class="line">        K_new[<span class="number">0</span>, <span class="number">2</span>] = w/<span class="number">2</span></span><br><span class="line">        K_new[<span class="number">1</span>, <span class="number">1</span>] = h/<span class="number">4</span></span><br><span class="line">        K_new[<span class="number">1</span>, <span class="number">2</span>] = h/<span class="number">2</span></span><br><span class="line">        K_new[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        K_new = <span class="literal">None</span></span><br><span class="line">undistorted_img = cv2.omnidir.undistortImage(</span><br><span class="line">img, K, distortions, Xi, cv2.omnidir.RECTIFY_PERSPECTIVE, Knew=K_new)</span><br><span class="line"></span><br><span class="line"><span class="comment"># undistort image points</span></span><br><span class="line"><span class="keyword">if</span> points2d.ndim == <span class="number">2</span>:</span><br><span class="line">    points2d = points2d[:, <span class="literal">None</span>, :]</span><br><span class="line">undistorted_points = cv2.omnidir.undistortPoints(points2d, K, distortions, Xi, <span class="literal">None</span>)</span><br><span class="line">undistorted_points = undistorted_points.squeeze()</span><br><span class="line"></span><br><span class="line">f0 = K_new[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">f1 = K_new[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">c0 = K_new[<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">c1 = K_new[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">undistorted_points[:, <span class="number">0</span>] = f0* undistorted_points[:, <span class="number">0</span>] + c0</span><br><span class="line">undistorted_points[:, <span class="number">1</span>] = f1 * undistorted_points[:, <span class="number">1</span>] + c1</span><br></pre></td></tr></table></figure>
<p><strong>PS</strong>:cv2::omnidir::undisortPoints的旧版本有bug，参考这个<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv_contrib/issues/1612">issue</a>。omnidir空间目前还没有成为opencv的正式稳定接口，因此维护在opencv-contrib-python包中，最新的包（4.6.x）已经修复了bug。一定要检查一下是不是有那个bug！！！！</p>
<h3 id="实例三kannalabrandt模型去畸变">实例三：KannalaBrandt模型去畸变</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You should replace these 3 lines with the output in calibration step</span></span><br><span class="line">DIM=XXX</span><br><span class="line">K=np.array(YYY)</span><br><span class="line">D=np.array(ZZZ)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">undistort</span>(<span class="params">img_path</span>):</span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line">    h,w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    map1, map2 = cv2.fisheye.initUndistortRectifyMap(K, D, np.eye(<span class="number">3</span>), K, DIM, cv2.CV_16SC2)</span><br><span class="line">    undistorted_img = cv2.remap(img, map1, map2, interpolation=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;undistorted&quot;</span>, undistorted_img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">        undistort(p)</span><br></pre></td></tr></table></figure>
<h2 id="相机标定方法">相机标定方法</h2>
<p>最经典的是使用张正友标定法。<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf">原文</a>;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94244568">中文讲解</a></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/d9/d0c/group__calib3d.html#:~:text=Detailed%20Description">OpenCV:Camera Calibration</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html">OpenCV2.4:Camera Calibration</a></p></li>
<li><p><a target="_blank" rel="noopener" href="http://michel.thoby.free.fr/Fisheye_history_short/Projections/Models_of_classical_projections.html">Models for the various classical lens projections</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction">Wiki:Distortion</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/TPAMI.2006.153">KannalaBrandt:A Generic Camera Model and Calibration Method for Conventional, Wide-Angle, and Fish-Eye Lenses</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ROBOT.2007.364084">CMei: Single View Point Omnidirectional Camera Calibration from Planar Grids</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/db/d58/group__calib3d__fisheye.html">OpenCV::Fisheye</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/dd/d12/tutorial_omnidir_calib_main.html">OpenCV::Omnidir</a></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/31/slam-theory/lie-group-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/31/slam-theory/lie-group-01/" class="post-title-link" itemprop="url">SLAM基础——李代数基础概念及公式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-31 21:56:58" itemprop="dateCreated datePublished" datetime="2023-05-31T21:56:58+08:00">2023-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 11:31:48" itemprop="dateModified" datetime="2023-06-14T11:31:48+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/05/31/slam-theory/lie-group-01/" class="post-meta-item leancloud_visitors" data-flag-title="SLAM基础——李代数基础概念及公式" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="SLAM基础——李代数基础概念及公式" href="/2023/05/31/slam-theory/lie-group-01/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::2cf0b705b902423269f4cebef74df287" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="李群李代数基础概念">李群李代数基础概念</h2>
<h3 id="群groups-李群liegroups">群（Groups） &amp;&amp; 李群（LieGroups）</h3>
<h4 id="群的定义">群的定义</h4>
<p>群是一种 <strong><em>集合</em></strong> 加上 <strong><em>一种运算</em></strong> 的代数结构，这种运算需要满足几个条件（可以不用记住）</p>
<p><strong>例</strong> ：旋转矩阵（集合）和矩阵乘法（运算），矩阵乘法对于旋转矩阵具有很良好的性质（符合群运算的定义），于是旋转矩阵是一种群。</p>
<h4 id="特殊正交群">特殊正交群</h4>
<p>特殊正交群（Special Orthogonal Group）记为<span class="math inline">\(SO(n)\)</span>，又叫旋转矩阵群。 例：<strong><em>三维</em></strong> 旋转矩阵构成特殊正交群<span class="math inline">\(SO(3)\)</span></p>
<p><span class="math display">\[
SO(3) = \{R \in \mathbb{R}^{3\times 3}:R^{T}R=\mathbf{I},det(R)=1\}
\]</span></p>
<h4 id="特殊欧式群">特殊欧式群</h4>
<p>特殊欧式群记为<span class="math inline">\(SE(n)\)</span>，对应<span class="math inline">\(n\)</span>维的欧式变换（旋转加平移）</p>
<h4 id="李群">李群</h4>
<p>李群是具有连续（光滑）性质的群</p>
<p>例：旋转可以连续地进行，平移也可以连续地进行，所以<span class="math inline">\(SO(3)\)</span>、<span class="math inline">\(SE(3)\)</span>都是李群</p>
<h3 id="李代数">李代数</h3>
<h4 id="反对称矩阵符号">反对称矩阵符号</h4>
<p>对于一个三维向量<span class="math inline">\(\boldsymbol{\phi}=[\phi_1,\phi_2,\phi_3]^T\)</span>，记其对应的反对称矩阵<span class="math inline">\(\boldsymbol{\phi}^{\wedge}\in \mathbb{R}^{3\times3}\)</span>，具有如下形式。符号<span class="math inline">\(\wedge\)</span>称作<em>hat</em></p>
<p><span class="math display">\[
\boldsymbol\phi^{\wedge} = 
\begin{bmatrix}
\phi_1\\
\phi_2\\
\phi_3
\end{bmatrix}^{\wedge}
=\
\begin{bmatrix}
0&amp;-\phi_3&amp;\phi_2\\
\phi_3&amp;0&amp;-\phi_1\\
-\phi_2&amp;\phi_1&amp;0
\end{bmatrix}\tag{hat}
\]</span></p>
<p>同样的，任意一个反对称矩阵通过<em>vee</em>操作得到对应的三维向量</p>
<p><span class="math display">\[
(\boldsymbol\phi^{\wedge})^{\vee}
=\
\begin{bmatrix}
0&amp;-\phi_3&amp;\phi_2\\
\phi_3&amp;0&amp;-\phi_1\\
-\phi_2&amp;\phi_1&amp;0
\end{bmatrix}^{\vee}
=\begin{bmatrix}
\phi_1\\
\phi_2\\
\phi_3
\end{bmatrix}\tag{vee}
\]</span></p>
<h4 id="李代数与李群的关系">李代数与李群的关系</h4>
<ul>
<li><p>每个李群都对应一个李代数。<span class="math inline">\(SO(3)\)</span>群的李代数是<span class="math inline">\(\mathfrak{so}(3)\)</span></p></li>
<li><p>为了不造成理解困难，这里只用<span class="math inline">\(SO(3)\)</span>群作为讲解。（笔者发现，用<span class="math inline">\(SO(3)\)</span>群作为例子，不看<span class="math inline">\(SE(3)\)</span>群理解起来会更容易）</p></li>
<li><p>为什么要引入李代数？ 一句话说明：在<span class="math inline">\(SO(3)\)</span>群上求导不太容易，因为旋转矩阵上的加法没有良好性质（两个旋转矩阵的加法不一定是一个旋转矩阵;回忆导数的定义，输入的微小变化造成的输出的改变量），而旋转矩阵的乘积在其中一者为微小量的时候，可以对应到李代数空间的线性关系。利用这一性质可以对旋转矩阵进行求导。旋转矩阵的更性也可以对应到李代数空间上的线性更新。后文会详细解说。</p></li>
<li><p>李代数对应李群单位元处的切空间 旋转矩阵群的单位元就是单位矩阵。李代数对应李群单位元处的切空间这一点只是两者的性质，与后文的指数/对数映射没有太大关系。（笔者一开始总是误会指数/对数映射只能在李群单位元处进行）</p></li>
</ul>
<h4 id="对数映射log和指数映射exp">对数映射（log）和指数映射（exp）</h4>
<p>《视觉SLAM十四讲》中这部分内容（第四讲）是通过旋转矩阵求导引出的，但其实这部分的推导只是建立一个感性的理解。李群李代数的指数/对数映射应该具有更严格的定义。所以这部分内容其实不要太过纠结。</p>
<p><strong><em>再次强调</em></strong>：这部分推导只是为了建立感性认识</p>
<p>由于旋转矩阵的性质：</p>
<p><span class="math display">\[
RR^T = \mathbf{I}
\]</span></p>
<p>上式对旋转矩阵求导（<span class="math inline">\(\dot{R}\)</span>表示<span class="math inline">\(R\)</span>的导数）：</p>
<p><span class="math display">\[
\dot{R}R^T + R\dot{R}^T=\mathbf{0}
\]</span></p>
<p>（这里对旋转矩阵求导，应该将其看作是一个变量，在时刻变化）</p>
<p>即：</p>
<p><span class="math display">\[
\dot{R}R^T = -R\dot{R}^T=-(\dot{R}R^T)^T
\]</span></p>
<p>也就是<span class="math inline">\(\dot{R}R^T\)</span>是一个反对称矩阵，我们将其记为<span class="math inline">\(\boldsymbol{\phi}^{\wedge}\)</span>，则我们可以得到：</p>
<p><span class="math display">\[
\begin{split}
\dot{R}R^T &amp;= \boldsymbol{\phi}^{\wedge}\\
\dot{R} &amp;= \boldsymbol{\phi}^{\wedge}R
\end{split}
\]</span></p>
<p>上式是关于<span class="math inline">\(R\)</span>的一个微分方程，我们可以看出，当</p>
<p><span class="math display">\[
R=\exp(\boldsymbol{\phi}^{\wedge})
\]</span></p>
<p>的时候，刚好满足上面的微分方程。同时，当<span class="math inline">\(R=\mathbf{I}\)</span>时，上面的微分方程刚好是<span class="math inline">\(\dot{R}=\boldsymbol{\phi}^{\wedge}\)</span>，所以说反对称矩阵空间是旋转矩阵单位元处的切平面（导数）。</p>
<p>于是，我们直接地引入定义：指数映射将李代数空间映射到李群空间，指数映射将李群映射到李代数空间。</p>
<p><span class="math display">\[
\begin{split}
\exp(\cdot):\mathfrak{so}(3)\rightarrow SO(3)\\
\log(\cdot):SO(3) \rightarrow \mathfrak{so}(3)
\end{split}
\]</span></p>
<h2 id="so3上的对数映射mathfrakso3的指数映射">SO(3)上的对数映射/<span class="math inline">\(\mathfrak{so}(3)\)</span>的指数映射</h2>
<h3 id="mathfrakso3的指数映射"><span class="math inline">\(\mathfrak{so}(3)\)</span>的指数映射</h3>
<p>令三维向量<span class="math inline">\(\boldsymbol{\phi}\)</span>的模为<span class="math inline">\(\theta\)</span>，方向向量为<span class="math inline">\(\boldsymbol{a}\)</span>，即</p>
<p><span class="math display">\[
\theta = ||\boldsymbol{\phi}||\\
\boldsymbol{a} = \frac{\boldsymbol{\phi}}{||\boldsymbol{\phi}||}
\]</span></p>
<p>经过一系列的推导，可以得到指数映射的公式如下：</p>
<p><span class="math display">\[
\begin{split}
\exp(\boldsymbol{\phi}^{\wedge}) &amp;= \exp(\theta\boldsymbol{a})\\
&amp;= \cos{\theta}\mathbf{I} + (1 - \cos{\theta})\boldsymbol{a}\boldsymbol{a}^T+\sin{\theta}\boldsymbol{a}^{\wedge}
\end{split}\tag{exp-1}
\]</span></p>
<p>上面公式的一种等价写法（不使用模和方向代替）为：</p>
<p><span class="math display">\[
\begin{split}
\exp(\boldsymbol{\phi}^{\wedge}) = \mathbf{I} + \frac{\sin{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||} + \frac{1 - \cos{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||^2}(\boldsymbol{\phi}^{\wedge})^2
\end{split}\tag{exp-2}
\]</span></p>
<p>上面这两个公式叫做罗德里格斯（Rodrigues' formula），也是将 <strong><em>旋转向量</em></strong> 变换为旋转矩阵的变换公式。从上面两个公式我们也可以看出，<span class="math inline">\(\mathfrak{so}(3)\)</span>李代数空间实际上也是 <strong><em>旋转向量</em></strong> 组成的空间。又因为旋转角的周期为<span class="math inline">\(2\pi\)</span>，所以一个旋转向量可以对应到一个旋转矩阵，但是一个旋转矩阵会对应到多个旋转向量（满射）。但是如果将旋转角限制在<span class="math inline">\([-\pi,\pi)\)</span>，则是单射。</p>
<h3 id="so3上的对数映射">SO(3)上的对数映射</h3>
<p>从上面的关系，我们可以知道要把李群<span class="math inline">\(SO(3)\)</span>映射到李代数，只需要用旋转矩阵计算旋转矢量即可。从旋转矩阵<span class="math inline">\(R\)</span>计算旋转角公式为：</p>
<p><span class="math display">\[
\theta = \arccos \frac{tr(R)-1}{2}\tag{ln-01}
\]</span></p>
<p>又由于旋转轴使用旋转矩阵旋转后方向不变，即：</p>
<p><span class="math display">\[
R\boldsymbol{a} = \boldsymbol{a}\tag{ln-02}
\]</span></p>
<p>所以<strong>旋转轴对应<span class="math inline">\(R\)</span>特征值为1的特征向量</strong></p>
<p>轴向量也可以使用下面公式计算</p>
<p><span class="math display">\[
\log(R) = 
\frac{\theta \cdot (R-R^T)}{2sin(\theta)}\quad \text{with} \quad R\neq\mathbf{I}\tag{ln-03}
\]</span></p>
<h3 id="指数映射的一阶近似">指数映射的一阶近似</h3>
<p>指数映射的严格展开形式为:</p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge}) = \sum^{\infty}_{n=0}\frac{1}{n!}(\boldsymbol{\phi}^{\wedge})^n
\]</span></p>
<p>当<span class="math inline">\(\boldsymbol{\phi}\)</span>是微小量时，忽略二次项及以上，得到指数映射的一阶近似：</p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge})\approx \mathbf{I} + \boldsymbol{\phi}^{\wedge} \tag{exp-1st}
\]</span></p>
<p><strong><em>上面这个公式经常被使用到，要牢记</em></strong></p>
<h2 id="李群李代数总结">李群李代数总结</h2>
<ul>
<li>引入李代数的原因是在SLAM中常用的群：<span class="math inline">\(SO(3),SE(3),Sim(3)\)</span>没有良好定义的加法，因此在优化的时候没法直接往上更新一个微小增量</li>
<li>另一个原因是<span class="math inline">\(SO(3),SE(3),Sim(3)\)</span>这些群都有额外的限制，直接优化就变成了带约束的优化，而转到李代数空间则是一个无约束的优化问题</li>
<li>在后面我们可以看到当旋转矩阵乘以一个微小扰动可以对应到李代数空间的近似线性相加，这为优化带来很大的好处</li>
<li>李代数通过指数映射到李群，李群通过对数映射到李代数</li>
<li>李代数是李群单位元处的切平面</li>
<li>不要纠结上面的这句话！！！！对数映射/指数映射可以对整个李群/李代数空间进行映射！！！</li>
</ul>
<h2 id="bch近似">BCH近似</h2>
<p>BCH(Baker-Campbell-Hausdorff)公式表达两个李代数指数映射乘积的完整形式（很复杂，不用记），但是但忽略高阶项后则会出现优美的线性表达。</p>
<p>当旋转矩阵<span class="math inline">\(R\)</span>左乘或者右乘上一个微小量<span class="math inline">\(\Delta{R}\)</span>时，会近似（BCH近似）对应李代数空间线性相加，记<span class="math inline">\(R\)</span>的李代数为<span class="math inline">\(\boldsymbol{\phi}\)</span>，<span class="math inline">\(\Delta{R}\)</span>的李代数为<span class="math inline">\(\Delta \boldsymbol{\phi}\)</span></p>
<p><strong>BCH近似有左乘右乘两种形式，笔者发现学习的时候以一种形式去推导即可，更容易理解，下面以右乘的形式进行讲解（十四讲中是以左乘作为讲解）</strong></p>
<h3 id="bch近似右乘形式">BCH近似右乘形式</h3>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge})\exp(\boldsymbol{\Delta{\phi}}^{\wedge})=\exp\big(J_r^{-1}(\boldsymbol{\phi})\Delta{\boldsymbol{\phi}}+\boldsymbol{\phi}\big)\tag{BCH}
\]</span></p>
<p>其中<span class="math inline">\(J_r(\boldsymbol{\phi})\)</span>乘为右乘雅各比：</p>
<p><span class="math display">\[
J_r(\boldsymbol{\phi}) = \mathbf{I}-\frac{1-\cos{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||^2} + \frac{||\boldsymbol{\phi}||-\sin{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||^3}(\boldsymbol{\phi}^{\wedge})^2\tag{BCH-Jr}
\]</span></p>
<p>也可以写成轴-角的形式</p>
<p><span class="math display">\[
J_r{(\boldsymbol{\phi})} = \frac{\sin{\theta}}{\theta}\mathbf{I}+(1-\frac{\sin{\theta}}{\theta})\boldsymbol{a}\boldsymbol{a}^T-\frac{1-\cos{\theta}}{\theta}\boldsymbol{a}^{\wedge}
\]</span></p>
<p>上面两种等价关系的变换中需要用到一个性质</p>
<p><span class="math display">\[
\boldsymbol{a}^{\wedge}\boldsymbol{a}^{\wedge} = \boldsymbol{a}\boldsymbol{a}^T - \mathbf{I}
\]</span></p>
<p>另外</p>
<p><span class="math display">\[
J_r^{-1}(\boldsymbol{\phi})=\mathbf{I}+\frac{1}{2}\boldsymbol{\phi}^{\wedge}+\big(\frac{1}{||\boldsymbol{\phi}||^2}-\frac{1+\cos{||\boldsymbol{\phi}||}}{2||\boldsymbol{\phi}||\sin{||\boldsymbol{\phi}||}}\big)(\boldsymbol{\phi}^{\wedge})^2
\]</span></p>
<h3 id="bch近似的其他表达形式">BCH近似的其他表达形式</h3>
<p>BCH近似是为了能够将<span class="math inline">\(SO(3)\)</span>上的矩阵乘积变成李代数上的加法，下面几条公式只是公式（BCH）的其他表达形式，后面也会频繁用到</p>
<p><span class="math display">\[
\exp\big((\boldsymbol{\phi}+\Delta{\boldsymbol{\phi}})^{\wedge}\big) = \exp(\boldsymbol{\phi}^{\wedge})\exp(J_r\Delta{\boldsymbol{\phi}}^{\wedge})\tag{BCH-2}
\]</span></p>
<h2 id="so3上的李代数求导"><span class="math inline">\(SO(3)\)</span>上的李代数求导</h2>
<p>加入我们对一个空间点<span class="math inline">\(\boldsymbol{p}\)</span>进行旋转，得到<span class="math inline">\(R\boldsymbol{p}\)</span>，要求相对于<span class="math inline">\(R\)</span>的导数。由于<span class="math inline">\(SO(3)\)</span>上没有加法，于是我们没法直接使用导数的定义进行计算。但是我们可以将<span class="math inline">\(R\)</span>映射到李代数空间<span class="math inline">\(\boldsymbol{\phi}{\wedge}\)</span>，并在李代数空间进行求导（SLAM十四讲公式4.41使用BCH左乘模型推导，这里使用右乘模型推导）</p>
<h3 id="李代数空间求导">李代数空间求导</h3>
<p><span class="math display">\[
\begin{split}
\frac{\partial(R\boldsymbol{p})}{\partial{R}} &amp;= \frac{\partial{\big(\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}\big)}}{\partial{\boldsymbol{\phi}}}\\
&amp;\overset{1}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}\frac{\exp(\big(\boldsymbol{\phi}+\Delta{\boldsymbol{\phi}})^{\wedge}\big)\boldsymbol{p} - \exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{2}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})\exp(J_r\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{3}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})(\mathbf{I}+J_r\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{4}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})J_r\Delta{\boldsymbol{\phi}^{\wedge}}\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{5}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{-\exp(\boldsymbol{\phi}^{\wedge})J_r\boldsymbol{p}^{\wedge}\Delta{\boldsymbol{\phi}}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;=-RJ_r\boldsymbol{p}^{\wedge}
\end{split}
\]</span></p>
<p>上式的推导中，等号1是导数的定义;等号2使用BCH右乘近似公式，也就是上文公式（BCH-2）;等号3是指数映射的一阶近似，也就是上文公式（exp-1st）;等号5利用了下面的性质</p>
<p><span class="math display">\[
\boldsymbol{a}^{\wedge}\boldsymbol{b} = -\boldsymbol{b}^{\wedge}\boldsymbol{a}\tag{skew-prop}
\]</span></p>
<p>将上面的结果记为 <span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=-RJ_r\boldsymbol{p}^{\wedge}\tag{dR-alg-R}
\]</span></p>
<p>如果在上面的推导中使用左乘模型进行推导，结果会稍微有点不同：</p>
<p><span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=(-R\boldsymbol{p})^{\wedge}J_l\tag{dR-alg-L}
\]</span></p>
<h3 id="李群空间求导">李群空间求导</h3>
<p>另一种更常见的做法是在李群上对<span class="math inline">\(R\)</span>进行一个扰动<span class="math inline">\(\exp(\Delta{\boldsymbol{\phi}^{\wedge}})\)</span>，计算结果相对于扰动的变化率。SLAM十四讲中使用左扰动推导，这里使用右扰动推导一下</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial(R\boldsymbol{p})}{\partial{R}}
&amp;=\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})\exp(\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{1}{=}\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})(\mathbf{I}+\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{2}{=}\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})\Delta{\boldsymbol{\phi}^{\wedge}}\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{3}{=}\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}^{\wedge}\Delta{\boldsymbol{\phi}}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;=-R\boldsymbol{p}^{\wedge}
\end{split}
\]</span></p>
<p>其中等号1使用指数映射的一阶近似，也就是公式（exp-1st）;等号3使用反对称矩阵的性质，也就是公式（skew-prop）。</p>
<p>如果使用左扰动推导，结果会稍有不同，我们将两者记为如下</p>
<p>右扰动模型：</p>
<p><span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=-R\boldsymbol{p}^{\wedge}\tag{dR-group-R}
\]</span></p>
<p>左扰动模型：</p>
<p><span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=-(R\boldsymbol{p})^{\wedge}\tag{dR-group-L}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/30/slam-theory/MAP2LSP_02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/30/slam-theory/MAP2LSP_02/" class="post-title-link" itemprop="url">SLAM基础——如何从最大后验概率到最小二乘（应用篇）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-30 10:12:01" itemprop="dateCreated datePublished" datetime="2023-05-30T10:12:01+08:00">2023-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 11:53:54" itemprop="dateModified" datetime="2023-06-14T11:53:54+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/05/30/slam-theory/MAP2LSP_02/" class="post-meta-item leancloud_visitors" data-flag-title="SLAM基础——如何从最大后验概率到最小二乘（应用篇）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="SLAM基础——如何从最大后验概率到最小二乘（应用篇）" href="/2023/05/30/slam-theory/MAP2LSP_02/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::996c42066e615cfa17c6dba93a63cf5f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="理论篇回顾">理论篇回顾</h2>
<p>总结一下《理论篇》的推理过程：</p>
<ol type="1">
<li>SLAM后端优化的任务是最大似然函数，也就是在已知观测的情况下通过最大化似然函数确定最有可能的机器人位姿</li>
<li>最大似然在高斯分布的情况下最终可以转换成一个二次型，具体含义是最小化观测和模型的误差（经过信息矩阵也就是协方差倒数的加权）</li>
</ol>
<p>用公式可以写为：</p>
<p><span class="math display">\[
\begin{equation}
\begin{split}
\hat{x}_{MLE}
&amp;= \underset{x}{\operatorname{argmin}} \big(z-h(x)\big)^T\Sigma^{-1}\big(z-h(x)\big)\\
&amp;= \underset{x}{\operatorname{argmin}}||z - h(x)||^2_{\Sigma^{-1}}\\
&amp;= \underset{x}{\operatorname{argmin}}||e_z||^2_{\Sigma^{-1}}
\end{split}
\end{equation}
\tag{1}
\]</span></p>
<h2 id="最小二乘的标准形式">最小二乘的标准形式</h2>
<p>在前文的公式中，向量的符号没有加粗，且推导的过程没有用正式的符号，这里先对前面的结果做更标准化的复述。</p>
<p>令机器人每一时刻的位姿为<span class="math inline">\(\boldsymbol{x}_i, i\in [0,1,2,...)\)</span>，每一时刻的观测为<span class="math inline">\(\boldsymbol{z}_i,i\in[0,1,2,...)\)</span>，记机器人历史轨迹的位姿集合为<span class="math inline">\(\boldsymbol{X},\boldsymbol{x}_i\in\boldsymbol{X}\)</span>，则公式（1）可以写为：</p>
<p><span class="math display">\[
\begin{split}
\hat{\boldsymbol{X}}_{MLE}
&amp;= \underset{\boldsymbol{x}_i}{\operatorname{argmin}}\sum_{i}\big(\boldsymbol{z}_i - \boldsymbol{h}(\boldsymbol{x}_i)\big)^T\boldsymbol{\Sigma}_i^{-1}\big(\boldsymbol{z}_i - \boldsymbol{h}(\boldsymbol{x}_i)\big)\\
&amp;=\underset{\boldsymbol{x}_i}{\operatorname{argmin}}\sum_{i}\boldsymbol{e}_i^T\boldsymbol{\Sigma}_i^{-1}\boldsymbol{e}_i
\end{split}\tag{2}
\]</span></p>
<p>上面的形式又叫加权的平方误差（Weighted Sum of Squared Error），权重系数在这里是<span class="math inline">\(\boldsymbol{\Sigma}_i^-1\)</span>，也就是协方差的倒数，直观含义就是对于不确定的观测（方差较大）赋予较低的权重。我们可以对<span class="math inline">\(\boldsymbol{e}_i\)</span>提前乘以一个系数<span class="math inline">\(L_i\)</span>，<span class="math inline">\(L_i\)</span>满足<span class="math inline">\(\boldsymbol{\Sigma}_i^{-1}=\boldsymbol{L}_i\boldsymbol{L}_i^T\)</span>，并记<span class="math inline">\(\bar{\boldsymbol{e}}_i=\boldsymbol{L}_i\boldsymbol{e}_i\)</span>，则</p>
<p><span class="math display">\[
\begin{split}
\hat{\boldsymbol{X}}_{MLE}&amp;=\underset{\boldsymbol{x}_i}{\operatorname{argmin}}\sum_{i}||\bar{\boldsymbol{e}}_i||^2
\end{split}\tag{3}
\]</span></p>
<p>公式（3）称为最小二乘的标准形式。</p>
<p>不过要注意的是，在SLAM中一些优化问题中比如BA,是直接构造最小二乘问题，同时也没有加入权重。这并不影响我们的理解。最小二乘问题从直观上就是让误差最小化。</p>
<h2 id="bundleadjustment">BundleAdjustment</h2>
<p>我觉得在这里加入BA(BundleAdjustment)问题的讲解可以加深对这部分的印象和理解。BA又叫光束法平差，或者捆绑调整。Bundle的意思是同时对相机位姿和关键点进行优化。</p>
<p><strong>PS</strong>：这部分其实《视觉SLAM十四讲》第九讲讲得很好，也可以直接参考十四讲的内容。这里主要和前文的公式建立联系，让这一部分的内容更为完整。</p>
<p>假设机器人移动经过三个点，相机的位姿分别为<span class="math inline">\(\boldsymbol{x}_1,\boldsymbol{x}_2, \boldsymbol{x}_3\)</span>，空间中有三个路标点<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2,\boldsymbol{p}_3\)</span></p>
<figure>
<img src="./imgs/01-BA.png" alt="" /><figcaption>BA问题示例图</figcaption>
</figure>
<p>定义相机投影方程<span class="math inline">\(\pi(\cdot)\)</span>，相机投影方程将世界坐标系下的点转换到相机坐标系然后投影到像素坐标系：</p>
<p><span class="math display">\[
\pi(\boldsymbol{p}) = K\big(R\boldsymbol{p}+\boldsymbol{t}\big)
\]</span></p>
<p>其中，<span class="math inline">\(K\)</span>是相机内参，<span class="math inline">\(R,\boldsymbol{t}\)</span>是相机位姿</p>
<p>关键点可以直接通过图像计算得到，也就是观测<span class="math inline">\(\boldsymbol{z}_i := [u_i,v_i]^T\)</span></p>
<p>将所有时刻的位姿以及每个位姿能够观测到的特征点都累加起来，并用标准的二次平方损失函数表达，则整体的代价函数为</p>
<p><span class="math display">\[
\sum_{i=1}^{M}\sum_{j=1}^{N}||\boldsymbol{e}_{ij}||^2=\sum_{i=1}^{M}\sum_{j=1}^{N}||\boldsymbol{z}_i-\pi(\boldsymbol{p}_j)||^2
\]</span></p>
<p>将相机位姿<span class="math inline">\(\boldsymbol{x}_i\)</span>和路标（landmark）点<span class="math inline">\(\boldsymbol{p}_j\)</span>共同当作变量进行优化，得到优化方程如下：</p>
<p><span class="math display">\[
\begin{split}
\hat{\boldsymbol{X}},\hat{\boldsymbol{P}}
&amp;= \underset{\boldsymbol{x}_i, \boldsymbol{p}_j}{\operatorname{argmin}}\sum_{i=1}^{M}\sum_{j=1}^{N}v_{ij}||\boldsymbol{z}_i-\pi(\boldsymbol{p}_j)||^2
\end{split}\tag{3}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(M\)</span>是位姿点的数量，<span class="math inline">\(N\)</span>是路标点的数量</li>
<li><span class="math inline">\(v_{ij}\)</span>是一个二元变量，当点<span class="math inline">\(\boldsymbol{p}_j\)</span>能够被位姿点<span class="math inline">\(\boldsymbol{x}_i\)</span>观察到时，<span class="math inline">\(v_{ij}=1\)</span>，否则<span class="math inline">\(v_{ij}=0\)</span></li>
</ul>
<p>至于要如何求解上面的最小二乘公式，就是非线性优化了，要讲清楚可能要单开一篇文章。但是从上一篇还有这一篇的论述，读者应该要清晰地建立从MAP问题到最小二乘问题的推演过程，这样也才能够更好地理解论文里频繁出现的MAP</p>
<h2 id="鲁棒核函数">鲁棒核函数</h2>
<p>让我们重新看一下上述公式（3），求解这样的一个二次型一般需要用非线性优化方法，优化过程中会涉及到对这个二次型求偏导。这样就会出现一个问题，如果<span class="math inline">\(\boldsymbol{z}_i\)</span>与<span class="math inline">\(\boldsymbol{p}_j\)</span>的匹配关系出现错误，或者<span class="math inline">\(\boldsymbol{z}_i\)</span>计算错误，那么二次型就会非常大。这样在优化过程中，导数会被错误项占据主要地位，这样更新的时候就往错误的方向进行更新。</p>
<p><strong>PS:在上述描述的BA问题中，<span class="math inline">\(\boldsymbol{z}_i\)</span>通常是对图像进行特征点检测得出特征点的位置和描述子，<span class="math inline">\(\boldsymbol{p}_j\)</span>是地图中点，两者的匹配关系通常可以通过特征点匹配的方式得到。</strong></p>
<p>为了解决上面的问题，我们把二次函数替换为其他函数，使得在误差较大的地方函数值不至于过大导致导数过大。这些函数就叫鲁棒核函数（Robust Kernel）。</p>
<h3 id="huber核函数">Huber核函数</h3>
<p>一种较为常见的核函数叫做Huber核函数，在很多论文中都使用该函数，其具有如下形式</p>
<p><span class="math display">\[
H(e) = 
\begin{cases}
\frac{1}{2}e^2,&amp;||e||\leq \delta\\
\delta\left(||e||-\frac{1}{2}\delta\right),&amp;else
\end{cases}\tag{4}
\]</span></p>
<p>Huber核函数与二次函数的函数曲线如下图</p>
<figure>
<img src="./imgs/02-l2_huber.png" alt="" /><figcaption>Huber函数与二次函数曲线</figcaption>
</figure>
<h3 id="核函数的特点和其他核函数">核函数的特点和其他核函数</h3>
<p>从上面的描述中我们其实不难得出鲁棒核函数应该具有的两个特点：</p>
<ol type="1">
<li>光滑。即处处可导</li>
<li>函数增长的速度要比二次函数慢</li>
</ol>
<p>从Huber函数公式（4）我们可以看出当<span class="math inline">\(||e||=\delta\)</span>的时候，上下两式结果是一样的，因此Huber函数明显是一个光滑的函数。</p>
<p>常见的其他鲁棒核函数还有Cauchy、Tukey核等，从网上找了一张各个核函数和二次函数的函数曲线对比图</p>
<figure>
<img src="./imgs/03-robust_kernels.png" alt="" /><figcaption>不同核函数的函数曲线</figcaption>
</figure>
<h3 id="一些思考">一些思考</h3>
<p>鲁棒核函数让我联想到了神经网络中的激活函数，SLAM中的图优化也让我觉得跟神经网络的梯度回传有点相似。神经网络的训练目标其实也是MAP问题（从训练集中估计出样本的分布，并使用该分布来预测测试集），而且很多的神经网络目标函数也是一个二次型。不过区别比较大的是，神经网络中大部分操作是线性操作（卷积、全连接），而SLAM中很多操作都是非线性的（旋转）。在图优化中的更新过程使用非线性优化方法（比如高斯牛顿法）也是需要在每一步更新过程中近似估计目标函数对于变量的偏导数，这点与神经网络的梯度回传是类似的。</p>
<p>既然三层全连接层的神经网络就可以拟合任意次的函数，那么是否有可能用神经网络来做SLAM的后端优化？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/29/slam-theory/MAP2LSP_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/29/slam-theory/MAP2LSP_01/" class="post-title-link" itemprop="url">SLAM基础——如何从最大后验概率到最小二乘（理论篇）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-29 10:12:01" itemprop="dateCreated datePublished" datetime="2023-05-29T10:12:01+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 11:37:30" itemprop="dateModified" datetime="2023-06-14T11:37:30+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/05/29/slam-theory/MAP2LSP_01/" class="post-meta-item leancloud_visitors" data-flag-title="SLAM基础——如何从最大后验概率到最小二乘（理论篇）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="SLAM基础——如何从最大后验概率到最小二乘（理论篇）" href="/2023/05/29/slam-theory/MAP2LSP_01/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::beb83704626c889ddf4360511dbc14eb" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="最大后验概率">最大后验概率</h2>
<h3 id="符号说明">符号说明</h3>
<p>本文的标记没有用粗体表示，但是要记住本文的变量都是任意多维变量</p>
<h3 id="定义">定义</h3>
<p>最大后验概率（MAP:Maximum a Posterior）具有以下逻辑</p>
<ol type="1">
<li>我们的最终目标是想要估计一个未知量<span class="math inline">\(x\)</span>，令其概率分布为<span class="math inline">\(p(x)\)</span>.</li>
<li>如果我们能够知道<span class="math inline">\(p(x)\)</span>的具体表达，则<span class="math inline">\(x\)</span>的估计值应该使得概率最大</li>
<li>当我们知道一些与<span class="math inline">\(x\)</span>有关的观测结果<span class="math inline">\(z\)</span>，<span class="math inline">\(p(x|z)\)</span>称做<span class="math inline">\(x\)</span>的后验概率</li>
<li>于是我们的估计可以变成使得<span class="math inline">\(p(x|z)\)</span>最大化的<span class="math inline">\(x\)</span></li>
</ol>
<p>上述问题称作最大后验概率，也就是在已知观测值的情况下如何求取未知量。 从形式上可以做如下定义：</p>
<p><span class="math display">\[
\hat{x}_{MAP}(z)=\underset{x}{\operatorname{argmax\ }}p(x|z)\tag{1}
\]</span></p>
<h3 id="将上述定义代入slam问题">将上述定义代入SLAM问题</h3>
<ol type="1">
<li><span class="math inline">\(x\)</span>对应机器人的位姿</li>
<li><span class="math inline">\(z\)</span>对应SLAM系统的观测，比如路标点、激光里程计的输出、视觉里程计的输出等</li>
<li>SLAM的后端优化最终目标就是求取在给定的观测下，机器人的位姿估计值，也就是使得后验概率<span class="math inline">\(p(x|z)\)</span>最大化的位姿<span class="math inline">\(x\)</span></li>
</ol>
<h2 id="最大似然估计">最大似然估计</h2>
<h3 id="贝叶斯定理">贝叶斯定理</h3>
<p>为了让没有基础的读者更容易理顺推理的过程，我们先简单介绍一下贝叶斯定理（Bayes's theorem）</p>
<p>贝叶斯定义描述随机事件A和B的条件概率的一个关系： <span class="math display">\[
P(A|B) = \frac{P(A)P(B|A)}{P(B)}\tag{Bayes&#39;s Theorem}
\]</span></p>
<ul>
<li><span class="math inline">\(P(A)\)</span>是<span class="math inline">\(A\)</span>的先验概率，也就是事件<span class="math inline">\(A\)</span>的概率分布。<span class="math inline">\(P(B)\)</span>同理</li>
<li><span class="math inline">\(P(A|B)\)</span>是事件<span class="math inline">\(B\)</span>发生后<span class="math inline">\(A\)</span>的条件概率，也叫<span class="math inline">\(B\)</span>发生后<span class="math inline">\(A\)</span>的后验概率</li>
<li><span class="math inline">\(P(A|B)\)</span>表示的是事件<span class="math inline">\(B\)</span>是结果，A是因，就是在知道结果的情况下求原因的概率</li>
<li><span class="math inline">\(P(B|A)\)</span>是事件<span class="math inline">\(A\)</span>发生后<span class="math inline">\(B\)</span>的条件概率。但是应该理解当<span class="math inline">\(B\)</span>固定后<span class="math inline">\(A\)</span>的<strong>似然</strong>，也就是<span class="math inline">\(P(B|A)=L(A|B)\)</span></li>
<li><span class="math inline">\(P(B|A)\)</span>或者<span class="math inline">\(L(A|B)\)</span>表示已知有事件B发生，运用似然函数<span class="math inline">\(L(A|B)\)</span>，我们估计或猜测<span class="math inline">\(A\)</span>的不同值的可能性</li>
</ul>
<p><strong>注意：在上面中<span class="math inline">\(A、B\)</span>是有区分的，虽然<span class="math inline">\(P(B|A)\)</span>的形式与条件概率函数的形式相同，但是我们关注的变量是<span class="math inline">\(A\)</span></strong></p>
<p>参考： 1. 关于贝叶斯定理的推导<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bayes%27_theorem#Statement_of_theorem">wiki</a> 2. 关于似然函数的理解<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0">wiki</a></p>
<h3 id="从最大后验概率map到最大似然估计mle">从最大后验概率（MAP）到最大似然估计（MLE）</h3>
<p><strong>回顾</strong>：（对理解很重要，所以回顾一下）在公式（1）中，<span class="math inline">\(x\)</span>代表我们要估计的机器人位姿，<span class="math inline">\(z\)</span>代表我们的观测。这里的观测是一个宽泛的定义，路标（landmark）可以是一种观测，图像特征点也可以是一种观测，激光里程计或者视觉里程计的结果也可以是一种观测。 <strong>注意</strong>：应该是现有了机器人当前的位姿，然后在当前位姿下对周围环境进行观测。也就是当前位姿是 <strong><em>因</em></strong>，观测是 <strong><em>果</em></strong></p>
<p>根据贝叶斯定理，有：</p>
<p><span class="math display">\[
\begin{split}
p(x|z) &amp;= \frac{p(z|x)p(x)}{p(z)}\\
&amp;\propto p(z|x)p(x)
\end{split}
\]</span></p>
<p>上述公式结果的第一项称为 <strong><em>似然</em></strong>（likelihood），第二项是是 <strong><em>先验</em></strong>（prior） 用文字解释一下就是，直接求位姿的最大后验概率是很困难的，但是根据贝叶斯法则，我们可以转换为求取似然和先验的乘积的最大，即下式</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MAP} &amp;= \underset{x}{\operatorname{argmax\ }}p(x|z)\\
&amp;= \underset{x}{\operatorname{argmax\ }}p(z|x)p(x)\\
&amp;\approx \underset{x}{\operatorname{argmax\ }}p(z|x)
\end{split}\tag{2}
\]</span></p>
<p>当然，我们也没有机器人位姿的先验<span class="math inline">\(p(x)\)</span>，于是，公式（2）可以近似成只求取<strong>最大似然(MLE,Maximum LIkelihood Estimation)</strong></p>
<p><span class="math display">\[
\hat{x}_{MLE} = \underset{x}{\operatorname{argmax\ }}p(z|x)\tag{3}
\]</span></p>
<h3 id="map与mle的联系">MAP与MLE的联系</h3>
<p>在上文公式（2）中我们直接忽略了先验项<span class="math inline">\(p(x)\)</span>，并在最大后验概率和最大似然两者间用了约等号，那么这两者间是否有什么其他关系呢？</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MAP}
&amp;= \underset{x}{\operatorname{argmax\ }}p(x|z)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(x|z)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x)p(x)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x) + \ln p(x)\\
\end{split}
\]</span></p>
<p>如果当先验概率<span class="math inline">\(p(x)\)</span>是一个均分分布的时候，上式就会变成：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MAP}
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x) + \ln p(x)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x) + constant\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x)
\end{split}
\]</span></p>
<p><strong>也就是说MLP实际上是MAP中，将先验概率做均匀分布假设的特殊情况</strong> 上面这句话就是说，在没有任何其他条件下，我们认为<span class="math inline">\(x\)</span>取任何值的概率都一样。</p>
<p>当然，其实我们也可以直接认为SLAM后端的问题就是在给定观测的情况下，求取位姿的似然</p>
<h3 id="最大似然的负对数形式">最大似然的负对数形式</h3>
<p>公式（3）中，可以对优化目标取负对数（对数函数是单调函数，最大化单调递增函数等价于最小化递减函数），于是，我们有如下形式：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MLE}
&amp;= \underset{x}{\operatorname{argmax\ }}p(z|x)\\
&amp;= \underset{x}{\operatorname{argmin\ }} - \ln p(z|x)
\end{split}\tag{4}
\]</span></p>
<p>我们后文都会采用公式（4）这种形式</p>
<h2 id="从最大似然估计到非线性最小二乘问题">从最大似然估计到非线性最小二乘问题</h2>
<h3 id="高斯分布的最大似然估计形式">高斯分布的最大似然估计形式</h3>
<p>因为高斯分布有很多优美的性质，所以我们在SLAM中大量地假设各种变量符合高斯分布，这一小节先推导高斯分布的最大似然估计的形式，方便后面直接使用。 <strong>PS:这部分的标记没有用粗体表示，但是要记住这里的变量都是多维变量</strong></p>
<p>对于一个任意高维高斯分布：<span class="math inline">\(x \sim \mathcal{N}(\mu,\Sigma)\)</span>，概率密度函数为：</p>
<p><span class="math display">\[
p(x) = \frac{1}{\sqrt{(2\pi)^N det(\Sigma)}}\exp\big(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\big)
\]</span></p>
<p>对上述取负对数，可得：</p>
<p><span class="math display">\[
-\ln(p(x)) = \frac{1}{2}\ln\big((2\pi)^N\det(\Sigma)\big) + \frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\tag{5}
\]</span></p>
<p>由于上述第一项与<span class="math inline">\(x\)</span>无关，于是在求最小化的时候第一项可以忽略。上述第二项中，<span class="math inline">\(\Sigma^{-1}\)</span>叫做 <strong><em>信息矩阵</em></strong> ,为协方差的倒数</p>
<p><span class="math display">\[
信息矩阵 := \Sigma^{-1}
\]</span></p>
<h3 id="slam优化目标的最小二乘形式">SLAM优化目标的最小二乘形式</h3>
<p>令机器人当前时刻的姿态为<span class="math inline">\(x\)</span>,观测于姿态之间的关系使用函数<span class="math inline">\(h(x)\)</span>表达。则，对于观测<span class="math inline">\(z\)</span>，有如下观测模型：</p>
<p><span class="math display">\[
z = h(x) + v
\]</span></p>
<p>其中<span class="math inline">\(v\)</span>为噪声项，我们假设噪声项服从均为为0，方差为<span class="math inline">\(Q\)</span>的高斯分布，也就是</p>
<p><span class="math display">\[
v \sim \mathcal{N}(h(x), Q)
\]</span></p>
<p>于是，而可以得到，在状态<span class="math inline">\(x\)</span>即已知道的情况下，观测<span class="math inline">\(z\)</span>的条件概率（也就是似然）也是一个高斯分布</p>
<p><span class="math display">\[
z \sim \mathcal{N}(h(x), Q)
\]</span></p>
<p>为了求得<span class="math inline">\(x\)</span>，求最大似然，根据公式（5），并忽略第一项和第二项的<span class="math inline">\(\frac{1}{2}\)</span>系数，则：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MLE}
&amp;=\underset{x}{\operatorname{argmax\ }} p(z|x)\\
&amp;=\underset{x}{\operatorname{argmin\ }} -\ln p(z|x)\\
&amp;=\underset{x}{\operatorname{argmin\ }} (z-h(x))^T\Sigma^{-1}(z-h(x))
\end{split}\tag{6}
\]</span></p>
<p>可以看出，公式（6）是一个二次型，可以看成是信息矩阵<span class="math inline">\(\Sigma^{-1}\)</span>加权后的欧式距离（二范数）。其中的<span class="math inline">\(h(x)\)</span>我们可以称为观测模型，描述机器人位姿和观测之间的关系。我们可以定义观测与模型之间的误差如下：</p>
<p><span class="math display">\[
e_{z} = z - h(x)
\]</span></p>
<p>则，公式（6）可以写成</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MLE}
&amp;= \underset{x}{\operatorname{argmin\ }}\big(z-h(x)\big)^T\Sigma^{-1}\big(z-h(x)\big)\\
&amp;= \underset{x}{\operatorname{argmin\ }}||e_z||^2_{\Sigma^{-1}}
\end{split}\tag{7}
\]</span></p>
<p>公式（7）的<span class="math inline">\(\Sigma_{-1}\)</span>下标指使用信息矩阵进行加权</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/19/sensors/AllanVariance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/19/sensors/AllanVariance/" class="post-title-link" itemprop="url">惯性测量单元Allan方差分析详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-19 15:37:57" itemprop="dateCreated datePublished" datetime="2023-04-19T15:37:57+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-18 16:49:48" itemprop="dateModified" datetime="2023-05-18T16:49:48+08:00">2023-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/" itemprop="url" rel="index"><span itemprop="name">传感器标定</span></a>
        </span>
    </span>

  
    <span id="/2023/04/19/sensors/AllanVariance/" class="post-meta-item leancloud_visitors" data-flag-title="惯性测量单元Allan方差分析详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="惯性测量单元Allan方差分析详解" href="/2023/04/19/sensors/AllanVariance/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::aa4c05f956521692fdd7a55fc75da757" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>原本以为Allan方差应该是一个简单的方差计算方法，但是经过两天的各种探索和资料学习，发现这玩意的原理远比想象中的复杂。详细的公式推导需要设计到随机信号的频谱分析、IMU各种误差模型等内容。并且，Allan方差一开始用来分析原子钟晶体振荡频率的误差分析，后续这种分析方法被用到IMU的误差分析，并且IEEE也制订了相应标准（见<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">参考资料1</a>），这一系列的发展过程其实很长，同时也有不同的定义。以上种种，让读者放弃了摸清Allan方差的详细来龙去脉和公式推导，毕竟，工程师和数学家还是有区别的……但是关于Allan方差的解释和应用网上的博文也都不够全面，单看某一篇文章很难获取对Allan方差的直观理解（没有找到一篇很好的文章能够说明Allan方差的定义和双对数曲线不同斜率段对应的噪声项是怎么来的）。</p>
<p>本文对以下内容做了梳理：</p>
<ol type="1">
<li>IMU的噪声项及其含义</li>
<li>Allan方差的定义和推导</li>
<li>对陀螺仪的数据计算Allan方差的方法</li>
<li>Allan方差双对数曲线的含义和分析</li>
<li>关键概念解读</li>
</ol>
<p><code>PS: 笔者水平有限，本文只是笔者对Allan方差学习的总结，并不是一篇严格的理论推导文章</code></p>
<h2 id="惯性测量单元imuinertial-measuremnt-unit误差项">惯性测量单元（IMU：Inertial Measuremnt Unit）误差项</h2>
<p>这部分可以参考<a target="_blank" rel="noopener" href="https://hexagondownloads.blob.core.windows.net/public/Novatel/assets/Documents/Bulletins/APN064/APN064.pdf">参考资料2</a></p>
<img src="./imgs/01-imu-axis.png" title="fig:" alt="IMU模型" />
<center>
IMU模型
</center>
<p>IMU的输出可以看上图，典型的六轴IMU输出三个轴的加速度和三个轴的角速度。对加速度做积分可以得到速度、再做一次积分可以得到位移；对角速度积分可以得到角度。</p>
<p>电子器件输出都会有误差，又叫噪声。IMU的噪声项主要有以下几种：</p>
<img src="./imgs/02-imu-errors.png" alt="IMU误差示意图" /> <cneter>IMU误差示意图
</center>
<ol type="1">
<li>零偏（Bias），单位<code>deg/hr,m/s^2</code> 零偏这个词似乎不太准确，因为在非零输出时也会有偏差。如果把IMU的输出当作一个遵循高斯分布的随机信号，在静止时该随机信号的均值应该是零，但是由于bias，该均值并不是0。见上面的<code>IMU误差示意图</code>可以较好地理解。要注意的是零偏是会随着时间改变的，因此在很多卡尔曼滤波模型中会把Bias当作一个状态量。</li>
<li>零偏可重复性（Bias Repeatability），单位<code>deg/hr,m/s^2</code> 每次上电零偏的稳定程度。</li>
<li>零偏稳定性（Bias Stability），单位<code>deg/hr/hr,m/s^2/hr</code> 有时也叫零偏不稳定性（Bias Instability）。描述零偏的稳定程度，也可以理解为零偏的噪声。（有些文章也会叫做零偏的角度随机游走）。</li>
<li>比例因子（Scale Factor） 比如比例因子是1.2,那么当真值是10m/s<sup>2的时候，IMU的输出可能是12m/s</sup>2。</li>
<li>角度随机游走（ARW:Angle Random Walk），单位：<span class="math inline">\(deg/\sqrt{hr}\)</span>,<span class="math inline">\(m/s/\sqrt{hr}\)</span> 这是一个比较难理解的量，实际上笔者也没法完全理解。简单理解就是当信号叠加上一个白噪声之后，对该信号的积分就包含了白噪声的积分，白噪声的积分不再是一个白噪声，而是一个马尔科夫模型，也就是此时的噪声是上一时刻的噪声加上一个白噪声。那么放在这里，对于陀螺仪的输出（角速度）一般是用来做积分得到角度，那么角速度的白噪声的积分就会得到角度的偏差，因此叫做角度随机游走。有时候角度随机游走的值又叫做白噪声强度，比如在<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a>中就有这样的描述： &gt; White Noise Terms: The parameters for the "white noise" processes are often specified in the datasheet of the sensor manufacturer. A bit misleading, they are commonly denoted as angular random walk in case of the gyro, and velocity random walk for the accel</li>
<li>速率随机游走（RRW:Rate Random Walk） 与角度随机游走类似，速率随机游走可以看作是角加速度的误差积分导致的角速度的误差。速率随机游走对应的是陀螺仪在长时间下才会发生改变的误差项，因此可以用来近似当作<code>Bias</code>使用。在<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a>中使用速率随机游走系数当作零偏参数。</li>
</ol>
<h3 id="角度随机游走arwangle-random-walkv.s.-角速率随机游走arrw">角度随机游走（ARW:Angle Random Walk）v.s. 角速率随机游走（ARRW）</h3>
<p>这个很容易弄混淆的一个概念。对应到加速度计上应该叫速度随机游走和加速度随机游走。因为讲解Allan方差的时候一般会以陀螺仪为示例，因此在文中可能只出现角度随机游走和角速率随机游走。角速率随机游走又会被简写成速率随机游走，比如参考资料1的IEEE标准。下面这段百度百科的描述反而清晰： &gt; 角速率传感器的性能参数中包含角度随机游走（ARW）和角速率随机游走（ARRW），前者反映了角速率信号中白噪声的特性，积分后表现为角度随机游走；后者为角速率本身的随机游走，可认为是角加速度白噪声的积分结果。</p>
<h2 id="allan方差">Allan方差</h2>
<p>Allan方差又叫阿伦方差，可以用Allan方差用来描述物理器件的不同噪声参数。Allan方差相比于普通的方差具有更好的描述长时间误差的优势（具体也不太清楚）。Allan方差现在好像基本被用来当作IMU噪声标定的标准方法了。</p>
<h3 id="数据方差">数据方差</h3>
<figure>
<img src="./imgs/03-variance.png" alt="" /><figcaption>数据方差及标准差计算方法</figcaption>
</figure>
<p>（上图引用自<a target="_blank" rel="noopener" href="http://www.i2nav.com/index/newListDetail_zw?newskind_id=13a8654e060c40c69e5f3d4c13069078&amp;newsinfo_id=c2bb31af75944e5ab665dc23b60b5fba">新手入门系列3——Allan方差分析方法的直观理解</a>）</p>
<p>系数<span class="math inline">\(\frac{1}{N-1}\)</span>使得这样计算出来的方差是数据方差的无偏估计（概率统计原理）。</p>
<h3 id="对不同时间尺度上的误差刻画">对不同时间尺度上的误差刻画</h3>
<p>上面的数据方差计算方法对数据的整个序列计算误差水平，无法细分出不同时间尺度上的误差波动情况。为了能够刻画不同时间周期下数据的波动情况，我们可以先对数据分块，对每块数据取平均作为该块数据的代表。假设原始数据的采样时间是<span class="math inline">\(\tau_0\)</span>，每3个数据分成一块，则每块的间隔时间<span class="math inline">\(\tau = 3\tau_0\)</span>。分块之后，我们再将<span class="math inline">\(M\)</span>个数据块计算方差，最后求这个方差的数学期望，作为我们最后的方差</p>
<figure>
<img src="./imgs/04-general-covariance.png" alt="" /><figcaption>通用样本方差计算方法</figcaption>
</figure>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2_{g}(M,\tau)
&amp;=&amp;
&lt;\sigma^2(M,\tau)&gt;\\
&amp;=&amp;
&lt;\frac{1}{M-1}\sum^M_{i=1}\big(\bar{y}_i-\frac{1}{M}\sum^M_{j=1}\bar{y}_j\big)^2&gt;\\
\end{array}
\end{split}\tag{1}
\]</span></p>
<p>上式中<span class="math inline">\(&lt;\cdot&gt;\)</span>表示求统计平均（期望）</p>
<h3 id="allan方差定义">Allan方差定义</h3>
<p>Allan方差是上述通用样本方差分析在<span class="math inline">\(M=2\)</span>时的一个特例，也就是在公式（1）中令<span class="math inline">\(M=2\)</span></p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2(\tau)
&amp;=&amp;
&lt;\sigma^2(2,\tau)&gt;\\
&amp;=&amp;
&lt;\sum^2_{i=1}\big(\bar{y}_i-\frac{1}{2}\sum^2_{j=1}\bar{y}_j\big)^2&gt;\\
&amp;=&amp;
&lt;\frac{1}{2}(\bar{y}_2-\bar{y}_1)^2&gt;\\
&amp;=&amp;
\frac{1}{2}&lt;(\bar{y}_2-\bar{y}_1)^2&gt;
\end{array}
\end{split}\tag{2}
\]</span></p>
<p>注意，Allan方差是<span class="math inline">\(\tau\)</span>的函数</p>
<figure>
<img src="./imgs/05-allan-covariance.png" alt="" /><figcaption>Allan方差定义</figcaption>
</figure>
<h3 id="角速度的allan方差计算">角速度的Allan方差计算</h3>
<p>这里只推导一种方式，根据<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">IEEE Standard</a></p>
<p>令陀螺仪的角度输出为<span class="math inline">\(\Omega(t^\prime)\)</span>，则角度为</p>
<p><span class="math display">\[
\theta(t)=\int^t\Omega(t^\prime)dt^\prime
\]</span></p>
<p>对于离散时间形式，时间点<span class="math inline">\(t=k\tau_0,k=1,2,3,...,N\)</span>。其中<span class="math inline">\(\tau_0\)</span>是陀螺仪的输出时间间隔，<span class="math inline">\(N\)</span>为总体样本数量。则，在时间段<span class="math inline">\(t_k\)</span>到<span class="math inline">\(t_k+\tau\)</span>之间，角速度的平均值是：</p>
<p><span class="math display">\[
\bar{\Omega}_k(\tau)=\frac{\theta_{k+m}-\theta_k}{\tau}\tag{3}
\]</span></p>
<p>其中<span class="math inline">\(\tau=m\tau_0\)</span></p>
<p>将公式（3）带入上文Allan方差的定义公式（2）中可以得到：</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2(\tau)
&amp;=&amp;
\frac{1}{2}&lt;(\bar{\Omega }_{k+m}-\bar{\Omega }_k)^2&gt;\\
&amp;=&amp;
\frac{1}{2\tau^2}&lt;(\theta_{k+2m}-2\theta_{k+m}+\theta_k)^2&gt;
\end{array}
\end{split}\tag{4}
\]</span></p>
<p>将公式（4）的期望代替为在整个数据样本（数量为N）上求平均，可以得到如下形式</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2(\tau)
&amp;=&amp;
\frac{1}{2\tau^2(N-2m)}\sum^{N-2m}_{k=1}(\theta_{k+2m}-2\theta_{k+m}+\theta_k)^2
\end{array}
\end{split}\tag{5}
\]</span></p>
<h3 id="重叠分段法计算allan方差">重叠分段法计算Allan方差</h3>
<p>这部分主要参考：<a target="_blank" rel="noopener" href="https://telesens.co/wp-content/uploads/2017/05/AllanVariance5087-1.pdf">Allan Variance: Noise Analysis for Gyroscopes</a> 在公式（5）中，对每<span class="math inline">\(m\)</span>个原始数据作为一段。切割方式有很多种，在图<code>Allan方差定义</code>中，每段数据都不重叠。另一种分割方法是让每段数据都重叠，如下图所示</p>
<figure>
<img src="./imgs/06-overlapping-sample.png" alt="" /><figcaption>重叠采样计算Allan方差</figcaption>
</figure>
<p>上图中<span class="math inline">\(m=3\)</span>，也就是每4个原始数据作为一组，组与组之前相差<span class="math inline">\(\tau_0\)</span>长度。</p>
<p>Allan方差的计算方式与公式（5）保持一致。</p>
<h2 id="allan方差双对数曲线">Allan方差双对数曲线</h2>
<p>根据公式（5），Allan方差是时间周期<span class="math inline">\(\tau=m\tau_0\)</span>的函数，我们根据不同的<span class="math inline">\(\tau\)</span>，计算出对应的Allan方差，并将<span class="math inline">\(log_{10}(\tau)\)</span>作为x，<span class="math inline">\(log_{10}(\sigma(\tau))\)</span>作为y，画出曲线，如下图：</p>
<figure>
<img src="./imgs/07-allan-log-curve.png" alt="" /><figcaption>Allan方差双对数曲线</figcaption>
</figure>
<p>注意，y轴是Allan方差的开根，又叫Allan</p>
<p>Allan方差双对数曲线可以用不同斜率的直线拟合，不同斜率部分的直线代表不同的含义。</p>
<p>这里讲述一下如何从双对数曲线分析信号的不同误差成分（以陀螺仪为例）</p>
<h3 id="角度随机游走白噪声强度">角度随机游走/白噪声强度</h3>
<p>角度随机游走对应到双对数曲线中斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的直线，取值可以直接读取<span class="math inline">\(\tau=1\)</span>处的值。</p>
<h3 id="零偏不稳定性">零偏不稳定性</h3>
<p>零偏不稳定性对应双对数曲线中斜率为0的直线，也就是双对数曲线中最小值位置。</p>
<h3 id="速率随机游走">速率随机游走</h3>
<p>速率随机游走对应双对数曲线中斜率为<span class="math inline">\(\frac{1}{2}\)</span>的直线，取值时取该直线与<span class="math inline">\(\tau=3\)</span>的交点。</p>
<p>上面三个误差项是我们用得比较多的误差项，画成图如下：</p>
<figure>
<img src="./imgs/08-display-of-errors-in-curve.png" alt="" /><figcaption>三种误差项在双对数曲线中的示意图</figcaption>
</figure>
<h3 id="为什么不同的斜率对应不同的误差项">为什么不同的斜率对应不同的误差项？？</h3>
<p>说实话，笔者对这个部分也是一知半解，说实话，也没有必要完全弄明白，里面涉及到时域信号分析太多基础知识了。这里根据<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">IEEE Standard</a>里一些内容根据自己的理解简单讲述一下。 噪声的双边功率谱密度(PSD:Power Sepctral Density)与Allan方差有如下关系：</p>
<figure>
<img src="./imgs/09-psd-2-allan.png" alt="" /><figcaption>功率谱密度与Allan方差的关系</figcaption>
</figure>
<p>上式中可以看作Allan方差是噪声能量经过一个<span class="math inline">\(sin^4(x)/(x)^2\)</span>为转移函数的滤波器，这个函数是由Allan方差计算决定的。这个滤波器的带宽跟<span class="math inline">\(\tau\)</span>有关，因此，不同的<span class="math inline">\(\tau\)</span>对应的Allan方差来分析噪声的不同频段特性。</p>
<p>以白噪声为例，其功率谱密度为</p>
<figure>
<img src="./imgs/10-white-noise-psd.png" alt="" /><figcaption>白噪声PSD</figcaption>
</figure>
<p>将其带入<code>功率谱密度与Allan方差关系</code>的公式中，并进行公式中的积分，可以得到如下结果:</p>
<figure>
<img src="./imgs/11-white-noise-psd-integrated.png" alt="" /><figcaption>白噪声PSD转换成Allan方差</figcaption>
</figure>
<p>对上式 <span class="math inline">\(\sigma^2\big(\tau\big)=\frac{N^2}{\tau}\)</span> 开根后求对数后可以得到</p>
<p><span class="math display">\[
log(\sigma(\tau)) = N - \frac{1}{2}log(\tau)
\]</span></p>
<p>刚好可以得到一条斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的直线，且当<span class="math inline">\(\tau=1\)</span>的时候可以得到<span class="math inline">\(N\)</span>。这也对应了上文中从Allan方差双对数曲线中求角度随机游走的方式。</p>
<h2 id="应用重点">应用重点</h2>
<h3 id="不同的imu建模方式需要不同的系数">不同的IMU建模方式需要不同的系数</h3>
<p>强调这一点是因为<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a>工具标定的输出结果和<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr">kalibr</a>的模型要求是不一样的。</p>
<p><strong>在GTSAM中</strong></p>
<p>在GTSAM中使用IMUFactor时需要IMU的几个参数：</p>
<ol type="1">
<li>IMU零偏Bias的初始值。但是这个参数可以先设置为0,后续逐步更新。（Bias是IMUFactor中的一个变量，会随时间改变）。</li>
<li>IMU加速度（3轴）和陀螺仪（3轴）的噪声参数。</li>
<li>IMU加速度（3轴）和陀螺仪（3轴）的Bias噪声参数。</li>
</ol>
<p>上面2、3两点的参数可以使用<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a>的标定结果。</p>
<p>其中第2点对应的是Allan方差双对数曲线（后文详细讲解）中斜率为<code>-1/2</code>的直线与 <span class="math inline">\(\tau =1s\)</span>的交点（IEEE标准）。（可以直接取双对数曲线 <span class="math inline">\(\tau = 1s\)</span>处的值，因为"据说"惯性单元在1Hz的时候对应的噪声强度主要由白噪声强度左右。这段话出自<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a>，<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a>也是直接取这一点的值） &gt;This is only true since the noise power in most inertial sensors is dominated by "white noise" at a frequency of approximately 1Hz.</p>
<p>第3点描述的是Bias的不稳定性，有些地方也叫Bias随机游走。这个参数对应的是<code>Bias [In]Stability</code>。Bias Stability可以直接从Allan方差双对数曲线中读出来（后文详解）</p>
<p>之所以GTSAM需要这些参数是因为GTSAM中对IMU的建模方法跟大部分算法相同，都是把IMU的Bias当作状态，认为Bias会随着时间变化而缓慢改变（这也是较为正确的做法）。因此需要标定出Bias的稳定性。</p>
<p><strong>在[kalibr]中</strong> 在[kalibr]中对IMU的建模是使用下面的公式：</p>
<p><span class="math display">\[\tilde{w}(t) = w(t)+b(t)+n(t)\]</span></p>
<p>其中<span class="math inline">\(w(t)\)</span>代表真值，<span class="math inline">\(b(t)\)</span>是Bias，<span class="math inline">\(n(t)\)</span>是噪声。因此在[kalibr]中使用角度随机游走系数作为<span class="math inline">\(n(t)\)</span>。同时使用角速率随机游走作为<span class="math inline">\(b(t)\)</span>。一开始对这点很迷惑，为什么角速率随机游走可以用来作为<span class="math inline">\(b(t)\)</span>。后面我在一个issue的回答中得到答案：<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/issues/63">issues63</a>。[kalibr]对IMU的建模形式实际上是不够准确的，因为这里将<span class="math inline">\(b(t)\)</span>当作一个恒定的量求解，实际上这是一个随着时间缓慢变化的量。而角速率随机游走则可以部分用力刻画这一偏差。<code>事实上还是很难理解</code></p>
<h3 id="单位">单位</h3>
<blockquote>
<p>First, it is important to realize that Hertz (Hz) is defined as the inverse of seconds, which means that a noise density specification of X°/s/√Hz is exactly equivalent to an angle random walk specification of X°/√s with no conversion necessary. 出自：https://www.vectornav.com/resources/inertial-navigation-primer/specifications--and--error-budgets/specs-imuspecs</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<p>【1】<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">IEEE Standard Specification Format Guide and Test Procedure for Single-Axis Laser Gyros, AnnexC, IEEE Std 647-1995, 1995</a></p>
<p>【2】<a target="_blank" rel="noopener" href="https://hexagondownloads.blob.core.windows.net/public/Novatel/assets/Documents/Bulletins/APN064/APN064.pdf">IMU Errors and Their Effects</a></p>
<p>【3】<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a></p>
<p>【4】<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a></p>
<p>【5】<a target="_blank" rel="noopener" href="http://www.i2nav.com/index/newListDetail_zw?newskind_id=13a8654e060c40c69e5f3d4c13069078&amp;newsinfo_id=c2bb31af75944e5ab665dc23b60b5fba">新手入门系列3——Allan方差分析方法的直观理解</a></p>
<p>【6】<a target="_blank" rel="noopener" href="https://telesens.co/wp-content/uploads/2017/05/AllanVariance5087-1.pdf">Allan Variance: Noise Analysis for Gyroscopes</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/lio_sam/mapOptimization-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（十）后端优化模块详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 22:00:19" itemprop="dateCreated datePublished" datetime="2023-04-11T22:00:19+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 22:08:03" itemprop="dateModified" datetime="2023-04-20T22:08:03+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/04/11/lio_sam/mapOptimization-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（十）后端优化模块详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（十）后端优化模块详解" href="/2023/04/11/lio_sam/mapOptimization-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::fddca820098456617fc64b80ba797a81" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="后端优化">后端优化</h2>
<figure>
<img src="./imgs/Design-Pipelines-mapOpt.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p>这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>四大部分（点云去畸变、特征提取、预积分、后端优化）中最复杂的一个模块了，完全弄懂这个模块也就离完全理解<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>不远了。 这个模块负责SLAM框架中的后端优化，由于<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中使用图优化作为后端优化算法，所以有时候笔者也会称这个模块为图优化模块。但是这个模块的 作用不单单是负责后端优化，还有1）、全局地图可视化；2）、回环检测等功能。</p>
<p>这个模块一共有三个主要线程执行具体功能，三个线程分别如下：</p>
<ol type="1">
<li>雷达里程计及后端优化线程</li>
</ol>
<p>这个线程主要负责执行雷达到地图的匹配，得到较为准确的雷达里程计，然后将雷达里程计、回环检测因子加入因子图进行优化，得到全局优化的关键帧位姿。</p>
<ol start="2" type="1">
<li>回环检测线程</li>
</ol>
<p>回环检测使用较为费时的ICP算法，因此作为一个单独的线程运行。当检测到合适的回环因子后，会加入全局缓存队列，在雷达里程计线程中被加入因子图优化。</p>
<ol start="3" type="1">
<li>全局地图可视化线程</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中对于地图的存储格式是通过一系列关键帧的点云和位姿存储，而不是通过一整个点云存储。为了能够以较低的频率发布全局地图，后端优化模块单独有一个线程 对历史关键帧的点云根据最新的位姿转换到地图坐标系，然后将融合后的全局点云地图发布出去。</p>
<p>废话不多说，下面分别介绍这三个线程的主要流程和方法</p>
<h2 id="雷达里程计及后端优化线程">雷达里程计及后端优化线程</h2>
<p>这个线程的流程主要如下图所示</p>
<figure>
<img src="./imgs/Design-mapOptimization-top.png" alt="" /><figcaption>雷达里程计及后端优化线程流程图</figcaption>
</figure>
<p>这个线程是点云的回调函数，点云来自<code>FeatureExtraction</code>模块输出的经过特征提取后的点云。整个函数执行过程代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特征点云回调函数，也是整个模块核心的计算函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 提取当前点云时间戳</span></span><br><span class="line">    timeLaserInfoStamp = msgIn-&gt;header.stamp;</span><br><span class="line">    timeLaserInfoCur = <span class="built_in">stamp2Sec</span>(msgIn-&gt;header.stamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取当前点云的特征角点和特征平面点</span></span><br><span class="line">    cloudInfo = *msgIn;</span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_corner,  *laserCloudCornerCur);</span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_surface, *laserCloudSurfCur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 一共三个线程使用到这把锁</span></span><br><span class="line"><span class="comment">        * 1. 雷达里程计线程，也就是当前线程</span></span><br><span class="line"><span class="comment">        * 2. 发布全局地图线程，执行关键帧点云拷贝转换操作</span></span><br><span class="line"><span class="comment">        * 3. 回环检测线程，执行关键帧姿态拷贝操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一帧的时间戳，两帧之间时间间隔大于mappingProcessInterval才会进行处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> timeLastProcessing = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)</span><br><span class="line">    &#123;</span><br><span class="line">        timeLastProcessing = timeLaserInfoCur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前帧位姿初始化</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;updateInitialGuess&quot;</span>);</span><br><span class="line">        <span class="built_in">updateInitialGuess</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建局部地图</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;extractSurroundingKeyFrames&quot;</span>);</span><br><span class="line">        <span class="built_in">extractSurroundingKeyFrames</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对当前帧点云做降采样</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;downsampleCurrentScan&quot;</span>);</span><br><span class="line">        <span class="built_in">downsampleCurrentScan</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前帧点云匹配到构建的局部地图，优化当前位姿</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;scan2MapOptimization&quot;</span>);</span><br><span class="line">        <span class="built_in">scan2MapOptimization</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算是否将当前帧采纳为关键帧，加入因子图优化</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;saveKeyFramesAndFactor&quot;</span>);</span><br><span class="line">        <span class="built_in">saveKeyFramesAndFactor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当新的回环因子或者GPS因子加入因子图时，对历史帧执行位姿更新</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;correctPoses&quot;</span>);</span><br><span class="line">        <span class="built_in">correctPoses</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布激光历程计</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;publishOdometry&quot;</span>);</span><br><span class="line">        <span class="built_in">publishOdometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布当前帧对齐到地图坐标系的点云和完整轨迹</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;publishFrames&quot;</span>);</span><br><span class="line">        <span class="built_in">publishFrames</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="雷达里程计的最高频率">雷达里程计的最高频率</h3>
<p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)</span><br></pre></td></tr></table></figure>
<p><code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1/0.15Hz</p>
<h3 id="点云匹配的初始值">点云匹配的初始值</h3>
<p>基本所有的精细点云匹配都需要一个较好的初值。<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中的点云匹配使用高斯牛顿算法优化当前帧点云到局部地图的距离（具体算法见本项目博客的相关文章），基于最小二乘法的点云匹配更需要一个优良的初值。 回顾一下我们在<code>ImageProjection</code>也就是点云去畸变模块的内容，在点云去畸变模块，除了对点云做运动畸变校正之外，还从IMU原始输出的角度和预积分模块的输出找到与当前帧点云时间最相近的数据，加入发布的消息中跟随点云一起发布。</p>
<p>在后端优化模块中，会优先判断接收的消息中是否有设置好的预积分数据，若有，则使用该数据作为该帧点云的初始值，否则，使用IMU的角度增量作为初始值。当然，特殊情况是第一帧的时候会使用IMU输出的角度作为初始值。</p>
<figure>
<img src="./imgs/Design-mapOptimization-initialGuess.png" alt="" /><figcaption>点云匹配初始值选取</figcaption>
</figure>
<p>这里比较特殊的是，初始值是通过计算当前帧的位姿和上一帧的缓存位姿计算位姿增量，然后将该增量应用到上一帧优化后的里程计结果。</p>
<p><span class="math display">\[
T_{incre} = \hat{T}_{pre}^{-1}\hat{T}_{cur}\\
\bar{T}_{cur} = T^{opt}_{pre}T_{incre}
\]</span></p>
<p>以使用预积分数据作为初始值为例，上面公式中的<span class="math inline">\(\hat{T}_{pre},\hat{T}_{cur}\)</span>分别是上一次缓存和当前的消息中包含的预积分位姿；<span class="math inline">\(T_{incre}\)</span>计算除了从上一帧到当前帧的位姿增量；<span class="math inline">\(T^{opt}_{pre}\)</span>是上一帧经过点云匹配、图优化之后的里程计结果；<span class="math inline">\(\bar{T}_{cur}\)</span>则是最终采用的当前帧点云的估计值。</p>
<h3 id="构建局部点云地图">构建局部点云地图</h3>
<figure>
<img src="./imgs/Design-mapOptimization-localMap.png" alt="" /><figcaption>构建局部点云地图</figcaption>
</figure>
<p>局部点云地图简单说就是根据最后一帧关键帧，找到其空间、时间附近的一些其他关键帧，将这些关键帧的点云都使用对应的位姿转换到地图坐标系下，融合成地图坐标系下的局部地图，后面这个局部地图就是点云匹配的目标点云。这个函数主要是一些几何计算。</p>
<h3 id="点云匹配">点云匹配</h3>
<p>这部分用的算法比较复杂，具体参考本项目的另一篇文章<a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——点云匹配算法详解</a>。 只要明白，经过这个步骤后，在第一步设置的点云位姿初始值已经被点云匹配算法更新为更准确的位姿。</p>
<figure>
<img src="./imgs/Design-mapOptimization-scan2Map.png" alt="" /><figcaption>点云匹配</figcaption>
</figure>
<h3 id="因子图构建及优化">因子图构建及优化</h3>
<p>这个步骤稍微比较复杂，我们先理一下目前手头有什么：</p>
<ol type="1">
<li>经过点云匹配校正后的当前帧的位姿</li>
<li>回环检测得到的某一帧关键帧到另一帧关键帧的相对位姿（这个部分在回环检测线程进行，这里只需要当作现有数据即可）</li>
<li>gps里程计（由于这部分需要额外的计算，暂且忽略gps的输入）</li>
</ol>
<p>PS:这部分需要<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的知识，可以参考本项目的另外一篇文章：<a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——GTSAM快速入门</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>使用上面两个位姿关系构建因子图，并使用因子图优化算法进行整体的优化，得到全局优化下的关键帧位姿</p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt01.png" alt="" /><figcaption>因子图构建流程图</figcaption>
</figure>
<p><strong>关键帧的选择</strong></p>
<p>并不是所有的雷达帧都会被当作关键帧，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>使用一种比较简单的方案判断是否将当前帧采纳为关键帧：只有与上一帧关键帧的位姿相差足够大才会采纳为关键帧。</p>
<p><strong>添加激光里程计因子</strong></p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt-odomFactor.png" alt="" /><figcaption>激光里程计因子</figcaption>
</figure>
<p><strong>回环因子</strong></p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt-loopFactor.png" alt="" /><figcaption>添加回环因子</figcaption>
</figure>
<p><strong>设置因子图初值并优化</strong></p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt-optimization.png" alt="" /><figcaption>因子图优化</figcaption>
</figure>
<h3 id="更新历史关键帧位姿">更新历史关键帧位姿</h3>
<p>当有新的回环被检测到，该回环关系被加入因子图进行优化。由于回环关系是一种很强约束性的观测，因此，在观测到新的回环之后，因子图优化对历史关键帧的位姿变化会比较大，因此需要对历史关键帧的位姿一起做一次更新。</p>
<figure>
<img src="./imgs/Design-mapOptimization-updatePath.png" alt="" /><figcaption>更新历史位姿</figcaption>
</figure>
<h3 id="发布里程计及可视化点云">发布里程计及可视化点云</h3>
<p>在原始的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>代码中这部分还有较多处理，但实际上并没有太多作用。在本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">spl</a>中，已经去除了冗余部分。这部分就只是将计算出来的激光里程计往外发布。</p>
<h2 id="回环检测线程">回环检测线程</h2>
<p>回环检测是SLAM中很重要的一个环节。通过检查当前位置是否已经是到达过的位置，并对重复到达的位置匹配计算位姿。如下图中，<span class="math inline">\(x_5\)</span>与<span class="math inline">\(x_2\)</span>够成回环，<span class="math inline">\(f_5(x_5,x_2)\)</span>是两个位置间的相对位置关系。通过回环之间的约束，对因子图优化器提供很强的信息，使得整体的位姿估计达到全局最优的状态。</p>
<figure>
<img src="./imgs/loopClosure.png" alt="" /><figcaption>回环因子</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中回环检测使用ICP算法，计算最新的关键帧与可能形成回环的位置的点云匹配，并只有在匹配分数非常好的情况下才采纳这个回环结果。由于这部分是比较耗费计算时间的，并且，回环关系只需要以比较低的状态加入因子图即可，因此，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的<code>mapOptimization.cpp</code>中是使用一个独立线程执行回环检测：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> MO = std::<span class="built_in">make_shared</span>&lt;mapOptimization&gt;(options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回环检测独立线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">loopthread</span><span class="params">(&amp;mapOptimization::loopClosureThread, MO)</span></span>;</span><br></pre></td></tr></table></figure>
<p>同时，这个线程内部也默认被设为较低的执行频率（默认1Hz）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 回环检测独立线程</span></span><br><span class="line"><span class="comment">  * 1. 由于回环检测中用到了点云匹配，较为耗时，所以独立为单独的线程运行</span></span><br><span class="line"><span class="comment">  * 2. 新的回环关系被检测出来时被主线程加入因子图中优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loopClosureThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loopClosureEnableFlag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 1</span></span><br><span class="line">    <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(loopClosureFrequency)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        <span class="built_in">performLoopClosure</span>();</span><br><span class="line">        <span class="built_in">visualizeLoopClosure</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回环检测线程的整体流程如下：</p>
<figure>
<img src="./imgs/Design-mapOptimization-loopThread.png" alt="" /><figcaption>回环检测线程流程图</figcaption>
</figure>
<h3 id="寻找回环对应的帧">寻找回环对应的帧</h3>
<p>当开始寻找新的回环关系时，会根据最后一帧关键帧找到是否有合适的对应帧作为回环帧。主要通过两个约束：</p>
<ol type="1">
<li>空间位置最近（使用kdtree做距离检索）</li>
<li>时间距离够远（去除时间过近的帧）</li>
</ol>
<p>这个部分主要是函数<code>detectLoopClosureDistance</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 根据位置关系寻找当前帧与对应帧的索引</span></span><br><span class="line"><span class="comment">  * 1. 将最后一帧关键帧作为当前帧，如果当前帧已经在回环对应关系中，则返回（已经处理过这一帧了）。如果找到的回环对应帧相差时间过短也返回false。回环关系用一个全局map缓存</span></span><br><span class="line"><span class="comment">  * 2. 对关键帧3D位姿构建kd树，并用当前帧位置从kd树寻找距离最近的几帧，挑选时间间隔最远的那一帧作为匹配帧</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @param latestID 传出参数，找到的当前帧索引，实际就是用最后一帧关键帧</span></span><br><span class="line"><span class="comment">  * @param closestID 传出参数，找到的当前帧对应的匹配帧</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">detectLoopClosureDistance</span><span class="params">(<span class="type">int</span> *latestID, <span class="type">int</span> *closestID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> loopKeyCur = copy_cloudKeyPoses3D-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> loopKeyPre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认最后一帧关键帧没有被加入过回环关系中</span></span><br><span class="line">    <span class="keyword">auto</span> it = loopIndexContainer.<span class="built_in">find</span>(loopKeyCur);</span><br><span class="line">    <span class="keyword">if</span> (it != loopIndexContainer.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将关键帧的3D位置构建kdtree，并检索空间位置相近的关键帧</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pointSearchIndLoop;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pointSearchSqDisLoop;</span><br><span class="line">    kdtreeHistoryKeyPoses-&gt;<span class="built_in">setInputCloud</span>(copy_cloudKeyPoses3D);</span><br><span class="line">    <span class="comment">// 寻找空间距离相近的关键帧</span></span><br><span class="line">    kdtreeHistoryKeyPoses-&gt;<span class="built_in">radiusSearch</span>(copy_cloudKeyPoses3D-&gt;<span class="built_in">back</span>(), historyKeyframeSearchRadius, pointSearchIndLoop, pointSearchSqDisLoop, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保空间距离相近的帧是较久前采集的，排除是前面几个关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)pointSearchIndLoop.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = pointSearchIndLoop[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(copy_cloudKeyPoses6D-&gt;points[id].time - timeLaserInfoCur) &gt; historyKeyframeSearchTimeDiff)</span><br><span class="line">        &#123;</span><br><span class="line">            loopKeyPre = id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到位置关系、时间关系都符合要求的关键帧，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (loopKeyPre == <span class="number">-1</span> || loopKeyCur == loopKeyPre)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *latestID = loopKeyCur;</span><br><span class="line">    *closestID = loopKeyPre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="构建局部地图">构建局部地图</h3>
<p>找到匹配的关键帧id后，会在该关键帧的周围抽取其他关键帧构建局部点云地图。这个步骤跟雷达里程计线程中的局部地图构建是类似的，这里就不再赘述。</p>
<h3 id="点云匹配-1">点云匹配</h3>
<p>这里使用ICP直接对<code>curKeyframeCloud</code>(最后一帧关键帧)和<code>preKeyframeCloud</code>(回环对应帧周围构建的点云地图)做点云匹配，并得出当前帧到回环帧的转换矩阵<span class="math inline">\(T_{cur}^{pre}\)</span></p>
<h3 id="添加回环关系到队列">添加回环关系到队列</h3>
<p>由于回环关系检测跟因子图优化是两个线程，为了避免复杂的线程同步关系，在回环线程中用几个队列将回环关系缓存，在雷达里程计线程中从这几个队列提取相应的回环关系加入因子图。这里主要缓存几个内容：1）、回环索引；2）、回环关系的位姿转换矩阵（也就是ICP的结果）；3）、噪声因子（根据匹配的分数计算的噪声）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9. 将回环索引、回环间相对位姿、回环噪声模型加入全局变量</span></span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">loopIndexQueue.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(loopKeyCur, loopKeyPre));</span><br><span class="line">loopPoseQueue.<span class="built_in">push_back</span>(poseFrom.<span class="built_in">between</span>(poseTo));</span><br><span class="line">loopNoiseQueue.<span class="built_in">push_back</span>(constraintNoise);</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<h2 id="全局地图可视化线程">全局地图可视化线程</h2>
<p>这个线程主要是将所有历史关键帧，使用关键帧的位姿，全部转换到地图坐标系下，构建一个全局地图，并发布。这个线程完全是为了可视化，同时，处理所有的关键帧也需要很大计算量，因此，这个线程也被默认限制在5Hz的频率下执行。主要操作就是点云坐标系转换，这里就不赘述了。函数是<code>publishGlobalMap</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发布全局地图点云，在全局地图可视化线程中调用</span></span><br><span class="line"><span class="comment">  * 1. 对所有关键帧3D位姿构建KD树</span></span><br><span class="line"><span class="comment">  * 2. 以最后一帧关键帧为索引找出一定半径范围内的所有关键帧</span></span><br><span class="line"><span class="comment">  * 3. 对找出的关键帧数量做降采样</span></span><br><span class="line"><span class="comment">  * 4. 对所有关键帧的点云做拼接（投影到地图坐标系）</span></span><br><span class="line"><span class="comment">  * 5. 对地图点云做降采样</span></span><br><span class="line"><span class="comment">  * 6. 发布全局地图点云</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publishGlobalMap</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/06/lio_sam/pcdRegistration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（九）点云匹配算法详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-06 23:17:19" itemprop="dateCreated datePublished" datetime="2023-04-06T23:17:19+08:00">2023-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 22:01:43" itemprop="dateModified" datetime="2023-04-20T22:01:43+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/04/06/lio_sam/pcdRegistration-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（九）点云匹配算法详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（九）点云匹配算法详解" href="/2023/04/06/lio_sam/pcdRegistration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6bd455643b6442d6e43dd9a0a5cd9a7a" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中激光历程计的点云匹配方法沿用自<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>，这个基于点到线和点到面距离求解最小二乘问题的方法起始被用到很多框架，包括<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">Lego-LOAM</a>,各种LOAM的变种，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>及其变种。这段点云匹配代码可以说被重用了很多次，但是各个论文对这部分的描述实际上很少或者基本省略，<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>原始论文对这部分的描述与实际的代码实现差别比较大，导致如果想真正看懂这段代码还是挺难的。这篇文章详细地剖析这部分的原理、实现、以及与论文中不同之处。这里面唯一有一点还没有搞清楚的是对于 <a href="#Degenerate">高斯矩阵退化</a>部分的实现。</p>
<p>由于本文主要是想讲明白在上述这些SLAM框架中点云匹配的实现，因此对于最小二乘问题的求解不会详细展开，需要这部分知识可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113946848">最小二乘问题求解的四种解法</a>或者《视觉SLAM十四讲》中关于最小二乘问题求解的章节。</p>
<h2 id="点云-局部地图匹配流程scan-2-map">点云-局部地图匹配流程Scan-2-Map</h2>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，对于每一帧点云<span class="math inline">\(\mathbb{F}_i\)</span>会先进行特征点提取。特征点包括线特征点和平面特征点（具体方法参考本博客文章：<a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a>)。我们记提取后的线特征点云为<span class="math inline">\(F^e_i\)</span>，平面特征点云为<span class="math inline">\(F^p_i\)</span>。</p>
<p>经过一段时间后<span class="math inline">\(1,2,3,...,i-1\)</span>后，我们拥有一系列关键帧的线特征点云<span class="math inline">\(F^e_1,F^e_2,F^e_3,...,F^e_{i-1}\)</span>和平面特征点云<span class="math inline">\(F^p_1,F^p_2,F^p_3,...,F^p_{i-1}\)</span>，以及这些关键帧对应的位姿<span class="math inline">\(T_1,T_2,T_3,...,T_{i-1}\)</span>. 同时对于点云<span class="math inline">\(\mathbb{F}_i\)</span>，我们通过IMU里程计还可以获得该帧点云的初始位姿估计<span class="math inline">\(\hat{T}_i\)</span>，这个位姿估计<span class="math inline">\(\hat{T}_i\)</span>其实就是我们要优化的量。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，激光里程计匹配的是当前帧点云和局部地图。局部地图是通过当前帧空间以及时间近邻的其他关键帧构建的。 <img src="./imgs/Design-mapOptimization-scan2MapOpt.png" alt="scan2MapOptimization" /></p>
<p>对于任何一帧点云以及对应的位姿，我们可以将点云转换到地图坐标系： <span class="math display">\[\mathbb{F}^m_i = R_i\mathbb{F}_i+t_i\]</span> 其中<span class="math inline">\(m\)</span>上标指的是地图坐标系，<span class="math inline">\(R_i\)</span>和<span class="math inline">\(t_i\)</span>是位姿<span class="math inline">\(T_i\)</span>中的旋转矩阵和平移向量。</p>
<p>对选择为构建局部地图的关键帧分别应用上式并累加起来（实际累加后会进行体素降采样）后就构成局部地图<span class="math inline">\(M^e_i\)</span>和<span class="math inline">\(M^p_i\)</span>，<span class="math inline">\(e\)</span>和<span class="math inline">\(p\)</span>下标表示edge和planner。</p>
<p>同时，我们对当前帧的特征点云<span class="math inline">\(F^e_i\)</span>和<span class="math inline">\(F^p_i\)</span>应用位姿的初始估计<span class="math inline">\(\hat{T}_i\)</span>可以得到在近似地图坐标系下的点云。为了方便后面叙述，这里省略坐标系和关键帧索引的上下标。重申一下我们的输入：</p>
<ol type="1">
<li>地图坐标系下的局部点云地图<span class="math inline">\(M^e\)</span>和<span class="math inline">\(M^p\)</span></li>
<li>雷达坐标系下的当前帧特征点云<span class="math inline">\(F^e\)</span>和<span class="math inline">\(F^p\)</span></li>
<li>当前帧的初始位姿估计<span class="math inline">\(\hat{T}_i=[\hat{R}_i,\hat{t}_i]\)</span></li>
</ol>
<p>我们的目标就是优化位姿<span class="math inline">\(T_i\)</span>使得用这个位姿将<span class="math inline">\(F^e\)</span>和<span class="math inline">\(F^p\)</span>转换到地图坐标系后与地图点云的匹配程度最好。</p>
<h2 id="几何相关知识">几何相关知识</h2>
<h3 id="点到线距离">点到线距离</h3>
<h4 id="论文中计算方法">论文中计算方法</h4>
<figure>
<img src="./imgs/LOAM-fig7.png" alt="" /><figcaption>LOAM论文图7：展示如何根据当前帧的边缘点和平面点在局部地图中找到对应的线和平面</figcaption>
</figure>
<p>上图的子图（a）展示如何对当前帧边缘点点集<span class="math inline">\(F^e\)</span>中的每一个点从局部地图<span class="math inline">\(M^e\)</span>中找到对应的直线。对于每一个边缘点<span class="math inline">\(P^{F^e}_i \in F^e\)</span>，从局部地图的边缘点集合<span class="math inline">\(M^e\)</span>中找到最近点<span class="math inline">\(P^{M^e}_j\)</span>，橘色线是点<span class="math inline">\(j\)</span>所在的激光线束，蓝色线是前后相近的另外两条激光线束。从前后两条激光线束（蓝色线）找出与<span class="math inline">\(e_i\)</span>距离最近的点，并选择两者中距离更小的点作为点<span class="math inline">\(P^{M^e}_l\)</span>，则经过点<span class="math inline">\(P^{M^e}_j\)</span>、<span class="math inline">\(P^{M^e}_l\)</span>组成的线为点<span class="math inline">\(P^{F^e}_i\)</span>对应的直线。那么问题就转化为点<span class="math inline">\(P^{F^e}_i\)</span>到经过点<span class="math inline">\(P^{M^e}_j\)</span>、<span class="math inline">\(P^{M^e}_l\)</span>的直线的距离。</p>
<p>该距离计算公式如下：</p>
<p><span class="math display">\[
d_{e}=\frac{|(P^{F^e}_i - P^{M^e}_j)\times (P^{F^e}_i - P^{M^e}_l)|}{|(P^{M^e}_j - P^{M^e}_l)|}\tag{1}
\]</span></p>
<p>公式（1）中分子部分计算的是向量<span class="math inline">\((P^{F^e}_i - P^{M^e}_j)\)</span>和<span class="math inline">\((P^{F^e}_i - P^{M^e}_l)\)</span>的叉积的模长。两个向量的叉积是一个向量，方向于两个向量构成的平面垂直，模长等于两个向量组成的平行四边形面积。公式（1）的分母代表的是该平行四边形对角线的长度。因此分子除以分母就等于直线外一点到直线的距离。</p>
<h4 id="代码中计算方法">代码中计算方法</h4>
<p>在论文中对<span class="math inline">\(F^e\)</span>的点找到<span class="math inline">\(M^e\)</span>对应的直线是通过找到两个距离最近的点，但是在代码中是找到距离最近的5个点，然后计算这5个点的协方差，对协方差做特征值分解，最大的特征值对应的特征向量为主方向，并判断这5个点的分布是否接近直线的要求。 代码中寻找点到局部地图的对应直线，然后计算距离和法向量主要是在<code>mapOptimization</code>中的函数<code>cornerOptimization</code>中完成。</p>
<ol type="1">
<li>对点集<span class="math inline">\(F^e\)</span>中的点从局部地图<span class="math inline">\(M^e\)</span>中找到最近5个点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从局部地图（已经提前设置好kdtree）中找到最近的5个点</span></span><br><span class="line"><span class="comment">// pointSel为检索点</span></span><br><span class="line"><span class="comment">// pointSearchInd存储检索结果的5个点在原始点云中的索引</span></span><br><span class="line"><span class="comment">// pointSearchSqDis存储检索出的5个点与检索点的距离的平方</span></span><br><span class="line">kdtreeCornerFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>计算这5个点的协方差矩阵</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cx,cy,cz是检索出的5个点的中心坐标</span></span><br><span class="line"><span class="type">float</span> cx = <span class="number">0</span>, cy = <span class="number">0</span>, cz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    cx += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">    cy += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">    cz += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">&#125;</span><br><span class="line">cx /= <span class="number">5</span>; cy /= <span class="number">5</span>;  cz /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协方差矩阵是对称矩阵</span></span><br><span class="line"><span class="type">float</span> a11 = <span class="number">0</span>, a12 = <span class="number">0</span>, a13 = <span class="number">0</span>, a22 = <span class="number">0</span>, a23 = <span class="number">0</span>, a33 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="type">float</span> ax = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].x - cx;</span><br><span class="line">    <span class="type">float</span> ay = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].y - cy;</span><br><span class="line">    <span class="type">float</span> az = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].z - cz;</span><br><span class="line"></span><br><span class="line">    a11 += ax * ax; a12 += ax * ay; a13 += ax * az;</span><br><span class="line">    a22 += ay * ay; a23 += ay * az;</span><br><span class="line">    a33 += az * az;</span><br><span class="line">&#125;</span><br><span class="line">a11 /= <span class="number">5</span>; a12 /= <span class="number">5</span>; a13 /= <span class="number">5</span>; a22 /= <span class="number">5</span>; a23 /= <span class="number">5</span>; a33 /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储协方差的值到matA1</span></span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = a11; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>) = a12; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) = a13;</span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>) = a12; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>) = a22; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) = a23;</span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>) = a13; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">1</span>) = a23; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) = a33;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>计算直线方向，也就是特征值分解，最大特征值对应的特征向量为数据主方向</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对协方差矩阵做特征值分解，最大特征值对应的特征向量是这5个点的主方向</span></span><br><span class="line">cv::<span class="built_in">eigen</span>(matA1, matD1, matV1);</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>计算点到直线距离</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下部分是在计算当前点pointSel到检索出的直线的距离和方向，如果距离够近，则认为匹配成功，否则认为匹配失败</span></span><br><span class="line"><span class="comment">// x0,y0,z0是直线外一点</span></span><br><span class="line"><span class="type">float</span> x0 = pointSel.x;</span><br><span class="line"><span class="type">float</span> y0 = pointSel.y;</span><br><span class="line"><span class="type">float</span> z0 = pointSel.z;</span><br><span class="line"><span class="comment">// matV1的第一行就是5个点形成的直线的方向，cx,cy,cz是5个点的中心点</span></span><br><span class="line"><span class="comment">// 因此，x1,y1,z1和x2,y2,z2是经过中心点的直线上的另外两个点，两点之间的距离是0.2米</span></span><br><span class="line"><span class="type">float</span> x1 = cx + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> y1 = cy + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">float</span> z1 = cz + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">float</span> x2 = cx - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> y2 = cy - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">float</span> z2 = cz - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这边是在求[(x0-x1),(y0-y1),(z0-z1)]与[(x0-x2),(y0-y2),(z0-z2)]叉乘得到的向量的模长</span></span><br><span class="line"><span class="comment">// 这个模长是由0.2*V1[0]和点[x0,y0,z0]构成的平行四边形的面积</span></span><br><span class="line"><span class="comment">// 垂直于0,1,2三点构成的平面的向量[XXX,YYY,ZZZ] = [(y0-y1)(z0-z2)-(y0-y2)(z0-z1),-(x0-x1)(z0-z2)+(x0-x2)(z0-z1),(x0-x1)(y0-y2)-(x0-x2)(y0-y1)]</span></span><br><span class="line"><span class="type">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) * ((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                + ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) * ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                + ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)) * ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// l12表示的是0.2*(||V1[0]||)</span></span><br><span class="line"><span class="comment">// 点x1,y1,z1到点x2,y2,z2的距离</span></span><br><span class="line"><span class="type">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求叉乘结果[la&#x27;,lb&#x27;,lc&#x27;]=[(x1-x2),(y1-y2),(z1-z2)]x[XXX,YYY,ZZZ]</span></span><br><span class="line"><span class="comment">// [la,lb,lc]=[la&#x27;,lb&#x27;,lc&#x27;]/a012/l12</span></span><br><span class="line"><span class="comment">// LLL=[la,lb,lc]是0.2*V1[0]这条高上的单位法向量。||LLL||=1；</span></span><br><span class="line"><span class="type">float</span> la = ((y1 - y2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">          + (z1 - z2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lb = -((x1 - x2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">            - (z1 - z2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lc = -((x1 - x2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">            + (y1 - y2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ld2就是点pointSel(x0,y0,z0)到直线的距离</span></span><br><span class="line"><span class="type">float</span> ld2 = a012 / l12;</span><br></pre></td></tr></table></figure>
<h3 id="点到面距离">点到面距离</h3>
<h4 id="论文中计算方法-1">论文中计算方法</h4>
<p>再次贴出论文中的图</p>
<figure>
<img src="./imgs/LOAM-fig7.png" alt="" /><figcaption>LOAM论文图7：展示如何根据当前帧的边缘点和平面点在局部地图中找到对应的线和平面</figcaption>
</figure>
<p>与计算点到直线的距离类似，对于一个平面点<span class="math inline">\(P^{F^p}_i \in F^p\)</span>，从局部地图平面点集<span class="math inline">\(M^p\)</span>中找到最近点<span class="math inline">\(P^{M^p}_j\)</span>，再从该点所在的激光线束找到另一个点<span class="math inline">\(P^{M^p}_l\)</span>以及前后两条激光线束中找到另外一个最近点<span class="math inline">\(P^{M^p}_m\)</span>，这样就确保了三个点不会共线。 那么问题就转化为已知经过三个点<span class="math inline">\(P^{M^p}_{jlm}\)</span>的平面，求平面外一点<span class="math inline">\(P^{F^p}_i\)</span>到该平面的距离 首先，根据三个点，我们可以计算该平面的法向量，并归一化为单位法向量</p>
<p><span class="math display">\[
n_{jlm}=(P^{M^p}_j - P^{M^p}_l)\times (P^{M^p}_j - P^{M^p}_m)
\]</span></p>
<p><span class="math display">\[
n_{jlm} = \frac{n_{jlm}}{|n_{jlm}|}
\]</span></p>
<p>于是，点到平面的距离为 <span class="math display">\[
d_p = |(P^{F^p}_i - P^{M^p}_j)n_{jlm}|\tag{2}
\]</span></p>
<h4 id="代码中计算方法-1">代码中计算方法</h4>
<p>在代码中，也是先根据点<span class="math inline">\(P^{F^p}_i\)</span>从局部地图平面点集中找到最近的5个点，然后对这5个点用最小二乘法（求解超定方程）得到拟合平面的法向量。得到平面方程后就可以直接计算点到平面的距离了。这部分代码在<code>mapOptimization.cpp</code>中<code>surfOptimization</code>函数</p>
<ol type="1">
<li>从局部地图找到距离最近的5个点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与边缘点找直线一样，从局部地图的平面点集中找到与pointSel距离最近的5个点</span></span><br><span class="line">kdtreeSurfFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>求解方程Ax+By+Cz+1=0方程</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的过程要求解Ax+By+Cz+1=0的平面方程</span></span><br><span class="line"><span class="comment">// 由于有5个点，因此是求解超定方程</span></span><br><span class="line"><span class="comment">// 假设5个点都在平面上，则matA0是系数矩阵，matB0是等号右边的值（都是-1）；matX0是求出来的A，B，C</span></span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">5</span>, <span class="number">3</span>&gt; matA0;</span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">5</span>, <span class="number">1</span>&gt; matB0;</span><br><span class="line">Eigen::Vector3f matX0;</span><br><span class="line"></span><br><span class="line">matA0.<span class="built_in">setZero</span>();</span><br><span class="line">matB0.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">matX0.<span class="built_in">setZero</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">0</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">1</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">2</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是求解matA0XmatX0 = matB0方程</span></span><br><span class="line">matX0 = matA0.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(matB0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>求点到平面距离</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pa = <span class="built_in">matX0</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pb = <span class="built_in">matX0</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pc = <span class="built_in">matX0</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （pa,pb,pc)是平面的法向量，这里是对法向量规一化，变成单位法向量</span></span><br><span class="line"><span class="type">float</span> ps = <span class="built_in">sqrt</span>(pa * pa + pb * pb + pc * pc);</span><br><span class="line">pa /= ps; pb /= ps; pc /= ps; pd /= ps;</span><br></pre></td></tr></table></figure>
<h2 id="最小二乘问题求解">最小二乘问题求解</h2>
<p>从前面两步，我们得到了一些边缘点和平面点到局部地图的距离和距离向量，我们的目标就是优化这些距离。由于我们现在有6个未知数，也就是位姿的6个自由度<span class="math inline">\(T_i=[t_x,t_y,t_z,roll,pitch,yaw]\)</span>，但是我们的点超过6个，因此是求解最小二乘问题。</p>
<p>最小二乘问题是最优化里的基础问题，这里就不展开公式推导了，具体可以参考这篇文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113946848">最小二乘问题求解的四种解法</a>。</p>
<p>常见的求解最小二乘问题有高斯牛顿法（Gauss-Newton Method）和列温伯格马夸克法（Levernberg-Marquate），后者是前者的改进。<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>论文里面虽然用的是LM算法，但是在代码中实际用的是GN算法。这里只强调GN算法的核心思路。</p>
<p><code>GN</code>算法也是迭代更新的算法，每一步重点在与求出未知量的更新方向和步长，每一步将更行向量叠加到未知量上，让目标函数逐渐收敛。 在这里，未知量是位姿<span class="math inline">\(T_i\)</span>，目标函数是点到直线点到平面距离<span class="math inline">\(\mathbb{d}\)</span>，因此，我们在每一步迭代中要找到一个<span class="math inline">\(\Delta{T}_i\)</span>，更新未知量<span class="math inline">\(T_i = T_i + \Delta{T}_i\)</span>，并使得距离<span class="math inline">\(\mathbb{b}\)</span>逐渐下降。</p>
<p>在高斯牛顿法中，更新向量的是通过求解增量方程得到</p>
<p><span class="math display">\[
J(x)J(x)^T\Delta{x}=-J(x)f(x)\tag{3}
\]</span></p>
<p>公式（3）就是高斯牛顿法的增量方程，<span class="math inline">\(J(x)\)</span>是雅克比矩阵，也就是目标函数相对于未知量的偏导；<span class="math inline">\(f(x)\)</span>是目标函数；<span class="math inline">\(\Delta{x}\)</span>就是我们要求的增量。</p>
<h2 id="代码中点云匹配算法基于gn算法">代码中点云匹配算法（基于GN算法）</h2>
<p>这部分内容对于数学公式推导部分主要参考<a target="_blank" rel="noopener" href="https://wykxwyc.github.io/2019/08/01/The-Math-Formula-in-LeGO-LOAM/#lmoptimization%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97">wykxwyc.github.io</a>，但是原文中对于旋转矩阵对欧拉角的求导似乎有点问题，与代码对不上。</p>
<h3 id="欧拉角转旋转矩阵">欧拉角转旋转矩阵</h3>
<p>代码中对角度的表达使用欧拉角表达，因此我们需要先将欧拉角转换为旋转矩阵形式。记<span class="math inline">\(x,y,z\)</span>轴的角度为<span class="math inline">\(\alpha,\beta,\gamma\)</span></p>
<p><span class="math display">\[
\begin{split}
R_{\alpha}=
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;\cos\alpha&amp;-\sin\alpha\\
0&amp;\sin\alpha&amp;\cos\alpha
\end{bmatrix}
\end{split}
\]</span></p>
<p><span class="math display">\[
\begin{split}
R_{\beta}=
\begin{bmatrix}
\cos\beta&amp;0&amp;\sin\beta\\
0&amp;1&amp;0\\
-\sin\beta&amp;0&amp;\cos\beta
\end{bmatrix}
\end{split}
\]</span></p>
<p><span class="math display">\[
\begin{split}
R_{\gamma}=
\begin{bmatrix}
\cos\gamma&amp;-\sin\gamma&amp;0\\
\sin\gamma&amp;\cos\gamma&amp;0\\
0&amp;0&amp;1\\
\end{bmatrix}
\end{split}
\]</span></p>
<p><strong>PS:</strong> 为了简便起见，我们在后面的推导中使用<span class="math inline">\(c_1,c_2,c_3\)</span>表示<span class="math inline">\(\cos\alpha,\cos\beta,\cos\gamma\)</span>，用<span class="math inline">\(s_1,s_2,s_3\)</span>表示<span class="math inline">\(\sin\alpha,\sin\beta,\sin\gamma\)</span></p>
<p>根据上面转换关系，使用<span class="math inline">\(Z-X-Y\)</span>顺序，将欧拉角转换为旋转矩阵如下</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
R
&amp;=&amp;R_yR_xR_z\\
&amp;=&amp;
\begin{bmatrix}
c_2&amp;0&amp;s_2\\
0&amp;1&amp;0\\
-s_2&amp;0&amp;c_2
\end{bmatrix}
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;c_1&amp;-s_1\\
0&amp;s_1&amp;c_1
\end{bmatrix}
\begin{bmatrix}
c_3&amp;-s_3&amp;0\\
s_3&amp;c_3&amp;0\\
0&amp;0&amp;1
\end{bmatrix}\\
&amp;=&amp;
\begin{bmatrix}
c_2c_3+s_1s_2s_3&amp;-c_2s_3+s_1s_2c_3&amp;c_1s_2\\
c_1s_3&amp;c_1c_3&amp;-s_1\\
-s_2c_3+s_1c_2s_3&amp;s_2s_3+s_1c_2c_3&amp;c_1c_2
\end{bmatrix}
\end{array}
\end{split}
\]</span></p>
<hr />
<h3 id="旋转矩阵对欧拉角求偏导">旋转矩阵对欧拉角求偏导</h3>
<p>有了上面欧拉角转旋转矩阵的公式之后，求旋转矩阵相对于欧拉角的偏导就容易多了，先求<span class="math inline">\(R\)</span>相对于角<span class="math inline">\(\alpha\)</span>的偏导</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial R}{\partial \alpha} = 
\begin{bmatrix}
c_1s_2s_3&amp;c_1s_2c_3&amp;-s_1s_2\\
-s_1s_3&amp;-s_1c_3&amp;-c_1\\
c_1c_2s_3&amp;c_1c_2c_3&amp;-s_1c_2
\end{bmatrix}
\end{split}
\]</span></p>
<p>再求<span class="math inline">\(R\)</span>相对于<span class="math inline">\(\beta\)</span>的偏导</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial R}{\partial \beta} = 
\begin{bmatrix}
-s_2c_3+s_1c_2s_3&amp;s_2s_3+s_1c_2c_3&amp;c_1c_2\\
0&amp;0&amp;0\\
-c_2c_3-s_1s_2s_3&amp;c_2s_3-s_1s_2c_3&amp;-c_1s_2
\end{bmatrix}
\end{split}
\]</span></p>
<p>最后求<span class="math inline">\(R\)</span>相对于<span class="math inline">\(\gamma\)</span>的偏导</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial R}{\partial \gamma} = 
\begin{bmatrix}
-c_2s_3+s_1s_2c_3&amp;-c_2c_3-s_1s_2s_3&amp;0\\
c_1c_3&amp;-c_1s_3&amp;0\\
s_2s_3+s_1c_2c_3&amp;s_2c_3-s_1c_2s_3&amp;0
\end{bmatrix}
\end{split}
\]</span></p>
<hr />
<h3 id="目标函数对位姿求雅克比矩阵">目标函数对位姿求雅克比矩阵</h3>
<p><strong>时刻牢记：位姿<span class="math inline">\(T_i=[t_x,t_y,t_z,\alpha,\beta,\gamma]=[R,t]\)</span>是我们要求的量</strong></p>
<p>对于当前帧特征点<span class="math inline">\(F^e,F^p\)</span>中的一个点<span class="math inline">\(P_i=[p_x,p_y,p_z]\)</span>（这里没有区分边缘点和平面点，因为两者的偏导公式一样），我们使用函数<span class="math inline">\(G(\cdot)\)</span>将其从雷达坐标系转换到局部坐标系(m上标表示地图坐标系)</p>
<p><span class="math display">\[
P^m_i=G(P_i,T_i)=R\cdot P_i+t
\]</span></p>
<p>我们使用函数<span class="math inline">\(D(\cdot)\)</span>表示该点到局部地图的距离，也就是目标函数</p>
<p><span class="math display">\[
loss=D(G(P_i,T_i),Map) = d
\]</span></p>
<p>上式中<span class="math inline">\(d\)</span>对于边缘点代表点到直线距离，对于平面点表示点到平面距离</p>
<p><strong>误差对旋转求偏导</strong></p>
<p>这里以<span class="math inline">\(x\)</span>轴的旋转<span class="math inline">\(\alpha\)</span>为例</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\frac{\partial loss}{\partial \alpha}
&amp;=&amp;
\frac{\partial D\left(G(P_i,T_i),Map\right)}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial G}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i+t}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R}{\partial \alpha}\cdot P_i
\end{array}
\end{split}\tag{4}
\]</span></p>
<p><strong>误差对平移求偏导</strong></p>
<p>这里以<span class="math inline">\(x\)</span>轴的平移<span class="math inline">\(t_x\)</span>为例</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\frac{\partial loss}{\partial t_x}
&amp;=&amp;
\frac{\partial D\left(G(P_i,T_i),Map\right)}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial G}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i+t}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i}{\partial \alpha} + \frac{\partial D}{\partial G}\cdot\frac{\partial t}{\partial t_x}\\
&amp;=&amp;
0+\frac{\partial D}{\partial G}\cdot\frac{\partial t}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}
\end{array}
\end{split}\tag{5}
\]</span></p>
<p><strong>求解<span class="math inline">\(\frac{\partial D}{\partial G}\)</span></strong></p>
<p>在上面误差对旋转求偏导中旋转矩阵对欧拉角求偏导<span class="math inline">\(\frac{\partial R}{\partial \alpha}\)</span>已经在前面的章节推导过了。公式(4)(5)还有一个未知量就是<span class="math inline">\(\frac{\partial D}{\partial G}\)</span></p>
<p><span class="math display">\[
\frac{\partial D}{\partial G} = \frac{\partial d}{\partial P^m_i}
\]</span></p>
<p>也就是说<span class="math inline">\(\frac{\partial D}{\partial G}\)</span>求的是损失函数也就是点到线和点到面的距离相对于点（地图坐标系下）的偏导数。这点可以理解成求一个移动方向，使得让点<span class="math inline">\(P^m_i\)</span>沿着这个方向移动，损失函数上升得最快。很容易想到这个方向就是法线方向（对于点到直线的情况则是直线的垂线方向） 因此</p>
<p><span class="math display">\[
\frac{\partial D}{\partial G} = \frac{\partial d}{\partial P^m_i}=\big(\frac{\partial d}{\partial x}, \frac{\partial d}{\partial y}, \frac{\partial d}{\partial z}\big)=(n_x,n_y,n_z)
\]</span></p>
<h3 id="代码中雅克比矩阵的计算">代码中雅克比矩阵的计算</h3>
<p>这部分计算主要在<code>mapOptimization.cpp</code>中的<code>LMOptimization</code>函数。这里要注意的是，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>这部分代码计算中还加了坐标系的转换，实际上是没有必要的，这部分代码可以看<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的代码，是完全一样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算三轴欧拉角的sin、cos，后面使用旋转矩阵对欧拉角求导中会使用到</span></span><br><span class="line"><span class="comment">// lidar -&gt; camera</span></span><br><span class="line"><span class="type">float</span> srx = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">1</span>]);</span><br><span class="line"><span class="type">float</span> crx = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">1</span>]);</span><br><span class="line"><span class="type">float</span> sry = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"><span class="type">float</span> cry = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"><span class="type">float</span> srz = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">0</span>]);</span><br><span class="line"><span class="type">float</span> crz = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// laserCloudOri是在cornerOptimization、surfOptimization两个函数中找到的有匹配关系的</span></span><br><span class="line"><span class="comment">// 角点和平面点，如果找到的可供优化的点数太少，则跳过此次优化</span></span><br><span class="line"><span class="type">int</span> laserCloudSelNum = laserCloudOri-&gt;<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (laserCloudSelNum &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matA是Jacobians矩阵J</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matA</span><span class="params">(laserCloudSelNum, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAt</span><span class="params">(<span class="number">6</span>, laserCloudSelNum, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtA</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// matB是目标函数，也就是距离</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matB</span><span class="params">(laserCloudSelNum, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtB</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// matX是高斯-牛顿法计算出的更新向量</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matX</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matP</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">PointType pointOri, coeff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudSelNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 坐标系转换这部分可以不用看，没有什么作用</span></span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    pointOri.x = laserCloudOri-&gt;points[i].y;</span><br><span class="line">    pointOri.y = laserCloudOri-&gt;points[i].z;</span><br><span class="line">    pointOri.z = laserCloudOri-&gt;points[i].x;</span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    coeff.x = coeffSel-&gt;points[i].y;</span><br><span class="line">    coeff.y = coeffSel-&gt;points[i].z;</span><br><span class="line">    coeff.z = coeffSel-&gt;points[i].x;</span><br><span class="line">    coeff.intensity = coeffSel-&gt;points[i].intensity;</span><br><span class="line">    <span class="comment">// in camera</span></span><br><span class="line">    <span class="comment">// 求雅克比矩阵的值，也就是求目标函数（点到线、平面的距离）相对于tx,ty,tz,rx,ry,rz的导数</span></span><br><span class="line">    <span class="comment">// 具体的公式推导看仓库README中本项目博客，高斯牛顿法方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)，\Delta&#123;x&#125;就是要求解的更新向量matX</span></span><br><span class="line">    <span class="comment">// arx是目标函数相对于roll的导数</span></span><br><span class="line">    <span class="type">float</span> arx = (crx*sry*srz*pointOri.x + crx*crz*sry*pointOri.y - srx*sry*pointOri.z) * coeff.x</span><br><span class="line">              + (-srx*srz*pointOri.x - crz*srx*pointOri.y - crx*pointOri.z) * coeff.y</span><br><span class="line">              + (crx*cry*srz*pointOri.x + crx*cry*crz*pointOri.y - cry*srx*pointOri.z) * coeff.z;</span><br><span class="line">    <span class="comment">// ary是目标函数相对于pitch的导数</span></span><br><span class="line">    <span class="type">float</span> ary = ((cry*srx*srz - crz*sry)*pointOri.x </span><br><span class="line">              + (sry*srz + cry*crz*srx)*pointOri.y + crx*cry*pointOri.z) * coeff.x</span><br><span class="line">              + ((-cry*crz - srx*sry*srz)*pointOri.x </span><br><span class="line">              + (cry*srz - crz*srx*sry)*pointOri.y - crx*sry*pointOri.z) * coeff.z;</span><br><span class="line">    <span class="comment">// arz是目标函数相对于yaw的导数</span></span><br><span class="line">    <span class="type">float</span> arz = ((crz*srx*sry - cry*srz)*pointOri.x + (-cry*crz-srx*sry*srz)*pointOri.y)*coeff.x</span><br><span class="line">              + (crx*crz*pointOri.x - crx*srz*pointOri.y) * coeff.y</span><br><span class="line">              + ((sry*srz + cry*crz*srx)*pointOri.x + (crz*sry-cry*srx*srz)*pointOri.y)*coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在求点到直线的距离时，coeff表示的是如下内容</span></span><br><span class="line"><span class="comment">    [la,lb,lc]表示的是点到直线的垂直连线方向，s是长度</span></span><br><span class="line"><span class="comment">    coeff.x = s * la;</span></span><br><span class="line"><span class="comment">    coeff.y = s * lb;</span></span><br><span class="line"><span class="comment">    coeff.z = s * lc;</span></span><br><span class="line"><span class="comment">    coeff.intensity = s * ld2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在求点到平面的距离时，coeff表示的是</span></span><br><span class="line"><span class="comment">    [pa,pb,pc]表示过外点的平面的法向量，s是线的长度</span></span><br><span class="line"><span class="comment">    coeff.x = s * pa;</span></span><br><span class="line"><span class="comment">    coeff.y = s * pb;</span></span><br><span class="line"><span class="comment">    coeff.z = s * pc;</span></span><br><span class="line"><span class="comment">    coeff.intensity = s * pd2;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">0</span>) = arz;</span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">1</span>) = arx;</span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">2</span>) = ary;</span><br><span class="line">    <span class="comment">// 目标函数相对于tx的导数等于法向量的x</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">3</span>) = coeff.z;</span><br><span class="line">    <span class="comment">// 目标函数相对于ty的导数等于法向量的y</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">4</span>) = coeff.x;</span><br><span class="line">    <span class="comment">// 目标函数相对于tz的导数等于法向量的z</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">5</span>) = coeff.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matB存储的是目标函数（距离）的负值，因为：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)</span></span><br><span class="line">    matB.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">0</span>) = -coeff.intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新">更新</h3>
<p>得到雅克比矩阵后就可以直接求解高斯-牛顿法里的增量方程</p>
<p><span class="math display">\[
J(x)J(x)^T\Delta{x}=-J(x)f(x)\tag{3}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">transpose</span>(matA, matAt);</span><br><span class="line">matAtA = matAt * matA;</span><br><span class="line">matAtB = matAt * matB;</span><br><span class="line"><span class="comment">// 求解高斯-牛顿法中的增量方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)，这里解出来的matX就是更新向量</span></span><br><span class="line"><span class="comment">// matA是雅克比矩阵J</span></span><br><span class="line"><span class="comment">// matAtB是上面等式中等号的右边，负号在matB赋值的时候已经加入</span></span><br><span class="line">cv::<span class="built_in">solve</span>(matAtA, matAtB, matX, cv::DECOMP_QR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将增量matX叠加到变量（位姿）transformTobeMapped中</span></span><br><span class="line">transformTobeMapped[<span class="number">0</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">1</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">2</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">3</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">4</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">5</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高斯矩阵退化">高斯矩阵退化</h3>
<div id="Degenerate">

</div>
<p>这部分代码其实有一小段没办法完全理解，就是在进行第一次迭代时会对近似Hessian矩阵做是否退化的的判断，然后对退化的方向进行处理，最后对增量进行重新加权。但是实在没有找到这种用法的出处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是第一次迭代，判断求解出来的近似Hessian矩阵，也就是J^&#123;T&#125;J:=matAtA是否退化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这部分的计算说实话没有找到很好的理论出处，这里只能大概说一下这段代码想要做的事情</span></span><br><span class="line"><span class="comment">    * 这里用matAtA也就是高斯-牛顿中的近似海瑟（Hessian）矩阵H。求解增量方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)</span></span><br><span class="line"><span class="comment">    * 要求H:=J^&#123;T&#125;J可逆，但H不一定可逆。下面的代码通过H的特征值判断H是否退化，并将退化的方向清零matV2。而后又根据</span></span><br><span class="line"><span class="comment">    * matV.inv()*matV2作为更新向量的权重系数，matV是H的特征向量矩阵。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (iterCount == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matE</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV2</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对近似Hessian矩阵做特征值分解，matE是特征值，matV是特征向量。opencv的matV中每一行是一个特征向量</span></span><br><span class="line">    cv::<span class="built_in">eigen</span>(matAtA, matE, matV);</span><br><span class="line">    matV.<span class="built_in">copyTo</span>(matV2);</span><br><span class="line"></span><br><span class="line">    isDegenerate = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> eignThre[<span class="number">6</span>] = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matE.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, i) &lt; eignThre[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                matV2.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isDegenerate = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matP = matV.<span class="built_in">inv</span>() * matV2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当第一次迭代判断到海瑟矩阵退化，后面会使用计算出来的权重matP对增量matX做加权组合</span></span><br><span class="line"><span class="keyword">if</span> (isDegenerate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matX2</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    matX.<span class="built_in">copyTo</span>(matX2);</span><br><span class="line">    matX = matP * matX2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="收敛条件判断">收敛条件判断</h3>
<p>当增量步长达到一定阈值后，认为优化已经收敛，因此可以跳出后续迭代。这里用增量中的角度增量和平移增量的幅度做判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算roll、pitch、yaw的迭代步长</span></span><br><span class="line"><span class="type">float</span> deltaR = <span class="built_in">sqrt</span>(</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)), <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 计算tx，ty，tz的迭代步长</span></span><br><span class="line"><span class="type">float</span> deltaT = <span class="built_in">sqrt</span>(</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果迭代的步长达到设定阈值，则认为已经收敛</span></span><br><span class="line"><span class="keyword">if</span> (deltaR &lt; <span class="number">0.05</span> &amp;&amp; deltaT &lt; <span class="number">0.05</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// converged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（八）IMU预积分模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-30 20:55:54" itemprop="dateCreated datePublished" datetime="2023-03-30T20:55:54+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 21:47:44" itemprop="dateModified" datetime="2023-04-20T21:47:44+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（八）IMU预积分模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（八）IMU预积分模块" href="/2023/03/30/lio_sam/imuPreintegration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::447e7d053e8cf00fca42d617e062a049" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="imu预积分">IMU预积分</h2>
<figure>
<img src="./imgs/Design-Pipelines-IMU.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p><code>IMU预积分模块</code>无论在VIO或者LIO中都是一个非常重要的模块。VIO或者LIO中的<code>I</code>，也就是<code>Inertial</code>指的是惯性单元，基本上在这类SLAM框架里指的就是IMU里程计。 IMU可以输出车辆坐标系下的三轴加速度、三轴角速度、三轴地磁计（九轴IMU）。我们都知道，加速度的积分是速度、速度的积分是距离，角速度的积分是角度，地磁计可以计算与地磁北极的偏角，因此，如果IMU的输出是准确的话，使用IMU原始数据并进行积分就可以得到车辆的位姿。然而，目前无论多么高精度的IMU，都很难在较长时间下保持较高的准确度，而且积分会对误差也进行积分，导致IMU里程计只能用来做短时间内的位姿校正。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>是IMU里程计和激光雷达里程计紧耦合的SLAM框架。“紧耦合”三个字在IMU预积分模块得到明显的表达。如果用一句话说明IMU预积分模块的作用，那就是：利用IMU数据，为车辆位姿提供一个较好的位姿初始估计。由于目前的激光雷达大部分是10Hz，部分可以达到20Hz以上，因此，在两帧雷达点云期间，车辆会发生旋转和位移，如果旋转和位移很小，那么点云匹配就能够单独算出一个较准确的里程计（在运动缓慢的情况下，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>即使去除了IMU预积分也可以工作，只需要不启动<code>ImuPreintegration</code>节点即可）。但是如果旋转和位移较大，点云匹配就很可能失败。IMU一般拥有较高频率（200Hz以上），因此可以为两帧雷达点云的匹配提供较好的初始位姿值。</p>
<p>前面提到单纯利用IMU数据做积分，时间一长累积误差会很大，无法提供良好的初始位姿估计，因此需要融合其他传感器校正IMU积分算法。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，通过不断从激光里程计获取最新的里程计信息，作为IMU积分算法的观测来达到校正IMU积分算法的目的。</p>
<p><em>PS：此部分代码很大程度利用了<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>，因此，需要提前阅读本项目<a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></em></p>
<h2 id="imu预积分模块的整体框架流程图">IMU预积分模块的整体框架流程图</h2>
<figure>
<img src="./imgs/Design-imuPreintegration-top01.png" title="预积分模块流程图" alt="" /><figcaption>Simple-LIO-SAM预积分模块整体框架流程图</figcaption>
</figure>
<h2 id="零偏估计和imu里程计">零偏估计和IMU里程计</h2>
<p>这个模块容易让人看晕的地方在于模块里有两个队列缓存IMU原始数据，同时有两个IMU预积分器。之所以需要有两个预积分器的原因在于，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中对于IMU的预积分，在预测时（predict）需要指明上一时刻的<code>bias</code>，也就是IMU的零偏。通常这个<code>bias</code>会随着时间慢慢改变，因此不能用离线标定的数据直接使用。于是，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，有一个线程（LaserHandler）会利用激光里程计当作额外的观测量，不断估计最新的<code>bias</code>值。而另一个线程（ImuHandler）则可以一直利用最新的<code>bias</code>值对实时接收到的IMU数据做积分，并发布为IMU里程计。</p>
<p>为了简单起见，我们将用来做零偏估计的队列和预积分器叫做<strong>优化队列</strong>和<strong>优化预积分器</strong>；将用来实时对IMU数据积分并发布IMU里程计的队列和预积分器叫做<strong>IMU队列</strong>和<strong>IMU预积分器</strong>。</p>
<p>一图胜千言，下面这幅图描述了两个队列是如何被耦合起来输出更为准确的IMU预积分结果。其中<code>imuQueOpt</code>是优化队列，<code>imuQueImu</code>是IMU队列，两者命令与代码中一致。</p>
<figure>
<img src="./imgs/TwoImuQues.png" alt="" /><figcaption>两个IMU队列及线程交互图</figcaption>
</figure>
<h2 id="零偏估计线程即odometryhandler">零偏估计线程——即odometryHandler</h2>
<p>这个回调函数占据了预积分模块大部分内容，而且有较多的重置条件和与<code>imuHandler</code>线程同步的操作，比较容易弄混。</p>
<p>这个回调函数会在接收到新的一帧雷达里程计（发自<code>MapOptimization</code>模块），主要操作上图中的<code>imuQueOpt</code>和<code>优化预积分器</code>。每当节点新收到一帧雷达里程计时，就会执行<code>预积分模块流程图</code>中左侧的一系列操作。主要目的就是利用雷达里程计做观测数据，实时更新IMU的偏差<code>bias</code>。同时，更新过的<code>bias</code>会传递到<code>IMU预积分器</code>。</p>
<h3 id="系统初始化">系统初始化</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-sysinit.png" alt="" /><figcaption>系统初始化流程</figcaption>
</figure>
<p>当接收到第一帧雷达里程计时，需要对系统做初始化操作。主要包括因子图、因子图优化器、两个预积分器的初始化。由于初始化操作需要将第一帧雷达里程计的位姿作为先验因子，因此不能在构造函数中初始化。</p>
<h3 id="判断是否应该重置因子图">判断是否应该重置因子图</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-reset.png" alt="" /><figcaption>重置系统</figcaption>
</figure>
<p>为了保证拥有足够的实时性（预积分模块需要与IMU频率保持一致），<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的预积分模块在因子图中里程计因子数量大于100时会重置因子图与优化器。操作主要是从当前的因子图优化器拿出最新结果，并当作先验因子构造新的因子图。</p>
<h3 id="对优化队列中imu原始数据进行积分">对优化队列中IMU原始数据进行积分</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-integraOpt.png" alt="" /><figcaption>积分优化队列</figcaption>
</figure>
<p>这里要重新回顾上文的<code>线程交互图</code>。零偏估计线程的主要目的就是为IMU里程计线程提供最新的<code>bias</code>估计，因此每当到达新的一帧雷达里程计，意味着有新的观测到达，<code>bias</code>就可以进行更新。于是需要对优化队列中在当前雷达里程计时间之前的IMU原始数据用IMU预积分器进行积分，然后构造IMU因子。将IMU因子和雷达里程计加入因子图优化，得出最新的<code>bias</code>估计。</p>
<h3 id="因子图优化">因子图优化</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-factorgraph.png" alt="" /><figcaption>因子图优化部分</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>可以使用IMU预积分器构造IMU因子。利用<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>可以用因子图优化出<code>速度</code>,<code>IMU bias</code>,<code>位姿</code>的估计。其中<code>IMU bias</code>是我们要重点关注的内容。</p>
<h3 id="传递优化结果">传递优化结果</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-setBias.png" alt="" /><figcaption>传递优化结果</figcaption>
</figure>
<p>使用因子图优化出最新的IMU bias 之后，实际上还有优化后的位姿，这个位姿和IMU偏差会用来重置另外一个预积分器——<code>IMU预积分器</code>。IMU预积分器是在另一个回调函数中被主要使用，回顾<code>线程交互图</code>的下半部分和<code>模块流程图</code>的右侧流程。同时，设置完<code>IMU预积分器</code>之后，会将<code>imuQueImu</code>中剩余的其他IMU原始数据放入<code>IMU预积分器</code>做积分，这样<code>IMU预积分器</code>就一直保持最新状态，在<code>imuHandler</code>中可以实时积分并发布IMU里程计。</p>
<h2 id="imu里程计线程即imuhandler">IMU里程计线程——即imuHandler</h2>
<p>这个回调函数比起odometryHandler就要简单很多。这个回调函数的主要功能就只有两个：</p>
<p>1、不断地将新收到的IMU数据塞入两个放置IMU原始数据的队列——<code>线程交互图</code>中的imuQueOpt和imuQueImu； 2、使用<code>IMU预积分器</code>对收到的IMU数据做积分，并将结果作为IMU里程计发布。</p>
<p>主要流程如下图：</p>
<figure>
<img src="./imgs/Design-imuPreintegration-imuHandler.png" alt="" /><figcaption>IMU里程计线程</figcaption>
</figure>
<p>这个回调函数比较简单，就不再赘述。</p>
<h2 id="代码要点">代码要点</h2>
<h3 id="坐标系转换">坐标系转换</h3>
<p>IMU预积分模块中代码涉及到多次坐标系转换。主要是要明白IMU积分的原理和<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中坐标系的转换关系。关于坐标系有几个注意要点：</p>
<p><strong>1. 所有IMU原始数据都会先旋转到与雷达的坐标系朝向一致后再进行处理</strong></p>
<p>在<code>imuHandler</code>中每收到一个IMU数据就先旋转再存放。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L555-L556">code</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU数据旋转到lidar的旋转朝向</span></span><br><span class="line">sensor_msgs::msg::Imu thisImu = <span class="built_in">imuConverter</span>(*imu_raw);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存IMU数据</span></span><br><span class="line">imuQueOpt.<span class="built_in">push_back</span>(thisImu);</span><br><span class="line">imuQueImu.<span class="built_in">push_back</span>(thisImu);</span><br></pre></td></tr></table></figure>
<p><strong>2. 里程计都是对齐到雷达坐标系</strong></p>
<p>所有在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架中发布出来的里程计，无论是IMU里程计或者是雷达里程计，度量的都是雷达在地图坐标系下的位姿。但是在IMU预积分模块的零偏估计线程中，使用IMU数据做积分，又需要使用雷达里程计作为观测，两者要同时加入因子图中，所以必须统一两者的坐标系。IMU原始数据在上面提到的第一个注意要点已经旋转到对齐雷达的方向，两者之间还差一个平移。因此，在接收到雷达里程计时，会先平移到旋转后的IMU坐标系，最后再平移回来。 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L298-L300">雷达里程计平移到旋转后的IMU坐标系代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化因子图的prior状态</span></span><br><span class="line"><span class="comment">// 将雷达里程计位姿平移到IMU坐标系，只是做了平移</span></span><br><span class="line">prevPose_ = lidarPose.<span class="built_in">compose</span>(lidar2Imu);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L585-L587">将IMU里程计对齐到雷达坐标系代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU里程计完全对齐到雷达（剩下一个平移关系）</span></span><br><span class="line">gtsam::Pose3 imuPose = gtsam::<span class="built_in">Pose3</span>(currentState.<span class="built_in">quaternion</span>(), currentState.<span class="built_in">position</span>());</span><br><span class="line">gtsam::Pose3 lidarPose = imuPose.<span class="built_in">compose</span>(imu2Lidar);</span><br></pre></td></tr></table></figure>
<h3 id="时间同步">时间同步</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架中各个模块都是进行异步通信（ros topic），因此在每个模块里面都有几个队列保存数据，处理的时候再根据时间戳做同步。IMU预积分模块中有多个地方对数据做了时间戳同步。 比如在更新完<code>bias</code>之后，对IMU队列做积分时，会先抛弃早于最新的雷达里程计时间之前的数据。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L480-L486">code link</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样先做IMU数据队列和雷达里程计的时间同步</span></span><br><span class="line"><span class="type">double</span> lastImuQT = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!imuQueImu.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp) &lt; currentLidarOdomTime - <span class="type">sync_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lastImuQT = <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp);</span><br><span class="line">    imuQueImu.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（七）GTSAM快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-27 21:28:48" itemprop="dateCreated datePublished" datetime="2023-03-27T21:28:48+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 21:33:14" itemprop="dateModified" datetime="2023-04-20T21:33:14+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（七）GTSAM快速入门" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（七）GTSAM快速入门" href="/2023/03/27/lio_sam/gtsam-quickstart/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::0d35c30bd7aedf439c2d1184605769ac" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>其中的两大模块<code>ImuPreintegration</code>和<code>MapOptimization</code>都依赖了因子图优化框架——<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>。 为了确保本项目的自洽性以及后面章节讲解的展开，不介绍一下因子图后端优化算法似乎说不过去。但是笔者目前对因子图的原理还没有进行非常详细的推导，因此这部分 内容会偏向如何对<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>快速入门。当然，最快速的入门方式就是完整地阅读一遍<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的官方教程。这部分章节只是拙劣地进行知识的搬迁，当然不是直接将 <a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的教程直接翻译过来。本章节会介绍<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>快速入门的知识，同时讲解<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>提供的<code>examples</code>中跟<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>联系较为紧密的一两个，同时指明<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中的用法出处。 至少阅读完本章节后应该能够对因子图有基本的认识，并且能够看懂<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中对<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的使用</p>
<h2 id="slam后端图优化">SLAM后端——图优化</h2>
<h3 id="问题描述">问题描述</h3>
<p>让我们先回归问题本身。在SLAM中，我们可以拥有多个输入，我们的最终目的是获取一条最准确的轨迹，然后使用这条准确的轨迹实时构建地图。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，我们有以下输入：</p>
<ol type="1">
<li>IMU数据；</li>
<li>点云数据；</li>
<li>GPS数据（可选）；</li>
<li>回环检测；</li>
</ol>
<p>我们的问题是如何使用这些数据计算出一条最准确的历史轨迹，使用该轨迹就可以将对应的点云投影到地图坐标系，以此来建立一个点云格式地图。 （PS：这只是SLAM的一个形式，就是优化出一条光滑准确的轨迹，这也是在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中使用的方法，因此本文以这种类型作为讲解）</p>
<h3 id="非线性优化">非线性优化</h3>
<p>在SLAM领域后端优化的一个分支是<code>滤波器方法</code>，主要以扩展卡尔曼滤波方法为主，采用隐马尔科夫假设，只保存上一次状态，并通过当前输入预测当前状态，偶尔通过观测修正状态。具体可见本博客的<a href="https://zeal-up.github.io/2023/03/13/kalman_filter/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%88%B0%E4%BA%92%E8%A1%A5%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/">卡尔曼滤波相关文章</a></p>
<p>目前的后端优化主要以各种非线性优化方法为主，把批量的位姿加入目标方程（projective function）一起优化，得到具有更好的全局性质的解。</p>
<p><span class="math display">\[
\mathbf{x}^* = \argmin_{\mathbf{x}}\mathbb{F}(\mathbf{x})
\]</span></p>
<p>其中，<span class="math inline">\(\mathbb{F}\)</span>是历史轨迹引入的各个误差之和</p>
<p><span class="math display">\[
\mathbb{F}(\mathbf{x}) = \sum\mathbf{e}(x_i,c_{ij},x_j)
\]</span></p>
<p><span class="math inline">\(x_i,x_j\)</span>是历史时刻的位姿，<span class="math inline">\(c_{ij}\)</span>是两者之间的约束（可以认为是观测或者输入）</p>
<p><strong>PS：再重申一句，SLAM后端体系很庞大，不是一篇文章能说清楚的，笔者目前也还没有这个能力。目前只求能够稍微讲清楚<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中是怎么被使用的即可。</strong></p>
<p>为了求解非线性方程在不同的SLAM任务中的特点，又发展出各种不同的优化方式，比如VIO中有Bundle Adjustment，有其他叫PoseGraph的，还有<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中使用的FactorGraph。 简单理解就是这些都是非线性方程和求解在不同的任务场景中的细分。后面有机会再单独列一篇文章讲解这些后端优化方法把。</p>
<figure>
<img src="./imgs/introToBA.png" alt="" /><figcaption>一图说明BA</figcaption>
</figure>
<h3 id="图优化">图优化</h3>
<p><strong>以下内容大量引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-repo/doc/gtsam.pdf</a></strong></p>
<p>为了批量优化历史位姿<span class="math inline">\(\mathbf{x} = \{x_0, x_1, x_2, ... x_i\}\)</span>，研究者将图论引入SLAM后端优化。每一个机器的位姿<span class="math inline">\(x_i\)</span>是图中的顶点；通过各种里程计计算，比如连续位姿间的IMU积分结果或者点云匹配结果，成为两个位姿<span class="math inline">\(x_i,x_j\)</span>之间的边；对于一些额外的观测，比如GPS数据，成为连接顶点的一元边（只有一端连接到顶点）。比如下图(引用自：<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>)</p>
<figure>
<img src="./imgs/egForFactorGraph.png" alt="" /><figcaption>FactorGraph</figcaption>
</figure>
<h2 id="gtsam">GTSAM</h2>
<p>GTSAM使用因子图（FactorGraph）作为通用的图问题描述框架，并为各种机器人任务提供实现好的优化算法API，使得研究者快速开发后端优化框架。</p>
<p><strong>图优化（GraphOptimization）vs. <a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中使用的因子图优化（FactorGraph Optimization）区别 vs. BA</strong></p>
<ol type="1">
<li><strong>图优化</strong>似乎一般指位姿图（PoseGraph）的优化，图中的顶点都是机器人的位姿</li>
<li><strong>BA</strong>(Bundle Adjustment)似乎一般指在视觉SLAM中对地标（Landmarks）和位姿同时优化的方法</li>
<li><strong>GTSAM</strong>的因子图除了能够构建位姿图之外，还可以将速度、偏差、IMU预积分等当作顶点和边加入图中。另外，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>框架实现了iSAM和iSAM2两个递增式优化器</li>
</ol>
<h3 id="重要概念">重要概念</h3>
<p><strong>变量（variables）</strong>：因子图中的每一个顶点是一个代求的变量。假设我们只需要求解每一个时刻的机器人姿态，那么每个顶点就是该时刻的机器人位姿，如上图中的<span class="math inline">\({X_1,X_2,X_3}\)</span></p>
<p><strong>值（values）</strong>：值是每个变量数值。在调用优化器对因子图做优化时，我们要先为每个变量设置初始值，优化结束后再从优化器中拿出每个变量优化后的值。</p>
<p><strong>因子（factors）</strong>：因子是因子图中的边，每条边都可以视为一个因子，每个因子又可以认为是一个约束。比如连续两个位姿之间可以由IMU计算出两个位姿的变换，该变换作为一条边加入因子图连接两个变量（<code>二元因子：binary factor</code>）；又或者在某个时刻有GPS数据输入，GPS数据是一个观测，也可以作为一个因子加入因子图，这时候GPS的边只有一端连接到变量（<code>一元因子：unary factor</code>）。</p>
<p><strong>因子图（factor graph）</strong>：因子图由顶点（变量）和因子（边）构成。</p>
<p><strong>优化器（Optimizer）</strong>：因子图只是建模了SLAM的历史位姿和输入与观测间的关系，如何求解这个因子图也就是如何设置变量使得整个图最符合所有的约束（误差最小）则需要用到优化器。除了最常见的求解非线性问题的<code>Gaussian-Newton</code>和<code>Levenberg-Marquardt</code>优化器之外，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>还实现了两个增量式优化器<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>,<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a></p>
<p><strong>键（Keys）</strong>：往因子图添加因子需要指定该因子连接到哪些变量。GTSAM中使用键来指明。一元因子需要指明其连接到第几个变量；二元因子需要指明其连接到哪两个变量。因子图中每个变量的键都应该是唯一的。为了方便在多种变量类型的情况下指明键，GTSAM提供<code>Symbols</code>来让用户方便生成不同变量类型的键值。（键不一定是连续的，但必须是唯一的）</p>
<h3 id="gtsam例子最小例子">GTSAM例子——最小例子</h3>
<p>本小节引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>—第2章 以构建并求解下面因子图为例</p>
<figure>
<img src="./imgs/gtsam-minExample.png" alt="" /><figcaption>GTSAM最小例子因子图示意</figcaption>
</figure>
<p>上图中<span class="math inline">\(x_1,x_2,x_3\)</span>为机器人三个时刻的位姿；<span class="math inline">\(f_0\)</span>为第一个时刻机器人位姿的观测；<span class="math inline">\(f_1,f_2\)</span>为时刻1-2和时刻2-3之间的里程计估计。<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/OdometryExample.cpp">代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个空的非线性因子图</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建先验因子，也就是图中的f_0</span></span><br><span class="line"><span class="comment">// 这里使用二维姿态（x,y,theta）简化问题</span></span><br><span class="line"><span class="function">Pose2 <span class="title">priorMean</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 高斯噪声，代表我们对该因子的不确定性</span></span><br><span class="line"><span class="keyword">auto</span> priorNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将先验因子加入因子图</span></span><br><span class="line"><span class="comment">// 其中的1表示该因子连接到第1个变量</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, priorMean, priorNoise));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建里程计因子，也就是图中的f_1,f_2</span></span><br><span class="line"><span class="comment">// 往前移动2米，y轴不便，theta不变</span></span><br><span class="line"><span class="function">Pose2 <span class="title">odometry</span><span class="params">(<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> odometryNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将里程计因子加入因子图</span></span><br><span class="line"><span class="comment">// 1,2代表该里程计约束是从变量1到变量2</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, <span class="number">2</span>, odometry, odometryNoise));</span><br><span class="line"><span class="comment">// 添加相同的因子到变量2和变量3之间</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">2</span>, <span class="number">3</span>, odometry, odometryNoise));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置各个变量的初始值</span></span><br><span class="line">Values initial;</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="built_in">Pose2</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="built_in">Pose2</span>(<span class="number">2.3</span>, <span class="number">0.1</span>, <span class="number">-0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="built_in">Pose2</span>(<span class="number">4.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用优化器并使用设定好的初始值对因子图优化</span></span><br><span class="line">Values result = <span class="built_in">LevenberMarquardtOptimizer</span>(graph, initial).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure>
<h3 id="gtsam例子imu预积分及imufactor">GTSAM例子——IMU预积分及ImuFactor</h3>
<p>在目前的SLAM，无论是VIO还是LIO，前端都需要IMU做积分得到一个位姿的初始估计。<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中实现了一个IMU预积分算法，并可以将其直接加入因子图中做优化。这在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中也被使用到。 本例子引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/ImuFactorsExample2.cpp">GTSAM-repo/examples/ImuFactorExample2.cpp</a>，为了说明<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中IMU预积分器及<code>ImuFactor</code>的用法，对该例子进行简化。最后构建出的因子图如下（为了可视化，人工调整了布局）：</p>
<figure>
<img src="./imgs/ImuFactorGraph.png" alt="" /><figcaption>使用ImuFactor构建的因子图</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，完整代码见下文</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IMU 预积分器</span></span><br><span class="line"><span class="comment">// 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span></span><br><span class="line"><span class="keyword">auto</span> params = PreintegrationParams::<span class="built_in">MakeSharedU</span>(kGravity);</span><br><span class="line">params-&gt;<span class="built_in">setAccelerometerCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setGyroscopeCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setIntegrationCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setUse2ndOrderCoriolis</span>(<span class="literal">false</span>);</span><br><span class="line">params-&gt;<span class="built_in">setOmegaCoriolis</span>(<span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 设置IMU预积分器</span></span><br><span class="line"><span class="function">PreintegratedImuMeasurements <span class="title">accum</span><span class="params">(params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个非线性因子图</span></span><br><span class="line">NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明因子图的初始值和优化结果</span></span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置位姿的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量x0的一元因子</span></span><br><span class="line"><span class="comment">// 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span></span><br><span class="line"><span class="keyword">auto</span> noise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(</span><br><span class="line">    (<span class="built_in">Vector</span>(<span class="number">6</span>) &lt;&lt; Vector3::<span class="built_in">Constant</span>(<span class="number">0.1</span>), Vector3::<span class="built_in">Constant</span>(<span class="number">0.3</span>)).<span class="built_in">finished</span>());</span><br><span class="line"><span class="comment">// 将位姿的先验因子加入因子图中</span></span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0, noise);</span><br><span class="line"><span class="comment">// 将位姿0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置IMU偏差的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量b0的一元因子</span></span><br><span class="line">Key biasKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> biasnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(Vector6::<span class="built_in">Constant</span>(<span class="number">0.1</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>(), biasnoise);</span><br><span class="line"><span class="comment">// 将IMU偏差b0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置速度的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量v0的一元因子</span></span><br><span class="line"><span class="comment">// 这里设置初始速度为0：Vector3(0,0,0)</span></span><br><span class="line"><span class="keyword">auto</span> velnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), velnoise);</span><br><span class="line"><span class="comment">// 将速度v0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于机器人的所有位姿时刻（关键帧）</span></span><br><span class="line"><span class="keyword">for</span> (i in N_steps)</span><br><span class="line">&#123;</span><br><span class="line">  biasKey++;</span><br><span class="line">  Symbol b1 = biasKey - <span class="number">1</span>;</span><br><span class="line">  Symbol b2 = biasKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置i时刻的位姿初始值</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(i), pose_i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于两个时刻之间的所有IMU数据进行积分</span></span><br><span class="line">  <span class="keyword">for</span> (j in N_imu_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    accum.<span class="built_in">integrateMeasurement</span>(measuredAcc, measuredOmega, <span class="type">delta_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用预积分器构建IMU因子，并加入因子图中</span></span><br><span class="line">  <span class="comment">// IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span></span><br><span class="line">  <span class="function">ImuFactor <span class="title">imufac</span><span class="params">(X(i - <span class="number">1</span>), V(i - <span class="number">1</span>), X(i), V(i), biasKey, accum)</span></span>;</span><br><span class="line">  newgraph.<span class="built_in">add</span>(imufac);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加两个时刻之间IMU偏差因子</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::<span class="built_in">ConstantBias</span>(), cov);</span><br><span class="line">  newgraph.<span class="built_in">add</span>(f);</span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(i), linear_velocity_vector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重值IMU预积分器</span></span><br><span class="line">  accum.<span class="built_in">resetIntegration</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用LM优化器对因子图进行优化并获取优化结果</span></span><br><span class="line">result = <span class="built_in">LevenbergMarquardtOptimizer</span>(newgraph, initialEstimate).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure>
<details class="note info no-icon"><summary><p>IMU预积分及IMU因子完整代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre>
</td>
<td class="code">
<pre><span class="line">/**</span><br><span class="line"> * @file ImuFactorExample2</span><br><span class="line"> * @brief Test example for using GTSAM ImuFactor and ImuCombinedFactor with ISAM2. Simplify and add graphviz by Zeal</span><br><span class="line"> * @author Robert Truax</span><br><span class="line"> * @author Zeal</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;gtsam/geometry/PinholeCamera.h&gt;</span><br><span class="line">#include &lt;gtsam/geometry/Cal3_S2.h&gt;</span><br><span class="line">#include &lt;gtsam/inference/Symbol.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuBias.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuFactor.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/Scenario.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/ISAM2.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span><br><span class="line">#include &lt;gtsam/slam/BetweenFactor.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace gtsam;</span><br><span class="line"></span><br><span class="line">// Shorthand for velocity and pose variables</span><br><span class="line">using symbol_shorthand::V;</span><br><span class="line">using symbol_shorthand::X;</span><br><span class="line"></span><br><span class="line">const double kGravity = 9.81;</span><br><span class="line"></span><br><span class="line">/* ************************************************************************* */</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // 起点</span><br><span class="line">  Pose3 pose_0(Rot3::Rodrigues(0, 0, 0), Point3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // 设置一个姿态仿真器，姿态沿着y轴以5m/s的速度前进，没有角度变化</span><br><span class="line">  Vector3 angular_velocity_vector(0, 0, 0);</span><br><span class="line">  Vector3 linear_velocity_vector(0, 5, 0);</span><br><span class="line">  auto scenario = ConstantTwistScenario(angular_velocity_vector,</span><br><span class="line">                                        linear_velocity_vector, pose_0);</span><br><span class="line">  // 设置仿真步长为1s</span><br><span class="line">  double delta_t = 1.0;</span><br><span class="line"></span><br><span class="line">  // 设置一个非线性因子图</span><br><span class="line">  NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line">  // 声明因子图的初始值和优化结果</span><br><span class="line">  Values initialEstimate, result;</span><br><span class="line"></span><br><span class="line">  // 设置位姿的先验因子</span><br><span class="line">  // 对应到上图中连接到变量x0的一元因子</span><br><span class="line">  // 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span><br><span class="line">  auto noise = noiseModel::Diagonal::Sigmas(</span><br><span class="line">      (Vector(6) &lt;&lt; Vector3::Constant(0.1), Vector3::Constant(0.3)).finished());</span><br><span class="line">  // 将位姿的先验因子加入因子图中</span><br><span class="line">  newgraph.addPrior(X(0), pose_0, noise);</span><br><span class="line">  // 将位姿0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(X(0), pose_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 设置IMU偏差的先验因子</span><br><span class="line">  // 对应到上图中连接到变量b0的一元因子</span><br><span class="line">  Key biasKey = Symbol(&#x27;b&#x27;, 0);</span><br><span class="line">  auto biasnoise = noiseModel::Diagonal::Sigmas(Vector6::Constant(0.1));</span><br><span class="line">  newgraph.addPrior(biasKey, imuBias::ConstantBias(), biasnoise);</span><br><span class="line">  // 将IMU偏差b0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">  </span><br><span class="line">  // 设置速度的先验因子</span><br><span class="line">  // 对应到上图中连接到变量v0的一元因子</span><br><span class="line">  // 这里设置初始速度为0：Vector3(0,0,0)</span><br><span class="line">  auto velnoise = noiseModel::Diagonal::Sigmas(Vector3(0.01, 0.01, 0.01));</span><br><span class="line">  newgraph.addPrior(V(0), Vector3(0,0,0), velnoise);</span><br><span class="line">  // 将速度v0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(V(0), Vector3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // IMU 预积分器</span><br><span class="line">  // 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span><br><span class="line">  auto params = PreintegrationParams::MakeSharedU(kGravity);</span><br><span class="line">  params-&gt;setAccelerometerCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setGyroscopeCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setIntegrationCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setUse2ndOrderCoriolis(false);</span><br><span class="line">  params-&gt;setOmegaCoriolis(Vector3(0, 0, 0));</span><br><span class="line">  // 设置IMU预积分器</span><br><span class="line">  PreintegratedImuMeasurements accum(params);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 模仿机器人在运动，这里一共有3个位姿节点0,1,2</span><br><span class="line">  // 在运动过程中模拟IMU预积分，并将IMU因子、IMU偏差因子加入因子图中</span><br><span class="line">  for (size_t i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">    double t = i * delta_t;</span><br><span class="line">    if (i &gt; 0) &#123;  // 设置位姿的初始值，这里是错误示范，使用真值作为初始值设置</span><br><span class="line">      auto pose_i = scenario.pose(t);</span><br><span class="line">      initialEstimate.insert(X(i), pose_i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加IMU因子和IMU偏差因子</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">      // 周期性添加IMU的偏差因子；IMU的偏差需要用其他方式计算，也可以使用离线标定的参数（一般不会）</span><br><span class="line">      if (i % 2 == 0) &#123;</span><br><span class="line">        // b1是上一次的IMU偏差变量的键值；b2是本次IMU偏差的键值</span><br><span class="line">        biasKey++;</span><br><span class="line">        Symbol b1 = biasKey - 1;</span><br><span class="line">        Symbol b2 = biasKey;</span><br><span class="line">        // 添加两个IMU偏差变量之间的二元因子</span><br><span class="line">        Vector6 covvec;</span><br><span class="line">        covvec &lt;&lt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1;</span><br><span class="line">        auto cov = noiseModel::Diagonal::Variances(covvec);</span><br><span class="line">        auto f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::ConstantBias(), cov);</span><br><span class="line">        newgraph.add(f);</span><br><span class="line">        // 将当前的IMU偏差变量的初始估计加入初始值集合</span><br><span class="line">        initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 这部分才是预积分器进行积分的地方</span><br><span class="line">      // 每次积分接收加速度、角速度以及间隔时间delta_t</span><br><span class="line">      Vector3 measuredAcc = scenario.acceleration_b(t);</span><br><span class="line">      Vector3 measuredOmega = scenario.omega_b(t);</span><br><span class="line">      accum.integrateMeasurement(measuredAcc, measuredOmega, delta_t);</span><br><span class="line"></span><br><span class="line">      // 使用预积分器构建IMU因子，并加入因子图中</span><br><span class="line">      // IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span><br><span class="line">      ImuFactor imufac(X(i - 1), V(i - 1), X(i), V(i), biasKey, accum);</span><br><span class="line">      newgraph.add(imufac);</span><br><span class="line"></span><br><span class="line">      // 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span><br><span class="line">      initialEstimate.insert(V(i), linear_velocity_vector);</span><br><span class="line">      // 重值IMU预积分器</span><br><span class="line">      accum.resetIntegration();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 使用初始值保存因子图</span><br><span class="line">  newgraph.saveGraph(&quot;ImuFactorsExample2_graphviz.dot&quot;, initialEstimate);</span><br><span class="line">  // 打印到命令行</span><br><span class="line">  newgraph.dot(cout, result);</span><br><span class="line"></span><br><span class="line">  // 调用LM优化器对因子图进行优化并获取优化结果</span><br><span class="line">  result = LevenbergMarquardtOptimizer(newgraph, initialEstimate).optimize();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* ************************************************************************* */</span><br><span class="line"></span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<h3 id="gtsam例子递增式优化">GTSAM例子——递增式优化</h3>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>不仅内置了<code>Gaussian-Newton</code>和<code>Leverberg-Marquat</code>两个常见的非线性优化器，还实现了<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>和<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a>两个递增式的优化器。 递增式优化器更符合SLAM中常见的使用方式，也就是持续加入新的位姿和约束，并持续进行优化。</p>
<p>这部分内容可以参考<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>——第7章</p>
<p><a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/VisualISAM2Example.cpp">example/VisualISAM2Example.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置iSAM2优化器</span></span><br><span class="line"><span class="function">ISAM2 <span class="title">isam</span><span class="params">(parameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置因子图和初始值</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; poses.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; relations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose3&gt;(i, j))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加初始值到初始估计集合</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>,i), initial_x[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将因子图加入优化器</span></span><br><span class="line">  isam.<span class="built_in">update</span>(graph, initialEstimate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空当前因子图和初始值</span></span><br><span class="line">  <span class="comment">// 因子图已经加入优化器，因此需要清空为下一次因子图做准备</span></span><br><span class="line">  graph.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">  initialEstimate.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gtsam学习路径">GTSAM学习路径</h2>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>对整个SLAM后端问题都封装得很好，因此可以让我们在不了解优化细节的情况下也可以构建自己的优化算法。除了对后端优化和图优化这些知识掌握外，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的学习主要还是要<code>学以致用</code>， 这里只是简单列出笔者觉得比较合适的资料阅读和学习顺序。</p>
<ol type="1">
<li>本文</li>
<li>GTSAM仓库下<code>doc</code>文件夹中的<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">gtsam.pdf</a></li>
<li>GTSAM仓库下<code>examples</code>文件夹中的一些例子，主要是对照上面的文档以及本文出现的例子进行阅读运行</li>
<li>本项目博客中关于<code>ImuPreintegration</code>和<code>MapOptimization</code>的讲解</li>
<li>本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">spl</a>中<code>src/mapOptimization.cpp</code>和<code>src/imuPreintegration.cpp</code>代码</li>
</ol>
<h2 id="资料参考">资料参考</h2>
<ol type="1">
<li>对目前各个图优化框架（g2o,GTSAM,ceres,SE-Sync）等做统一分析的综述性论文（强烈建议）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://lamor.fer.hr/images/50036607/2021-ajuric-comparison-mipro.pdf">A Comparison of Graph OptimizationApproaches for Pose Estimation in SLAM</a></p>
<ol start="2" type="1">
<li>Introduction to Bundle Adjustment, ppt</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://vincentqin.gitee.io/blogresource-3/slam-summer-courses-CADCG-Lab/BA-haominLiu.pdf">Bundle Adjustment</a></p>
<ol start="3" type="1">
<li>对基于图的SLAM后端优化算法的讲解，对SLAM的后端问题做比较正式的描述，接近2000引用</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf">A Tutorial on Graph-Based SLAM</a></p>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（六）特征提取模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 20:03:12" itemprop="dateCreated datePublished" datetime="2023-03-22T20:03:12+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 21:17:55" itemprop="dateModified" datetime="2023-04-20T21:17:55+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（六）特征提取模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（六）特征提取模块" href="/2023/03/22/lio_sam/featureExtraction-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::e84bd67344741c4da21c259e3e444c5d" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="点云特征提取">点云特征提取</h2>
<figure>
<img src="./imgs/Design-Pipelines-feature.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>、<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的做法，从原始点云中提取出边缘点和平面点。边缘点和平面点被下游模块用来做点云匹配和构建地图。 特征提取模块是比较简单的模块，只监听来自<code>ImageProjection</code>发布出来的去畸变后点云，同时将提取出的特征点云发布出去。这里有几点需要注意：</p>
<ol type="1">
<li>特征点的提取根据点的平滑度，而平滑度则通过每个点与周围点距离的平均值做近似</li>
<li>实际上在提取完边缘点和平面点之后，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>在代码里又把所有非边缘点的点都加入了平面点集合。这是比较奇怪的地方。从这里看出也许特征提取也不是必要的， 因为平面点已经包含了大部分的点云。事实上，在Github的一个仓库<a target="_blank" rel="noopener" href="https://github.com/YJZLuckyBoy/liorf">liorf</a>中，就将特征提取模块去掉。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该段中除了角点之外的点加入平面点集合</span></span><br><span class="line"><span class="comment">// ！！！ 这点让步骤2感觉是多余的，最终的结果可能只是原始点云降采样，可能特征点提取也是没有必要的！！！</span></span><br><span class="line"><span class="comment">// cloudLabel标识该点的性质，-1为平面点，0为非特征点，1为边缘点。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        surfaceCloudScan-&gt;<span class="built_in">push_back</span>(extractedCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特征点提取原理">特征点提取原理</h2>
<p>关于特征点提取部分<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的论文基本略过，因为跟<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>和<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的做法基本相同。本文对算法中点云特征点提取做详细介绍。</p>
<h3 id="转换到rangemat">转换到RangeMat</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的做法，先把三维点全部投影到二维图片，图像像素保存每个点距离原点的距离，称做<code>RangeMat</code>，<code>RangeMat</code>是规则的，每一行代表一条激光线束扫射360度所产生的点，因此后面用这个<code>RangeMat</code>做特征提取更快速更简单。 PS：这部分是在<code>ImageProjection</code>就已经处理好，并且<code>RangeMat</code>也被展开成一维向量存储。</p>
<p>有一点要注意，在一些激光雷达中，<code>RangeMat</code>是可以直接从雷达驱动提供的接口拿到，但并不是所有雷达都提供这样的API。据笔者的了解，ouster的雷达驱动API就提供直接获取<code>RangeMat</code>的功能。</p>
<h3 id="平滑度估计">平滑度估计</h3>
<p>特征点提取通过每个点的平滑度来提取，平滑度高于某个阈值的认为是边缘点；平滑度小于某个阈值的认为是平面点。 而平滑度的估计则通过每一个点在该激光线成像的前后几个点的平均距离代替。 我们令时间<span class="math inline">\(t\)</span>的点云为<span class="math inline">\(P_t = \{p_i, i \in |P_t|\}\)</span>，同时我们可以根据每个点的坐标算出每个点距离原点的距离<span class="math inline">\(r_i\)</span>，对于每个点，我们取其同一条激光线上前后5个点构成集合<span class="math inline">\(S\)</span>，则，点<span class="math inline">\(p_i\)</span>的平滑度可以这样计算：</p>
<p><span class="math display">\[
c = \frac{1}{|S|\cdot||r_i||}\left|\left|\sum_{j\in S,j\neq i}(r_j-r_i)\right|\right|
\]</span></p>
<h3 id="分段提取及特征点数量数量限制">分段提取及特征点数量数量限制</h3>
<p>为了让特征点分布更均匀，采用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>，将整个360的图像在水平方向分成6个子图像，在每个子图像中进行特征点提取。并且，对于每一个子图像中的每一条激光线束，会限制边缘点数量不超过20个，平面点的数量则没有限制。</p>
<h3 id="特殊情况">特殊情况</h3>
<p><strong>有3种特殊情况不能将该点设置为边缘点：</strong></p>
<ol type="1">
<li>当一个点被选择为特征点，则把该点左右5个点都排除在特征点选取范围</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对该角点左右各5个点，如果两点之间的列索引差距小于10，则抛弃周围的点，避免重复对同一块区域提取角点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>当该点可能是由于遮挡导致被选择为边缘点</li>
</ol>
<figure>
<img src="./imgs/illegal_feature_point.png" alt="" /><figcaption>不合格的特征点(from LOAM)</figcaption>
</figure>
<p>如上图（b）所示，点A是由于被平面遮挡而产生的边缘点，当视角变化后，点A就不再是边缘点。 这个逻辑的判断也是通过点与其周围点的range差距判断。如果是由于遮挡产生的边缘点，则其与左边或者右边会存在距离的突变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// featureExtraction.cpp&gt;markOccludedPoints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markOccludedPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cloudSize = extractedCloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 标记被遮挡的点和与激光束平行的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记被遮挡的点</span></span><br><span class="line">        <span class="type">float</span> depth1 = cloudInfo.point_range[i];</span><br><span class="line">        <span class="type">float</span> depth2 = cloudInfo.point_range[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[i+<span class="number">1</span>] - cloudInfo.point_col_ind[i]));</span><br><span class="line">        <span class="comment">// 两个点的列索引相差10个像素之内，认为是同一块区域</span></span><br><span class="line">        <span class="keyword">if</span> (columnDiff &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前点距离大于右点距离0.3米，认为当前点及左边6个点无效</span></span><br><span class="line">            <span class="keyword">if</span> (depth1 - depth2 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前点距离小于右边点距离0.3米，认为右边6个点无效</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (depth2 - depth1 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记平行与激光束的点</span></span><br><span class="line">        <span class="type">float</span> diff1 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i<span class="number">-1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="type">float</span> diff2 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i+<span class="number">1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="comment">// 当前点与左右两点的距离均大于阈值，认为当前点是处于平行面的点</span></span><br><span class="line">        <span class="keyword">if</span> (diff1 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i] &amp;&amp; diff2 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i])</span><br><span class="line">            cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>当点处于跟激光线平行的平面上时，也可能被认为时边缘点，也需要排除 如上图中的(a)所示，点B位于一个跟激光线较为平行的面上，激光线扫过去，前后几个点的距离差距会很大，因此在处理时可能会被认为是边缘点。这些点也需要做标记，不要设置为边缘点。</li>
</ol>
<h2 id="特征点提取流程">特征点提取流程</h2>
<p>由于这部分代码和原理都比较简单，这里只说一下特征提取的流程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief</span></span><br><span class="line"><span class="comment">* cloudInfo话题的回调函数，这个模块的功能都是顺序进行</span></span><br><span class="line"><span class="comment">* 1. 接收到从imageProjection中发布出的一个去畸变点云信息cloudInfo(自定义格式)</span></span><br><span class="line"><span class="comment">* 2. 对每个点计算曲率。计算时是计算周围点的平均距离用来作为曲率的替代</span></span><br><span class="line"><span class="comment">* 3. 标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="comment">* 4. 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="comment">* 5. 整合信息，发布完整数据包</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param msgIn 从去畸变模块接受的数据包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 缓存全局变量，后面的函数可以直接读取cloudInfo和cloudHeader进行处理</span></span><br><span class="line">cloudInfo = *msgIn;</span><br><span class="line">cloudHeader = msgIn-&gt;header;</span><br><span class="line"><span class="comment">// 把ros2 PointCloud2转成PCL格式，方便后面处理</span></span><br><span class="line">pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_deskewed, *extractedCloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点云每一个点曲率</span></span><br><span class="line"><span class="built_in">calculateSmoothness</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="built_in">markOccludedPoints</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="built_in">extractFeatures</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合信息，发布完整数据包</span></span><br><span class="line"><span class="built_in">publishFeatureCloud</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/imageProjection-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（五）点云去畸变模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 15:55:36" itemprop="dateCreated datePublished" datetime="2023-03-22T15:55:36+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 22:54:00" itemprop="dateModified" datetime="2023-04-19T22:54:00+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/imageProjection-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（五）点云去畸变模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（五）点云去畸变模块" href="/2023/03/22/lio_sam/imageProjection-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::92a09cadad63fefbcbc8404aeb27c1f1" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<figure>
<img src="./imgs/Design-Pipelines-image.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p>点云去畸变模块（imageProjection.cpp文件，文件命名应该是继承了<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>，其实我觉得应该叫做数据预处理模块更合适）主要有以下几个作用</p>
<ol type="1">
<li>去除激光雷达点云的运动畸变</li>
<li>检索每一帧点云对应的IMU输出角度、IMU里程计位姿（发布自ImuPreintegration），以便MapOptimization模块用这些信息作为该帧点云的初始位姿</li>
<li>转换点云格式，计算<code>Range</code>字段，方便特征提取模块进行边缘点、平面点提取</li>
</ol>
<p>从<code>总体流程图</code>不难看出，点云去畸变模块是整个算法框架的入口。点云去畸变模块的总体流程如下图：</p>
<figure>
<img src="./imgs/Design-imageProjection-pipeline.png" alt="" /><figcaption>点云去畸变模块流程图</figcaption>
</figure>
<h2 id="消息订阅及发布">消息订阅及发布</h2>
<figure>
<img src="./imgs/Design-Node%26%26Topics-imageProjection.png" alt="" /><figcaption>去畸变模块的消息订阅及发布</figcaption>
</figure>
<p>从上图可以看到，这个模块订阅点云和IMU的原始数据，输出一个以<code>CloudInfo</code>格式的topic。下面详细讲解<code>CloudInfo</code>这个数据格式。</p>
<h2 id="cloudinfo数据类型">CloudInfo数据类型</h2>
<p>经过去畸变的点云通过算法自定义的数据格式<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/main/msg/CloudInfo.msg">Simple-LIO-SAM/msg/CloudInfo.msg</a>发布；特征提取模块也是将特征点放入这个自定义数据格式发布。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cloud Info</span></span><br><span class="line"><span class="string">std_msgs/Header</span> <span class="string">header</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在进行点云去畸变时，把range数据展开成一维向量</span></span><br><span class="line"><span class="comment"># ring代表第几条激光线数，比如16线的激光雷达有16个ring</span></span><br><span class="line"><span class="comment"># start_ring_index记录第一个ring在一维向量中的起始索引</span></span><br><span class="line"><span class="comment"># end_ring_index记录第一个ring在一维向量中的结束索引</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">start_ring_index</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">end_ring_index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录一维的Range数据中每一个点在原始range图片中属于那一个列</span></span><br><span class="line"><span class="string">int32[]</span>  <span class="string">point_col_ind</span> <span class="comment"># point column index in range image</span></span><br><span class="line"><span class="comment"># 所有点的range数值，展开为一维数组</span></span><br><span class="line"><span class="string">float32[]</span> <span class="string">point_range</span> <span class="comment"># point range </span></span><br><span class="line"></span><br><span class="line"><span class="string">int64</span> <span class="string">imu_available</span></span><br><span class="line"><span class="string">int64</span> <span class="string">odom_available</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attitude for LOAM initialization</span></span><br><span class="line"><span class="comment"># 从IMU原始数据获取的roll、pitch、yaw角初值</span></span><br><span class="line"><span class="comment"># 当上面的imu_avaliable为true，odom_available为false的时候，会被用来</span></span><br><span class="line"><span class="comment"># 当作这一帧点云的初值</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_roll_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_pitch_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_yaw_init</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial guess from imu pre-integration</span></span><br><span class="line"><span class="comment"># 从imuPreintegration，IMU预积分模块获取的与这一帧雷达最接近的初始位姿</span></span><br><span class="line"><span class="comment"># 当上面的odom_available标签被置为true的时候会被使用</span></span><br><span class="line"><span class="comment"># 优先级比imu_xxx_init高</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_x</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_y</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_z</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_roll</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_pitch</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_yaw</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Point cloud messages</span></span><br><span class="line"><span class="comment"># 去畸变后的原始点云</span></span><br><span class="line"><span class="comment"># 在经过imageProjection模块后，这个数据字段被填充。在经过特征提取之后这个字段被清空</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_deskewed</span> </span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云边缘点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_corner</span></span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云平面点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_surface</span></span><br></pre></td></tr></table></figure>
<p>这里主要是前面几个数组类型会比较难理解，主要是要知道在去畸变模块中，将所有点的<code>range</code>信息（也就是点距离雷达的距离）拉成一个一维的数组，即<code>float32[] point_range</code>。 同时，<code>cloud_deskewed</code>里存储的是去完畸变后的点云，里面点的顺序与<code>point_range</code>的顺序是一样的。</p>
<p><code>cloud_corner</code>和<code>cloud_surface</code>两个字段在<code>imageProjection</code>模块中没有被放置数据。特征提取模块会将边缘点、平面点放置在这两个字段中，同时将<code>cloud_deskewed</code>字段清空。</p>
<h2 id="功能解读">功能解读</h2>
<h3 id="imu及imu里程计处理">IMU及IMU里程计处理</h3>
<p>ImageProjection监听IMU原始数据与从<code>ImuPreintegration</code>（后面会详细讲解这个模块）发布出来的IMU里程计数据，分别由两个回调函数处理，对于IMU原始数据，只是简单地将其旋转到雷达坐标系后塞入缓存队列。 对于IMU历程计，则是直接塞入缓存队列。</p>
<h3 id="去畸变流程">去畸变流程</h3>
<p>一句话说明点云运动畸变校正：根据每一帧点云中每一个点的时间戳，计算该点到该帧点云起始点的旋转平移变换，将每一个点变换到起始点的坐标系。</p>
<p>要注意的是，算法中对运动畸变校正只做了旋转校正，没有做平移校正。</p>
<p>去畸变流程发生在点云的回调函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection::cloudHandler</span></span><br><span class="line"><span class="comment">/** 原始雷达点云话题的回调函数，实际上真正做点云处理的函数</span></span><br><span class="line"><span class="comment">    * 实际处理流程是单线程流水线式处理，这个函数后面的所有函数都是为这个函数服务，因此需要了解</span></span><br><span class="line"><span class="comment">    * 点云去畸变的流程。</span></span><br><span class="line"><span class="comment">    * 订阅原始lidar数据</span></span><br><span class="line"><span class="comment">    * 1、转换点云为统一格式，提取点云信息</span></span><br><span class="line"><span class="comment">    *   1）添加一帧激光点云到队列，取出最早一帧作为当前帧</span></span><br><span class="line"><span class="comment">    *   2) 计算起止时间戳，检查数据有效性</span></span><br><span class="line"><span class="comment">    * 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line"><span class="comment">    *   imu数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu数据，初始时刻对应imu的姿态角RPY设为当前帧的初始姿态角</span></span><br><span class="line"><span class="comment">    *   2) 用角速度、时间积分，计算每一时刻相对于初始时刻的旋转量，初始时刻旋转设为0</span></span><br><span class="line"><span class="comment">    *   imu里程计数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu里程计数据，初始时刻对应imu里程计设为当前帧的初始位姿</span></span><br><span class="line"><span class="comment">    *   2) 用起始、终止时刻对应imu里程计，计算相对位姿变换，保存平移增量</span></span><br><span class="line"><span class="comment">    * 3、当前帧激光点云运动畸变校正</span></span><br><span class="line"><span class="comment">    *   1) 检查激光点距离、扫描线是否合规</span></span><br><span class="line"><span class="comment">    *   2) 激光运动畸变校正，保存激光点</span></span><br><span class="line"><span class="comment">    * 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line"><span class="comment">    * 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line"><span class="comment">    * 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cloudHandler</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::PointCloud2::SharedPtr laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、提取、转换点云为统一格式</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cachePointCloud</span>(laserCloudMsg))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">deskewInfo</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、当前帧激光点云运动畸变校正</span></span><br><span class="line">    <span class="built_in">projectPointCloud</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line">    <span class="built_in">cloudExtraction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line">    <span class="built_in">publishClouds</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line">    <span class="built_in">resetParameters</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提取、转换点云为统一格式</li>
</ul>
<figure>
<img src="./imgs/Design-imageProjection-cachePointCloud.png" alt="" /><figcaption>提取、转换点云为统一格式</figcaption>
</figure>
<ul>
<li>提取去畸变信息</li>
</ul>
<figure>
<img src="./imgs/Design-imageProjection-deskewInfo.png" alt="" /><figcaption>提取去畸变信息</figcaption>
</figure>
<p>这里有几点要注意</p>
<ol type="1">
<li><p>从IMU原始数据计算每一时刻的位姿变换用的是近似算法（因为一帧点云成像时间很短，一般小于100ms） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对角度做积分</span></span><br><span class="line"><span class="comment">// 再次强调，对角速度的积分不是简单的角速度乘以间隔时间</span></span><br><span class="line"><span class="comment">// 关于角速度的积分公式可以查阅：https://zhuanlan.zhihu.com/p/591613108</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> timeDiff;</span><br><span class="line">timeDiff = currentImuTime - imuTime[imuPointerCur<span class="number">-1</span>];</span><br><span class="line">imuRotX[imuPointerCur] = imuRotX[imuPointerCur<span class="number">-1</span>] + angular_x * timeDiff;</span><br><span class="line">imuRotY[imuPointerCur] = imuRotY[imuPointerCur<span class="number">-1</span>] + angular_y * timeDiff;</span><br><span class="line">imuRotZ[imuPointerCur] = imuRotZ[imuPointerCur<span class="number">-1</span>] + angular_z * timeDiff;</span><br><span class="line">imuTime[imuPointerCur] = currentImuTime;</span><br><span class="line">++imuPointerCur;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对于速度较低，角度变化不那么剧烈的行驶系统，即使不做点云畸变校正也没有问题</p></li>
</ol>
<ul>
<li>对点云做去畸变处理</li>
</ul>
<figure>
<img src="./imgs/Design-imageProjection-projectPointCloud.png" alt="" /><figcaption>对点云做去畸变处理</figcaption>
</figure>
<ul>
<li>提取有效点云并集合其他信息</li>
</ul>
<p>这里主要是将经过去畸变处理后记录下来的有效点进行数据转换，并把各种信息填入准备发布的<code>cloud_info</code>消息中。</p>
<ul>
<li>发布点云</li>
</ul>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（四）utility文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 11:18:09" itemprop="dateCreated datePublished" datetime="2023-03-22T11:18:09+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 22:43:29" itemprop="dateModified" datetime="2023-04-19T22:43:29+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（四）utility文件解读" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（四）utility文件解读" href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6ed3eebc09d2237963daad43bab3bc96" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="utiliti.cpp文件">utiliti.cpp文件</h2>
<p>这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>里一个最基础的文件，主要有几个重要功能：</p>
<ol type="1">
<li>作为所有其他节点的基类，放置所有从配置文件读取的配置字</li>
<li>提供一些实用函数</li>
<li>配置<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html">QoS</a></li>
</ol>
<p>本文对这个文件的详细内容和重点详细解读。</p>
<h2 id="配置基类">配置基类</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>为了方便配置，把所有节点的配置项都写在同一个文件<code>Simple-LIO-SAM/config/params.yaml</code>，同时构建了一个基类<code>ParamServer</code>统一读取该配置文件，其余模块都从该基类继承。</p>
<figure>
<img src="./imgs/Design-Class.png" alt="" /><figcaption>源代码类图</figcaption>
</figure>
<p>这可能不是最优的方式，不过从实现上来说的确是最简单的。</p>
<p>每个模块的具体配置项后面具体讲解到会逐一解释，目前只需要知道是在哪里配置就行。</p>
<details class="note info no-icon"><summary><p>配置部分代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>
</td>
<td class="code">
<pre><span class="line">// Topics</span><br><span class="line">string pointCloudTopic;  // 原始点云数据话题（/points_raw）</span><br><span class="line">string imuTopic;         // 原始IMU数据话题（/imu_correct）</span><br><span class="line">string imuOdomTopic;     // IMU里程计，在imuPreintegration中对IMU做预积分得到（/lio_sam/imu/odometry）</span><br><span class="line">string lidarOdomTopic;   // 雷达里程计，在mapOptimization中得到（/lio_sam/mapping/odometry）</span><br><span class="line">string gpsTopic;         // 原始gps经过robot_localization包计算得到，暂未使用</span><br><span class="line"></span><br><span class="line">// Services</span><br><span class="line">string saveMapSrv;      // 保存地图service地址</span><br><span class="line"></span><br><span class="line">// Frames</span><br><span class="line">string imuFrame;        // IMU数据坐标系，如果IMU和激光雷达坐标系硬件对齐，可以认为IMU、Lidar、Chassis坐标系相同</span><br><span class="line">string lidarFrame;      // 激光雷达坐标系，点云数据坐标系，由激光雷达发布的数据指定。与lidarFrame相同，但是不同雷达有不同的名称</span><br><span class="line">string baseLinkFrame;   // 车辆底盘坐标系</span><br><span class="line">string odomFrame;       // 地图坐标系，在SLAM中一般也是世界坐标系，通常是车辆的起始坐标系</span><br><span class="line"></span><br><span class="line">// GPS Settings</span><br><span class="line">bool useImuHeadingInitialization;</span><br><span class="line">bool useGpsElevation;</span><br><span class="line">float gpsCovThreshold;</span><br><span class="line">float poseCovThreshold;</span><br><span class="line"></span><br><span class="line">// Save pcd</span><br><span class="line">bool savePCD;</span><br><span class="line">string savePCDDirectory;</span><br><span class="line"></span><br><span class="line">// Lidar Sensor Configuration</span><br><span class="line">SensorType sensor;</span><br><span class="line">int N_SCAN;</span><br><span class="line">int Horizon_SCAN;</span><br><span class="line">int downsampleRate;</span><br><span class="line">float lidarMinRange;</span><br><span class="line">float lidarMaxRange;</span><br><span class="line"></span><br><span class="line">// IMU</span><br><span class="line">float imuAccNoise;      // IMU加速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuGyrNoise;      // IMU角速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuAccBiasN;      // IMU加速度偏差，三轴统一</span><br><span class="line">float imuGyrBiasN;      // IMU角速度偏差，三轴统一</span><br><span class="line">float imuGravity;       // 重力加速度值</span><br><span class="line">float imuRPYWeight;     // 算法中使用IMU的roll、pitch角对激光里程计的结果加权融合</span><br><span class="line">vector&lt;double&gt; extRotV;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extRPYV;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extTransV;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Matrix3d extRot;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Matrix3d extRPY;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Vector3d extTrans;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Quaterniond extQRPY;     // IMU角速度向量到雷达坐标系的旋转（四元数形式）</span><br><span class="line"></span><br><span class="line">// LOAM</span><br><span class="line">float edgeThreshold;            // 边缘特征点提取阈值</span><br><span class="line">float surfThreshold;            // 平面特征点提取阈值</span><br><span class="line">int edgeFeatureMinValidNum;     // 边缘特征点数量阈值（default:10)</span><br><span class="line">int surfFeatureMinValidNum;     // 平面特征点数量阈值（default:100)</span><br><span class="line"></span><br><span class="line">// voxel filter paprams</span><br><span class="line">float odometrySurfLeafSize;</span><br><span class="line">float mappingCornerLeafSize;</span><br><span class="line">float mappingSurfLeafSize ;</span><br><span class="line"></span><br><span class="line">float z_tollerance;             // 限制z轴平移的大小</span><br><span class="line">float rotation_tollerance;      // 限制roll、pitch角的大小</span><br><span class="line"></span><br><span class="line">// CPU Params</span><br><span class="line">int numberOfCores;              // 在点云匹配中使用指令集并行加速（default:4）</span><br><span class="line">double mappingProcessInterval;  // 点云帧处理时间间隔（default:0.15s）</span><br><span class="line"></span><br><span class="line">// Surrounding map</span><br><span class="line">float surroundingkeyframeAddingDistThreshold;   // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingkeyframeAddingAngleThreshold;  // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingKeyframeDensity;               // 构建局部地图时对采用的关键帧数量做降采样</span><br><span class="line">float surroundingKeyframeSearchRadius;          // 构建局部地图时关键帧的检索半径</span><br><span class="line"></span><br><span class="line">// Loop closure</span><br><span class="line">bool  loopClosureEnableFlag;</span><br><span class="line">float loopClosureFrequency;                     // 回环检测独立线程的执行频率</span><br><span class="line">int   surroundingKeyframeSize;                  // 回环检测构建局部地图的最大关键帧数量</span><br><span class="line">float historyKeyframeSearchRadius;              // 执行回环检测时关键帧的检索半径</span><br><span class="line">float historyKeyframeSearchTimeDiff;            // 执行回环检测时关键帧的检索时间范围</span><br><span class="line">int   historyKeyframeSearchNum;                 // 执行回环检测时融合局部地图时对目标关键帧执行+-25帧的关键帧融合</span><br><span class="line">float historyKeyframeFitnessScore;              // 执行回环检测时使用ICP做点云匹配，阈值大于0.3认为匹配失败，不采纳当前回环检测</span><br><span class="line"></span><br><span class="line">// global map visualization radius</span><br><span class="line">float globalMapVisualizationSearchRadius;</span><br><span class="line">float globalMapVisualizationPoseDensity;</span><br><span class="line">float globalMapVisualizationLeafSize;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<h2 id="实用函数">实用函数</h2>
<p>这里主要讲解其中一个<code>imuConverter</code>函数。该函数的功能主要是将<code>IMU</code>的原始数据<strong>旋转到</strong><code>Lidar</code>坐标系。这里要先知道，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中， 默认将雷达坐标系和小车的坐标系等同为同一个坐标系，同时，这里只做了<strong>旋转</strong>操作，没有做平移操作。代码中有很多处位置都用到这个函数，因此需要理解这个函数到底做了什么。 简单来说这个函数就是做了一个<strong>向量坐标变换</strong>。旋转矩阵操作空间中一个点有两种意义：1）三维旋转；2）坐标变换。这两种不同的操作在做连续的操作时，对应旋转矩阵的左乘和右乘。 由于笔者以前的研究方向是六自由度姿态估计，用三维旋转操作比较多，一开始被这里的<code>矩阵右乘</code>搞蒙了。关于旋转矩阵的左乘和右乘，可以看这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45632220/article/details/117735223">博客</a></p>
<p>这个函数的代码和解释如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将原始IMU数据：三轴加速度、三轴角速度、三轴角度，与雷达坐标系进行旋转对齐</span></span><br><span class="line"><span class="comment">+ 对齐之后输出的加速度、角速度、角度的x，y，z就变成雷达坐标系的x，y，z</span></span><br><span class="line"><span class="comment">+ 这里的特殊之处在于允许IMU的加速度、角速度与角度的输出是两个不同的坐标系。但在算法中，角度的输出除了用来做第一帧的初始化和加权融合，似乎没有其他作用</span></span><br><span class="line"><span class="comment">+ 这里是将IMU的三个轴与雷达的三个轴在旋转上做对齐，不能加上平移</span></span><br><span class="line"><span class="comment">+ 对向量做坐标系变换，对多个变换的复合应该是右乘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sensor_msgs::<span class="function">msg::Imu <span class="title">imuConverter</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::Imu&amp; imu_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sensor_msgs::msg::Imu imu_out = imu_in;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对加速度向量做坐标系变换，注意这里要理解成坐标系变换，也就是同一个加速度在IMU坐标系和Lidar坐标系的不同表达。不能想象成对加速度做旋转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">acc</span><span class="params">(imu_in.linear_acceleration.x, imu_in.linear_acceleration.y, imu_in.linear_acceleration.z)</span></span>;</span><br><span class="line">    acc = extRot * acc;</span><br><span class="line">    imu_out.linear_acceleration.x = acc.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.linear_acceleration.y = acc.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.linear_acceleration.z = acc.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角速度做坐标系变换。将IMU坐标系下的向量变换到雷达坐标系。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">gyr</span><span class="params">(imu_in.angular_velocity.x, imu_in.angular_velocity.y, imu_in.angular_velocity.z)</span></span>;</span><br><span class="line">    gyr = extRot * gyr;</span><br><span class="line">    imu_out.angular_velocity.x = gyr.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.angular_velocity.y = gyr.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.angular_velocity.z = gyr.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角度做坐标系变换。</span></span><br><span class="line"><span class="comment">    + q_from是IMU在全局坐标系下的位姿，q_from: transformation_from_map_to_imu</span></span><br><span class="line"><span class="comment">    + extQRPY如果与extRot对应的话应该是lidar到imu的变换：transformation_from_lidar_to_imu</span></span><br><span class="line"><span class="comment">    + q_final是将雷达点云从雷达坐标系转换到map坐标系的变换，也是：transformation_from_map_to_lidar -&gt; pcd_in_map = q_final * pcd_in_lidar</span></span><br><span class="line"><span class="comment">    + 这里原代码是q_final = q_from * extQRPY；似乎有点问题，还是按照我的推导修改成q_final = q_from * extQRPT.inverse()；由于这里的extQRPY是</span></span><br><span class="line"><span class="comment">    + 直接从配置文件里面读取的，所以这里加不加逆只需要在配置文件里改就行。认为这里有问题的假设是认为extQRPY和extRot的坐标系关系的定义是一致的，也就是</span></span><br><span class="line"><span class="comment">    + 将imu坐标系下的向量转换到雷达坐标系下。如果作者对这两者的定义刚好是相反的，那这里就没有问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Quaterniond <span class="title">q_from</span><span class="params">(imu_in.orientation.w, imu_in.orientation.x, imu_in.orientation.y, imu_in.orientation.z)</span></span>;</span><br><span class="line">    Eigen::Quaterniond q_final = q_from * extQRPY.<span class="built_in">inverse</span>();</span><br><span class="line">    imu_out.orientation.x = q_final.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.orientation.y = q_final.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.orientation.z = q_final.<span class="built_in">z</span>();</span><br><span class="line">    imu_out.orientation.w = q_final.<span class="built_in">w</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sqrt</span>(q_final.<span class="built_in">x</span>()*q_final.<span class="built_in">x</span>() + q_final.<span class="built_in">y</span>()*q_final.<span class="built_in">y</span>() + q_final.<span class="built_in">z</span>()*q_final.<span class="built_in">z</span>() + q_final.<span class="built_in">w</span>()*q_final.<span class="built_in">w</span>()) &lt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Invalid quaternion, please use a 9-axis IMU!&quot;</span>);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imu_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="qosquality-of-service">QoS:Quality of Service</h2>
<p>关于ROS2中<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html">QoS</a>的基本介绍，参考官方文档学习。<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html">QoS</a>的设置中，有两个参数是最重要的。一个是<code>depth</code>，一个是<code>RELIABILITY</code>。<code>depth</code>可以简要理解成中间件DDS为这个消息预留的缓存队列长度。 <code>RELIABILITY</code>主要有两种选项<code>best_effort</code>和<code>reliable</code>，它们的关系类似<code>TCP</code>,<code>UDP</code>。<code>best_effort</code>不能保证每一个消息到到达接收端，但可以保持最好的实时信。<code>reliable</code>保证每一帧消息 都到达接收端，但是无法保证实时性。ROS2中专门为传感器预设了一个<a target="_blank" rel="noopener" href="https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1SensorDataQoS.html">SensorDataQoS</a>，里面采用的就是<code>best_effort</code> 的设置。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>设置了三种<code>QoS</code>，分别为：原始IMU数据、原始雷达数据、框架内部传输</p>
<ol type="1">
<li>原始IMU数据QoS</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始IMU数据的QOS，因为IMU数据较小，所以depth可以设成较大</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_imu&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">2000</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_imu = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_imu.history,</span><br><span class="line">      qos_profile_imu.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_imu);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>原始雷达数据QoS</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始雷达数据topic的QOS，主要是best_effort和depth起作用</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_lidar&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">5</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_lidar = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_lidar.history,</span><br><span class="line">      qos_profile_lidar.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_lidar);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>算法框架内部传输QoS</li>
</ol>
<p>算法框架内部要求有最高的实时性，并且由于传输中有很多点云类型的数据（较大），因此作者把<code>depth</code>设置为1 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 算法框架中默认的QOS，主要是depth=1和reliability=best_effort起作用。对于传输实时性有要求，不要求每个数据可接收的消息，一般</span></span><br><span class="line"><span class="comment">/// 设成best_effort。在ROS2中对于传感器数据，有一个内置的QOS叫rclcpp::SensorDataQoS()</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> qos = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile.history,</span><br><span class="line">      qos_profile.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile);</span><br></pre></td></tr></table></figure></p>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（三）总体流程认识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-16 19:38:59" itemprop="dateCreated datePublished" datetime="2023-03-16T19:38:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 22:37:19" itemprop="dateModified" datetime="2023-04-19T22:37:19+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（三）总体流程认识" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（三）总体流程认识" href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::152660a48ad07f280a45860dc663a523" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总体流程">总体流程</h2>
<p>话不多说，直接上干货。下图是整理出来的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>整体运行流程</p>
<figure>
<img src="./imgs/Design-Pipelines.png" alt="" /><figcaption>Simple-LIO-SAM整体运行流程图</figcaption>
</figure>
<h2 id="整体认识">整体认识</h2>
<p>所谓的紧耦合，笔者是这么理解的：IMU本身就可以积分出来一个位姿，连续帧的点云匹配也可以计算出一个位姿，如果两者分别进行，然后再做一个加权融合，那么就属于松耦合。而从上面的框架图也可以看出，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的融合框架整体呈现一个<code>圈</code>，每个环节都为下一个环节提供信息，最后一个环节又为第一个环节提供信息。同时，耦合之处还在于以下几点：</p>
<ol type="1">
<li>高频的IMU信息对激光雷达点云做了畸变矫正，做了畸变矫正后的点云被用来做匹配计算激光里程计</li>
<li>IMU的积分结果被用来当作该帧点云的初值，为点云匹配提供了较好的初始估计</li>
<li>雷达里程计的结果被用来计算IMU的偏差，同时也被用来持续纠正IMU里程计</li>
</ol>
<p>虽然<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架中还可以融合<code>GPS</code>信息，但是主要还是对雷达点云和IMU信息做融合，因此，可以认为输入是点云和IMU数据，输出是小车当前时刻的位姿，以及对历史时刻位姿的平滑。</p>
<ul>
<li><p>框架的入口是点云去畸变模块，主要的功能就是对激光雷达运动畸变做矫正，然后输出去完畸变的点云。</p></li>
<li><p>去完畸变的点云经过特征提取模块，提取出角特征点和平面特征点，被图优化模块中的点云匹配部分用来做点云匹配。</p></li>
<li><p>图优化模块利用去完畸变后的点云与历史帧构建的局部地图做匹配，得出较准确的里程计结果。同时利用图优化，加入回环检测因子，使得整体估计更为准确顺滑</p></li>
<li><p>IMU预积分模块从IMU和图优化模块接收数据，对IMU的原始数据做积分，得出每一帧点云的初始位姿，提供给图优化模块作为优化初始值。同时又从图优化模块拿出经过点云、图优化校正后的里程计结果校正本身的结果</p></li>
<li><p>坐标系发布主要是为了<code>RIVZ</code>显示中用的，主要就是将各种里程计结果转换成<code>TF</code>坐标关系发布出去。在原始<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中是与<code>imuPreintegration</code>放置在同一个文件</p></li>
</ul>
<h2 id="运动畸变矫正">运动畸变矫正</h2>
<p>对应博文：<a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></p>
<ul>
<li>为什么激光雷达有运动畸变？</li>
</ul>
<p>激光雷达通过发射高能量激光线束，计算激光线束往返时间，得到该激光线打到的物体的距离。以机械式激光雷达为例，雷达在统一时刻可以发送多条激光线（32、64、128），这多条激光线在垂直方向上可以扫到三维空间中垂直的一条线，激光雷达通过环绕一周的方式可以对360的空间做三维成像</p>
<figure>
<img src="./imgs/lidar.webp" alt="" /><figcaption>激光雷达成像原理图</figcaption>
</figure>
<p>由于激光雷达是通过激光线束环绕一周的方式成像一帧的点云，那么这一帧点云的点就是在不同的时间探测的。如果激光线束在环绕一周的过程中，激光雷达是在运动的，那么这一帧点云就由于激光雷达的运动而变得不准确，因此需要对其做运动畸变校正。</p>
<figure>
<img src="./imgs/livox_lidar_distortion.png" alt="" /><figcaption>livox_lidar_distortion_removal</figcaption>
</figure>
<p>（上面这幅图片引用自livox官网[Liovox_distortion_removal]）</p>
<p>激光雷达输出的每一帧点云<span class="math inline">\(P\)</span>，里面的每一个点<span class="math inline">\(p_i\)</span>，都有一个属性<span class="math inline">\(t_i\)</span>，记录了该点距离该帧点云起始时刻的时间间隔，也就是下面代码段里的<code>time</code>字段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection.cpp 49-60</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VelodynePointXYZIRT</span></span><br><span class="line">&#123;</span><br><span class="line">    PCL_ADD_POINT4D</span><br><span class="line">    PCL_ADD_INTENSITY;</span><br><span class="line">    <span class="type">uint16_t</span> ring;</span><br><span class="line">    <span class="type">float</span> time;</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">&#125; EIGEN_ALIGN16;</span><br><span class="line"><span class="built_in">POINT_CLOUD_REGISTER_POINT_STRUCT</span> (VelodynePointXYZIRT,</span><br><span class="line">    (<span class="type">float</span>, x, x) (<span class="type">float</span>, y, y) (<span class="type">float</span>, z, z) (<span class="type">float</span>, intensity, intensity)</span><br><span class="line">    (<span class="type">uint16_t</span>, ring, ring) (<span class="type">float</span>, time, time)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>由于IMU是非常高频的，因此我们可以得出该帧点云成像时间段内的激光雷达位移和旋转的变换，然后通过每一个点的时间<span class="math inline">\(t_i\)</span>，可以根据时间进行插值得出每一个点相对于起始点的转换关系<span class="math inline">\(T_i\)</span>。（注：LIOSAM里面是直接通过时间戳查找，而不是进行插值）。从而，我们就可以将每个点都转换到起始点的坐标系 <span class="math display">\[
p_i^0 = T_ip_i
\]</span></p>
<h2 id="点云特征提取">点云特征提取</h2>
<p>对应博文：<a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></p>
<p>激光里程计中一般会涉及到点云匹配，如果用原始点云进行匹配由于点数过多的关系，会导致耗时太长，因此<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的方法进行<code>边缘点</code>,<code>平面点</code>两类特征点的提取，后面点云匹配部分使用这两种特征点进行<code>高斯-牛顿法</code>求解出匹配关系。</p>
<p>这部分的代码相对简单，后面关于这个模块的详细内容会介绍，这里唯一要清楚的是，这里的点云特征点提取用的是每个点的曲率，选择曲率大的点作为边缘点，选择曲率小的点作为平面点。但是曲率的计算是用每个点周围的点到其平均距离作为近似。</p>
<h2 id="imu预积分模块">IMU预积分模块</h2>
<p>对应博文：<a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></p>
<p>这一个模块虽然从原理和实现上来说稍微有一点点复杂，但是从功能上简单来说只有一个功能，就是实时对<code>IMU原始数据</code>做处理（积分），得到每一个时刻的IMU里程计（也是6自由度位姿），然后该位姿被用来作为该帧点云的初始估计位姿，这个初始估计位姿会被用来作为点云匹配的初始估计。</p>
<h2 id="点云匹配及图优化">点云匹配及图优化</h2>
<p>对应博文：</p>
<p><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></p>
<p><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></p>
<p>这是整个框架最复杂的一个模块（也许是没有很好解耦？）。这个模块主要包含了以下几个功能：</p>
<ol type="1">
<li>点云匹配</li>
<li>回环检测</li>
<li>因子图构建及优化</li>
<li>根据关键帧信息构建全局地图</li>
</ol>
<p>具体内容会在后面的章节展开，这里应该要有几个感性认识：</p>
<ol type="1">
<li>一般点云精细匹配（比如ICP算法）需要有一个良好的初始值，这里的初始值可以理解成采用IMU预积分模块的输出。</li>
<li>点云匹配部分用的是沿用自LOAM-&gt;LeGO-LOAM的点云匹配算法，不是使用ICP。<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>也是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan">TixiaoShan</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>之前的一篇相关论文</li>
<li>回环检测根据里程计的x,y,z检索紧邻帧，然后通过ICP算法计算当前帧与近邻帧的转换关系</li>
<li>经过点云匹配后的位姿会经过图优化得出更平滑的位姿</li>
<li>地图和因子图的因子实际上是以关键帧的形态存在后端优化部分，关键帧的选取会比较稀疏，比如距离小与1米不会采用为关键帧。不采用为关键帧的点云会执行完点云匹配后就直接输出位姿。</li>
<li>在有新的回环因子加入因子图后，会进行多次因子图优化器的更新步骤，然后将所有历史关键帧的位姿都更新一遍</li>
<li>这个部分还支持<code>GPS里程计</code>的监听，并将<code>GPS里程计</code>也加入因子图进行优化</li>
</ol>
<h2 id="坐标系规定">坐标系规定</h2>
<h3 id="坐标系规定-1">坐标系规定</h3>
<p>原有的<code>urdf</code>文件加入了太多额外没必要的关节，导致<code>rviz</code>中<code>tf-tree</code>关系太过复杂。为了简化坐标系关系，但同时又维持坐标系关系标准化并且与<code>ROS</code>的规定相同（<code>ROS</code>中关于姿态估计的坐标系关系主要参考：<a target="_blank" rel="noopener" href="http://docs.ros.org/en/melodic/api/robot_localization/html/preparing_sensor_data.html">robot_localization_coordinate_system</a>，这里对项目中的坐标系关系做了一些简化修改。 根据robot_localization包的规定，所有姿态都要转到世界坐标系，通常是<code>map</code>或者<code>odom</code>坐标系。所有的twist数据，都要转到base_link坐标系下处理。</p>
<h3 id="simple-lio-sam坐标系说明">Simple-LIO-SAM坐标系说明</h3>
<ol type="1">
<li>根据REP资料，一般有4个坐标系<code>earth</code>,<code>map</code>,<code>odom</code>,<code>base_link</code>。由于在SLAM中一般没有引入地球坐标系。所以在这里只有后三个坐标系。 同时，如果是以起始点作为地图原点，<code>map</code>,<code>odom</code>两个坐标系是重合的关系。</li>
<li>另外，为了可以在Rivz显示原始点云信息，则也加入一个雷达坐标系。</li>
<li>为了让坐标系定义自洽，虽然在算法中没有直接用到，但是IMU加速度速度和角速度应该定义在IMU坐标系，因此引入IMU坐标系</li>
<li>为了让定义更为标准，这里保留<code>map</code>坐标系，虽然在SLAM中<code>map</code>,<code>odom</code>大部分情况是重叠的</li>
<li>因此，整个spl_lio_sam框架可以简化成5个坐标系：<code>map</code>, <code>odom</code>,<code>base_link</code>,<code>lidar_link</code>,<code>imu_link</code>坐标系。其中， <code>map</code>是地图原点，在建图时是起始点，在重定位模式时，是地图原点。<code>odom</code>是里程计坐标系；<code>base_link</code>是车辆自身坐标系。<code>lidar_link</code>坐标系是雷达坐标系， 在lio_sam中是与<code>base_link</code>坐标系对齐的，但是<code>lidar_link</code>字段会根据雷达型号不同，被修改。<code>imu_link</code>坐标系是IMU坐标系，配置文件中 有指明IMU坐标系到Lidar坐标系的转换关系。</li>
</ol>
<h3 id="坐标系关系的其他说明">坐标系关系的其他说明</h3>
<ol type="1">
<li>ROS的Message Header只有一个frame_id字段，表明这个数据是在哪个坐标系下的。</li>
<li>nav_msgs/Odometry中还有一个child_frame_id字段，nav_msgs/Odometry中的twist数据应该是在child_frame_id坐标系下的数据 &gt; The twist in this message should be specified in the coordinate frame given by the child_frame_id</li>
</ol>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">记一次解决rosbag2内存错误问题过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 18:28:01" itemprop="dateCreated datePublished" datetime="2023-03-15T18:28:01+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-14 16:36:35" itemprop="dateModified" datetime="2023-05-14T16:36:35+08:00">2023-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/ROS/" itemprop="url" rel="index"><span itemprop="name">ROS</span></a>
        </span>
    </span>

  
    <span id="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="记一次解决rosbag2内存错误问题过程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="记一次解决rosbag2内存错误问题过程" href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73e4783c1a71c1ae17cdb35318885253" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
</ul>
<h2 id="问题背景">问题背景</h2>
<p>由于工作需要，需要开发一个程序，根据记录的信息，从<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>保存的数据包根据打点的时间戳，提取出一段段单独的数据包。 为了存储空间考虑，保存时以及提取时都指定了使用<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#recording-with-compression">压缩的方式</a>进行存储。压缩器和压缩模式如下： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line"><span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>不仅有命令行工具，同时还开放API给开发者使用。<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>还提供了<code>convert</code>功能，可以对录下来的bagfile进行<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">二次提取</a>。因此开发这部分功能可以参考源码里面的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp">bag_rewriter.cpp</a></p>
<h2 id="开发环境">开发环境</h2>
<blockquote>
<p>ROS: ROS2-humble</p>
</blockquote>
<blockquote>
<p>OS: ubuntu 22.04</p>
</blockquote>
<blockquote>
<p>language: cpp17</p>
</blockquote>
<blockquote>
<p>rosbag2: 0.15.4-2jammy.20230118.031755</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p>完成上述数据提取功能后进行测试，发现提取的时候如果同时提取多个目标（构建多个writer，读取message后进行写操作，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L135">rosbag2源码参考部分</a>，并且都进行压缩的时候，会有<code>core dump</code>，错误信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corrupted size vs. prev_size</span><br><span class="line">[ros2run]: Aborted</span><br></pre></td></tr></table></figure></p>
<p>然而在其他情况：1.同时提取多个目标，但是不进行压缩；2.提取一个目标，进行压缩；的时候，程序都可以正常运行</p>
<p>为了确保不是自己编写的程序导致的问题，又使用<code>rosbag2 cli</code>进行类似的尝试。根据<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">converting-bags</a>的说明，我使用下面的<code>output_options.yaml</code>进行数据转换： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p>然后使用如下命令进行提取 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<p>果不其然，直接使用<code>rosbag2</code>的包也会有<code>core</code>问题，不过报的信息会有区别，不同次运行报的信息还不一样，主要是类似下面这样： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc(): unsorted double linked list corrupted</span><br><span class="line">free(): corrupted unsorted chunks</span><br><span class="line">corrupted double-linked list</span><br></pre></td></tr></table></figure></p>
<h2 id="问题复现">问题复现</h2>
<p>简单起见可以直接使用<code>rosbag2 cli</code>复现这个问题 1. 准备一个ros2的bag包 2. 新建一个配置文件命名为：<code>output_options.yaml</code>，并填入下面内容： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure> 3. 执行数据转换命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="问题定位">问题定位</h2>
<h3 id="增加日志">增加日志</h3>
<p>由于已经确认不是自己写的程序的问题，所以其实可以跳过这一步</p>
<h3 id="gdb检查">gdb检查</h3>
<p>cpp程序排查还是需要上gdb，不要自己瞎折腾瞎改代码。<a href="#appendA">文末记录</a>如何在<code>ubuntu</code>上生成<code>core文件</code>。 运行一次程序，生成<code>core文件</code>后使用gdb检查错误堆栈 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ros_ws/install/package/lib/package/excutable /path/to/corefile</span><br><span class="line"></span><br><span class="line">bt  <span class="comment"># gdb命令，打印错误堆栈</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到如下的报错信息</p>
<figure>
<img src="./imgs/backtraces.png" alt="" /><figcaption>backtraces</figcaption>
</figure>
<p>虽然是在子线程中出错，但是大概也能看到是在<code>rosbag2_compression::SequentialCompressonWriter::compression_thread_fn()</code>函数中出错。 这也符合了现象，只在进行压缩的时候会出错。</p>
<p>同时，从错误堆栈里可以看出应该是<code>rosbag2_compression_zstd::ZstdCompressor</code>在进行压缩处理的时候调用<code>rcutils_uint8_array_resize</code>函数出错。</p>
<h3 id="对比不同的writer">对比不同的writer</h3>
<p>由于在进行多个<code>writers</code>写数据，但是不执行压缩的时候并没有相关问题发生，所以可以对比一下普通的<code>writer</code>和<code>SequentialCompressonWriter</code>在写函数中的区别</p>
<h4 id="普通的writer即rosbag2_cppsequentialwriter">普通的writer，即rosbag2_cpp::SequentialWriter</h4>
<p>普通的<code>writer</code>，即<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp">rosbag2_cpp::SequentialWriter</a>中，<code>void SequentialWriter::write(std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>函数比较简单，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp#L328-L337">核心代码</a>是这几行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (storage_options_.max_cache_size == <span class="number">0u</span>) &#123;</span><br><span class="line"><span class="comment">// If cache size is set to zero, we write to storage directly</span></span><br><span class="line">storage_-&gt;<span class="built_in">write</span>(converted_msg);</span><br><span class="line">++topic_information-&gt;message_count;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Otherwise, use cache buffer</span></span><br><span class="line">message_cache_-&gt;<span class="built_in">push</span>(converted_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>bag_rewrite</code>在调用<code>writer</code>的时候，<code>max_cache_size</code>始终<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L191">设置为0</a>，因此执行的是<code>if</code>分支，也就是直接调用底层的数据库封装类直接写入硬盘。</p>
<h4 id="带压缩的writer即rosbag2_compressionsequentialcompressionwriter">带压缩的writer即rosbag2_compression::SequentialCompressionWriter</h4>
<p>带压缩功能的writer这部分的逻辑增加了一个单独线程做压缩处理，函数<code>void SequentialCompressionWriter::write(   std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>的核心部分主要是<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L317-L321">这几行</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(compressor_queue_mutex_)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (compressor_message_queue_.<span class="built_in">size</span>() &gt; compression_options_.compression_queue_size) &#123;</span><br><span class="line">    compressor_message_queue_.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">compressor_message_queue_.<span class="built_in">push</span>(message);</span><br><span class="line">compressor_condition_.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>compressor_message_queue_</code>在另一个线程，即函数<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L63">void SequentialCompressionWriter::compression_thread_fn()</a>被处理。 这里面有一个对传入的<code>SerializedMessageSharedPtr</code>对象中的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L96">内存直接进行处理</a></p>
<h4 id="重新查看调用api的代码">重新查看调用API的代码</h4>
<p>调用<code>rosbag2 API</code>进行数据写操作的主要过程如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create rosbag2_storage::StorageOptions</span></span><br><span class="line">rosbag2_storage::StorageOptions storageOptions;</span><br><span class="line"><span class="comment">// create reader</span></span><br><span class="line"><span class="keyword">auto</span> inputReader = rosbag2_transport::ReaderWriterFactory::<span class="built_in">make_reader</span>(storageOptions);</span><br><span class="line"><span class="comment">// open file</span></span><br><span class="line">inputReader-&gt;<span class="built_in">open</span>(storageOptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create multiplt writers</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
<p><strong>可以看到，我们从<code>reader</code>中拿到的<code>SerializedBagMessage</code>是以共享指针的形式使用，当我们把共享指针传给不同的<code>writer</code>时，不同的<code>writer</code>内部同时对同一块内存进行数据压缩处理，因此也就导致了不同线程操作同一块地址空间的错误。</strong></p>
<h2 id="修复">修复</h2>
<p>由于不想更改<code>rosbag2</code>的代码，因此想办法在调用层解决。既然问题共享指针指向的内存被不同线程同时处理，那么我们就在每一次调用<code>writer-&gt;write(nextMsg)</code>的时候对<code>nextMsg</code>执行一次深拷贝，让不同的<code>writer</code>操作不同内存即可。 这里比较复杂的是<code>SerializedBagMessage</code>中使用一个指向<code>rcutils_uint8_array_t</code>的指针对内存进行管理。而<code>rcutils_uint8_array_t</code>里面又使用一个裸<code>uint8_t*</code>指针指向管理的内存。同时<code>rcutils</code>的文档不够详细，也没有提供函数对<code>rcutils_uint8_array_t</code>执行深拷贝操作。不过只要能够明白上面的内存管理关系，修复起来不太困难，关于<code>rcutils_uint8_array_t</code>的操作可以参考<code>rosbag2</code>里面的代码，最终修复的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">...create reader &amp;&amp; writer</span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg_copy = std::<span class="built_in">make_shared</span>&lt;rosbag2_storage::SerializedBagMessage&gt;();</span><br><span class="line">        <span class="comment">// 新建rcutils_uint8_array_t需要按照下面这样的操作</span></span><br><span class="line">        nextMsg_copy-&gt;serialized_data = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">rcutils_uint8_array_t</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">rcutils_uint8_array_t</span>,</span><br><span class="line">        [](<span class="type">rcutils_uint8_array_t</span> * msg) &#123;</span><br><span class="line">        <span class="keyword">auto</span> fini_return = <span class="built_in">rcutils_uint8_array_fini</span>(msg);</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">        <span class="keyword">if</span> (fini_return != RCUTILS_RET_OK) &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR_STREAM</span>(</span><br><span class="line">            rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rosbag2_cpp&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Failed to destroy serialized message: &quot;</span> &lt;&lt; <span class="built_in">rcutils_get_error_string</span>().str);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建后需要执行内存初始化</span></span><br><span class="line">        <span class="type">rcutils_allocator_t</span> allocator = <span class="built_in">rcutils_get_default_allocator</span>();</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">rcutils_uint8_array_init</span>(</span><br><span class="line">            nextMsg_copy-&gt;serialized_data.<span class="built_in">get</span>(),</span><br><span class="line">            nextMsg-&gt;serialized_data-&gt;buffer_capacity,</span><br><span class="line">            &amp;allocator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span> (ret != RCUTILS_RET_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Init arrry failed with ret code = %d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制内容</span></span><br><span class="line">        nextMsg_copy-&gt;topic_name = nextMsg-&gt;topic_name;</span><br><span class="line">        nextMsg_copy-&gt;time_stamp = nextMsg-&gt;time_stamp;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_capacity = nextMsg-&gt;serialized_data-&gt;buffer_capacity;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_length = nextMsg-&gt;serialized_data-&gt;buffer_length;</span><br><span class="line">        <span class="comment">// 复制内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)nextMsg_copy-&gt;serialized_data-&gt;buffer,</span><br><span class="line">                (<span class="type">void</span>*)nextMsg-&gt;serialized_data-&gt;buffer, nextMsg-&gt;serialized_data-&gt;buffer_length);</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg_copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="issue-提交及-pr">Issue 提交及 PR</h2>
<p>这个bug同时提交到<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>仓库<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/issues/1262">issues1262中</a>。根据issue的反馈，这个bug在最新的rolling分支已经被修复。不过rolling分支的API与humble 的API差别较大，因此没法直接合并到humble分支中，因此在humble分支这个bug还没有被修复。</p>
<h3 id="pr过程">PR过程</h3>
<ol type="1">
<li>fork仓库</li>
<li>克隆fork后的仓库到本地</li>
<li>从humble分支切出bug_fix分支</li>
<li>先用原始代码编译并执行test</li>
<li>先新增一个单元测试用例，并执行编译测试，原始代码无法在新的单元测试下通过</li>
<li>修复代码</li>
<li>编译并测试，通过所有测试用例</li>
</ol>
<p>PS:在修复过程中一开始总是无法通过测试用例，提示无法生成测试结果文件。后面查看发现运行过程中会<code>core dump</code>。经过<code>gdb</code>调试（为了调试能够输出最多的<code>core dump</code>信息，需要<code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug</code>）后发现，是因为声明了共享指针之后没有对齐进行初始化，后面又调用了该指针的成员变量。哎，还是太菜呀～</p>
<p>具体的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/pull/1331#issue-1708860338">PR</a></p>
<h2 id="附录aubuntu-core文件生成">附录A：ubuntu core文件生成</h2>
<div id="appendA">

</div>
<ol type="1">
<li>ubuntu有一个默认的错误搜集系统apport，必须要关掉之后才能生成core文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service apport status</span><br><span class="line">sudo service apport stop</span><br><span class="line">sudo systemctl apport disble  <span class="comment"># 似乎无法关闭开机启动，每次需要的时候需要手工确认是否关闭</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>设置core文件大小，默认是0，所以不会生成core文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c  <span class="comment"># 若结果是0，则不会生成core文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 不限制core文件大小</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 选择当前使用的终端</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>设置corefile路径（注意，路径必须普通用户可读！）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /corefile</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /corefile</span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><code>CMakeLists.txt加上``Debug模式</code>下不进行编译器优化</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In CMakeLists.txt</span></span><br><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;<span class="variable">$ENV</span>&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb -Wno-unused-parameter&quot;</span>)  </span><br></pre></td></tr></table></figure>
<p>注意在编译<code>ROS2</code>包的时候要指明<code>Debug</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select package_name --cmake-args -DCMAKE_BUILD_TYPE=Debug</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（二）环境搭建与运行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-14 19:49:06" itemprop="dateCreated datePublished" datetime="2023-03-14T19:49:06+08:00">2023-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 22:23:01" itemprop="dateModified" datetime="2023-04-19T22:23:01+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（二）环境搭建与运行" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（二）环境搭建与运行" href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::b824fa070f036b85c958cacd75daa48f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="运行环境搭建">运行环境搭建</h2>
<p>本项目提供基于<code>ROS2-humble</code>的镜像，并提供脚本可直接在镜像中启动可视化程序。 docker镜像部署见下文。</p>
<h3 id="数据">数据</h3>
<p>本项目同时提供转为<code>rosbag2</code>格式的数据包，<a href="">下载地址:暂时未上传</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATA_DIR=/path/to/download/ros2bag/dir</span><br></pre></td></tr></table></figure>
<p>本项目中默认的配置文件<code>params_default.yaml</code>可以直接运行下面的数据： - park_dataset - walking_dataset - garden_dataset</p>
<h3 id="环境部署">环境部署</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zeal-up/Simple-LIO-SAM.git</span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_run.sh -h  <span class="comment"># show help message</span></span><br><span class="line">./docker_run.sh -c /path/to/code/repo -d <span class="variable">$DATA_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./docker_into.sh  # enter the container next time</span></span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令在镜像中执行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws/</span><br><span class="line"><span class="built_in">mkdir</span> src &amp;&amp; <span class="built_in">cd</span> src &amp;&amp;<span class="built_in">ln</span> -s /home/splsam/codes ./</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">colcon build --packages-select spl_lio_sam</span><br></pre></td></tr></table></figure>
<h3 id="运行">运行</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker镜像下运行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws</span><br><span class="line"><span class="built_in">source</span> ./install/setup.bash</span><br><span class="line">ros2 launch spl_lio_sam run.launch.py </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开终端</span></span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"><span class="built_in">cd</span> data/ros2/</span><br><span class="line">ros2 bag play ./park_dataset/ --topics /points_raw /imu_raw</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行时画面：</p>
<img src="./imgs/runtime.gif" title="fig:" alt="Simple-LIO-SAM运行时画面" />
<center>
Simple-LIO-SAM运行时画面
</center>
<h2 id="开发环境搭建">开发环境搭建</h2>
<p>由于本项目作者在使用<code>vscode</code>开发<code>c++</code>时经常会遇到无法快捷跳转问题（其实笔者发现有很多人在使用vscode开发时都会有这个问题）， 因此一并把解决方案写入项目中。</p>
<h3 id="vscode-cpp函数快捷跳转">vscode Cpp函数快捷跳转</h3>
<ol type="1">
<li>安装cpp扩展 vscode侧边栏进入扩展选项（ctrl+shift+x)，搜索<code>c++</code>，安装<code>C/C++ Extension Pack</code></li>
<li>打开项目 &gt; File-&gt;Open Folder</li>
<li>保存为工作区 &gt; File-&gt;Save Workspace as 选择目标目录及文件（默认以<code>.code-workspace</code>结尾）</li>
<li>打开刚才保存的工作区文件 &gt; File-&gt;Open File 选择刚才打开的工作区文件</li>
<li>对工作区添加<code>c++</code>库检索路径 在刚才打开的工作区文件中，参考以下格式编辑</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;folders&quot;:</span> [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;path&quot;:</span> <span class="string">&quot;../Simple-LIO-SAM&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.includePath&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/**&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/c++/9/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/8/include/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/include/**&quot;</span>,</span><br><span class="line"></span><br><span class="line">			<span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">//</span> <span class="string">重点！！这里的路径要设置为ros2工作空间下spl_lio_sam编译出来的头文件</span></span><br><span class="line">			<span class="string">&quot;/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam&quot;</span></span><br><span class="line"></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;C_Cpp.files.exclude&quot;:</span> &#123;</span><br><span class="line">			<span class="string">&quot;**/.vscode&quot;</span><span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">			<span class="string">&quot;**/.vs&quot;</span><span class="string">:</span> <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cStandard&quot;:</span> <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cppStandard&quot;:</span> <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;python.analysis.include&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.autoComplete.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.analysis.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对工作区文件的解释">对工作区文件的解释</h3>
<p>其实主要起作用的是工作区文件中<code>settings-&gt;C_Cpp.default.includePath</code>字段内容，vscode的cpp扩展会读取该工作空间文件下 的这个字段，并将里面的路径进行解析加到头文件解析路径中。</p>
<p>这里有两个路径要注意的</p>
<ol type="1">
<li><code>"$&#123;workspaceFolder&#125;/include"</code>，也就是Simple-LIO-SAM仓库下的include路径</li>
<li><code>"/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam"</code>，这个要设置成你的ros工作空间对应的路径</li>
</ol>
<p>另外，如果发现自己路径设置完成，但是有些函数还提示下划线，要看看是不是那些函数是<code>c++17</code>或者更高的标准才支持的特性，在上面的配置文件中 设置c++/c标准为17</p>
<h3 id="其余注意">其余注意</h3>
<ol type="1">
<li>尽量不要用<code>/path/**</code>的格式添加include路径，虽然看起来很省事，但会影响检索效率</li>
<li>刚设置完路径需要等待vscode检索构建数据库，在vscode右下方状态条会提示正在进行检索</li>
<li>上面配置文件中<code>"python.analysis.extraPaths","python.autoComplete.extraPaths","python.analysis.include"</code>是设置python语法提示器的 库检索路径，不同的python提示器插件会使用不同的路径。</li>
</ol>
<h2 id="reference">Reference</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIO-SAM</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258">LIO-SAM paper</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">This Project</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note">LIO-SAM-note</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a></li>
</ol>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/lio_sam/intro/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（一）项目简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 19:45:58" itemprop="dateCreated datePublished" datetime="2023-03-13T19:45:58+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 22:29:16" itemprop="dateModified" datetime="2023-04-18T22:29:16+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/13/lio_sam/intro/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（一）项目简介" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（一）项目简介" href="/2023/03/13/lio_sam/intro/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::d227db67a0df8ebb129db6bbfad2da40" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="liosam介绍">LIOSAM介绍</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>（Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping），紧耦合激光惯性里程计方法。 作者<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan">TixiaoShan</a>是SLAM届大神，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>之前发表过<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>之后发布了<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2104.10831">LVI-SAM</a>——在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>基础上又加入了语义定位因子。 网上关于<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的解读已经有很多，这里不会进行太过详细的复述，具体的内容解析会放在后面系列文章慢慢仔细阐述。</p>
<p>简单来说，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>整体的框架与其他方法区别在与：</p>
<ol type="1">
<li>使用因子图作为后端优化框架，将IMU预积分与雷达点云匹配及回环检测等紧耦合</li>
<li>使用当前帧-局部地图匹配而不是对全局地图匹配来加速点云匹配速度</li>
<li>基于位置关系选择回环帧，并使用点云匹配计算回环因子</li>
<li>使用高频IMU并进行简单积分对点云做运动畸变校正</li>
</ol>
<p>另外，LIOSAM作者的工程功底很好，LIOSAM代码库被github上很多SLAM开源项目作为code base</p>
<h2 id="本项目目的">本项目目的</h2>
<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>源代码虽然不能说庞大，甚至可以说简单，因为整个代码库主要只要5个文件。 <img src="./imgs/org_files.png" alt="LIOSAM原代码src目录" />
<center>
LIOSAM原代码src目录
</center>
<p>但是原代码里面每个模块都通过ROS的topic与其他模块有紧密的联系，且非常多的冗余代码和topic，这导致了 整个的流程对新手十分不友好，下图是LIOSAM原本运行时的<code>rqt_graph</code></p>
<img src="./imgs/org_rqtgraph.png" title="fig:" alt="原始LIOSAM运行时rqt_graph" />
<center>
原始LIOSAM运行时rqt_graph
</center>
<p>第二个复杂之处在于<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架涉及到的知识点和工具较多，至少要熟悉<code>ROS,gtsam,pcl</code>几个库，算法层面需要熟悉<code>点云匹配、IMU积分、因子图、三维转换</code>等。 对于熟悉SLAM的人来说可能较为简单上手，但是对于新入门的人来说则一开始会一头雾水。</p>
<p>基于上述这些原因，笔者基于<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>改进，完成了<a href="Simple-LIO-SAM">SPL-LIO-SAM</a>项目，希望能够以最大幅度帮助初学者理解<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架及里面的算法细节。</p>
<h2 id="适用人群">适用人群</h2>
<p>如果你是SLAM大牛，那本项目可能对你没有用处。如果你是以下人群之一，笔者相信本项目可以让你受益匪浅。</p>
<ol type="1">
<li>SLAM初学者。本项目对代码注释和讲解可以说细致到令人发指，因此十分适合初学者学习。</li>
<li>接触过SLAM，希望将SLAM算法工程化，并加以实现。</li>
<li>SLAM学习者或工程师，但是希望对<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>,<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2104.10831">LVI-SAM</a>,<a target="_blank" rel="noopener" href="https://github.com/laboshinl/loam_velodyne">loam_velodyne</a>其中任何一种算法进行精细学习</li>
</ol>
<h2 id="simple-lio-sam项目特点与liosam区别">Simple-LIO-SAM项目特点/与LIOSAM区别</h2>
<h3 id="基于最新的ros2发行版humble实现">基于最新的ROS2发行版humble实现</h3>
<p>虽然<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>源码中有一个ros2分支，但该分支的维护者并不是原作者，而且已经长时间没有人维护，且该分支存在一些bug没有被修复。为了能够在进行本项目的学习过程中 熟悉最新的ROS2框架，笔者在LIOSAM的ros2分支基础上，修复了存在的bug，同时将功能较为独立的<code>Transformfusion</code>类抽取成独立的类。</p>
<h3 id="开箱即用docker开发环境">开箱即用docker开发环境</h3>
<p>为了便于上手及部署，笔者同时准备了适配的docker镜像供学习者使用。</p>
<h3 id="简化">简化</h3>
<h4 id="话题发布的简化">话题发布的简化</h4>
<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>原始代码中有很多中间结果的发布，这些中间结果可以用来可视化及调试程序，但是对于学习者和开发者而言不仅意义不大，而且会在初始学习源码阶段误导学习者。 本项目在话题发布上进行<code>大幅度简化</code>，简化后的设计如下： <img src="./imgs/Design-Node%26%26Topics.png" alt="Simple-LIO-SAM节点及话题设计" />
<center>
Simple-LIO-SAM节点及话题设计
</center>
简化后运行时的<code>rqt_graph</code>: <img src="./imgs/spl_liosam_rosgraph.png" alt="Simple-LIO-SAM的rqt_grpah" />
<center>
Simple-LIO-SAM的rqt_grpah
</center>
<h4 id="坐标系简化">坐标系简化</h4>
<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中实用的坐标系并不复杂，但是作者提供的<code>urdf</code>包含了太多为了兼容性考虑的坐标系，这些坐标系对于实际运行和理解并没有用。因此，本项目基于ROS对坐标系的约束，将 坐标系关系树简化为如下： <img src="./imgs/Design-CoordinateSystem.png" alt="Simple-LIO-SAM的坐标系关系" />
<center>
Simple-LIO-SAM的坐标系关系
</center>
<h3 id="保留算法及定义完整性">保留算法及定义完整性</h3>
<p>虽然本项目去除了很多非必要topic，同时对于一些非必要代码也进行了简化，但对一些学习算法有帮助的细节依旧保留。比如激光里程计在发布的时候有<code>mapping/odometry</code>和<code>mapping/odometry_incremental</code>两个话题，这两个话题虽然类似但是背后却有很不同的含义，但同时两者合一又不影响算法的运行。因此采取的做法时在代码中保留这部分代码，同时加以解释，但发布时只发布其中一个话题。</p>
<h3 id="完善的注释及流程图">完善的注释及流程图</h3>
网上对<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>源码的注释其实并不少，比如<a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note">LIO-SAM-note</a>和<a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a>，还有一些blog也对源码做了解释，但是都不太完美，同时缺少项目性的组织。本项目借鉴了一些开源项目的注释，并加以完善，可以说，本项目是目前对<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>注释最完善的开源项目。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">Simple-LIO-SAM代码</a> <img src="./imgs/comments.png" alt="Simple-LIO-SAM部分注释图" />
<center>
Simple-LIO-SAM部分注释图
</center>
为了最为清晰的展示<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>算法不同模块的流程，该项目还对各个模块流程进行梳理，建立了完善的流程图设计 <img src="./imgs/Design-Pipelines.png" alt="算法Pipeline梳理" />
<center>
算法Pipeline梳理
</center>
<img src="./imgs/Design-imageProjection_top0.png" title="fig:" alt="点云去畸变流程图-top" />
<center>
点云去畸变流程图-top
</center>
<img src="./imgs/Design-imageProjection_top1.png" title="fig:" alt="点云去畸变流程图-细节示例1" />
<center>
点云去畸变流程图-细节示例
</center>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">FastDDS关键概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 18:02:43" itemprop="dateCreated datePublished" datetime="2023-03-13T18:02:43+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/DDS/" itemprop="url" rel="index"><span itemprop="name">DDS</span></a>
        </span>
    </span>

  
    <span id="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/" class="post-meta-item leancloud_visitors" data-flag-title="FastDDS关键概念" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="FastDDS关键概念" href="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73f7a0f706535d55ad531611b3af6c03" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="架构">架构</h1>
<p>架构图 <img src="./imgs/fast-dds-architecture.svg" alt="架构图" /></p>
<p>域（Domain）的概念 <img src="imgs/domain_concept.jpg" alt="Domain" /> <img src="imgs/dds_domain.svg" alt="Domain" /></p>
<p>数据中心收发模型（DCPS:Data Centric Publisher and Subscriber) <img src="imgs/DataCentricModel.png" alt="DCPS" /></p>
<h1 id="why-need-a-publisher-and-subscriber">Why need a publisher and subscriber</h1>
<blockquote>
<p>These publishers and subscribers don’t need to know about each other ahead of time; they discover each other dynamically at runtime. The data they share is described by a “topic,” and publishers and subscribers send and receive data only for the topics they are interested in. In this pattern, many publishers may publish the same topic, and many subscribers may subscribe to the same topic. Subscribers receive data from all of the publishers that they share a topic with. Publishers send data directly to subscribers, with no need for a broker or centralized application to mediate communications. (https://community.rti.com/static/documentation/connext-dds/6.0.1/doc/manuals/connext_dds/getting_started/cpp11/intro_pubsub_cpp.html)</p>
</blockquote>
<h1 id="notes">Notes</h1>
<p>Publisher 和 Subscriber 负责生成DataWriter&amp;&amp;DataReader，一个Publisher[Subscriber]可以绑定多个DataWriter[DataReader]。每一个DataWriter[DataReader]都会绑定到一个topic，同时可以指定对应的回调函数DataWriterListener[DataReaderListener]</p>
<h1 id="数据监控fastdds-monitor">数据监控——FastDDS Monitor</h1>
<p><a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/getting_started/tutorial.html">FastDDS Monitor Tutorial</a> ## 原理 FastDDS库有一个内嵌的Participant，叫做Statistic Participant，包含在FastDDS的Statistic Module中。该模块不是默认编译的，因此需要在编译FastDDS的时候指明CMake选项。 实际上是用户开发应用时，在构建<strong>DomainParticipants</strong>阶段，如果通过某种方式指明了要将数据统计信息往外发送，则Statistic Module模块就会自动收集信息，然后往固定的topic发送监控数据。FastDDS Monitor通过这些内嵌的topic，可以监控数据的收发情况。</p>
<p><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/statistics/statistics.html">如何打开Statistics DataWriters</a> <a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/getting_started/tutorial.html">如何使用FastDDS Monitor</a></p>
<p><strong>注意，如果编译FastDDS的时候打开Statistics Module模块，由于会发送额外的信息，所以会损失性能</strong> &gt; Consequently, by default, Fast DDS does not compile this module because it may entail affecting the application’s performance.(https://fast-dds.docs.eprosima.com/en/latest/fastdds/statistics/statistics.html)</p>
<figure>
<img src="imgs/monitor.jpg" alt="" /><figcaption>数据监控窗口</figcaption>
</figure>
<h1 id="record-replay">Record &amp;&amp; Replay</h1>
<blockquote>
<p>rosbag2 is a ROS 2 application that can be used to capture DDS messages and store them on an SQLite database which allows inspecting and replaying said messages at a later time.</p>
</blockquote>
<ol type="1">
<li>rosbag2可以将在Topic中传送的数据以SQLite的形式保存</li>
<li>FastDDS没有自己的数据保存和回放工具，官方说明用的是ROS2的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2">rosbag2</a>包。要使用该包来记录和回放FastDDS的数据需要安装ROS2环境和rosbag2</li>
<li>由于rosbag2是用来保存ros2的message的，并不是FastDDS的官方工具，因此如果要用rosbag2回放，需要做较多的配置</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/use_cases/rosbag_capture/rosbag_capture.html#rosbag-capture">使用rosbag-capture</a></p>
<h1 id="limitations">Limitations</h1>
<ol type="1">
<li>没有进程管理和启动工具。ROS/Apollo/XPilot都有属于自己的进程调度系统，可以直接按指定顺序启动多个进程并执行相关调度。</li>
<li>似乎无法实现像ROS的Service这种类似RPC的功能</li>
</ol>
<h1 id="reference-resources-link">Reference &amp;&amp; Resources link</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/eProsima/Fast-DDS">FastDDS Github</a></li>
<li><a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/installation/linux.html">FastDDS Monitor Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/use_cases/rosbag_capture/rosbag_capture.html#rosbag-capture">使用rosbag-capture</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/eProsima/Fast-DDS-python.git">Fast-DDS-Python</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/" class="post-title-link" itemprop="url">经久不衰的卡尔曼滤波器-基础知识及公式推导</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 17:59:59" itemprop="dateCreated datePublished" datetime="2023-03-13T17:59:59+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/%E6%BB%A4%E6%B3%A2/" itemprop="url" rel="index"><span itemprop="name">滤波</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/%E6%BB%A4%E6%B3%A2/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" itemprop="url" rel="index"><span itemprop="name">卡尔曼滤波</span></a>
        </span>
    </span>

  
    <span id="/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/" class="post-meta-item leancloud_visitors" data-flag-title="经久不衰的卡尔曼滤波器-基础知识及公式推导" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="经久不衰的卡尔曼滤波器-基础知识及公式推导" href="/2023/03/13/kalman_filter/%E7%BB%8F%E4%B9%85%E4%B8%8D%E8%A1%B0%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::485da1f1f8066e1c77d786731c1e5117" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一卡尔曼滤波器的应用场景">一、卡尔曼滤波器的应用场景</h1>
<p>卡尔曼滤波器之前被广泛用来做动态系统的状态估计、预测。主要的目的就是用来从带噪声的观测量，比如各种传感器的观测（IMU、GPS、里程计等）估计出最优的系统状态（state）。不过要明确强调的是，由于测量都带有噪声，也就是随机性，所以真正准确的状态是无法获知的。</p>
<p>最小二乘法可以从一长串的测量值回归出一个最为匹配的模型。卡尔曼滤波相比于最小二乘法，采用了一种递归的计算方式，也就是每一时刻只需要保存上一时刻的状态。因此可以被用来处理实时任务。</p>
<p>虽然卡尔曼滤波器从美国阿波罗登月计划到如今已有几十年，且目前有更先进的因子图（Factor Graph）算法，但是在很多领域依旧可以看到卡尔曼滤波器的身影，特别是在自动驾驶的各个模块，比如：从IMU的数据（三轴加速度，三轴角速度）计算出运动物体的当前位置。</p>
<h1 id="二卡尔曼滤波器的两个步骤宏观认识">二、卡尔曼滤波器的两个步骤——宏观认识</h1>
<p>卡尔曼滤波包含两个步骤</p>
<ol type="1">
<li>预测（prediction）—— Dynamic model</li>
<li>更新（correction/measurment update）—— Observation model</li>
</ol>
<p>所谓<strong>预测</strong>，就是用一个数学模型，根据当前的传感器输入，直接计算此时系统的状态。可以理解为一个方程的计算就行。</p>
<p>所谓的<strong>更新</strong>，就是在某些时刻或者每一时刻，获取一些系统的状态输入（可以同样是传感器的值），甚至是<strong>预测</strong>阶段中同样的传感器的值，将其当作真值，我们将这个值叫做<strong>测量值</strong>。比较此刻<strong>预测</strong>的系统状态和<strong>测量</strong>的系统状态，对<strong>预测</strong>出的系统状态进行修正，因此也叫<strong>测量更新</strong>（measurment update）。</p>
<figure>
<img src="./imgs/framework.png" alt="" /><figcaption>framework</figcaption>
</figure>
<h1 id="三卡尔曼滤波的几大概念">三、卡尔曼滤波的几大概念</h1>
<h2 id="状态向量state-vector">1、状态向量State Vector</h2>
<p>系统的状态向量包含了系统中我们关心的状态变量，比如速度<span class="math inline">\(\textbf{v}=[v_x, v_y,v_z]\)</span>，距离<span class="math inline">\(\textbf{d}=[d_x, d_y,d_z]\)</span>，加速度<span class="math inline">\(\textbf{a}=[a_x,a_y,a_z]\)</span>等。我们用<span class="math inline">\(\textbf{x}\)</span>表示系统向量 <span class="math display">\[ \textbf{x} = \begin{bmatrix} \textbf{d}\\ \textbf{v}\\ \textbf{a} \end{bmatrix}\\\]</span></p>
<p>因为卡尔曼滤波有两个步骤，我们先以每个时刻都进行测量和修正这两个步骤作为讲解。那么，每一时刻的两个步骤的输出对应两个系统向量，一个是预测的系统向量<span class="math inline">\(\textbf{x}^-\)</span>，一个是修正后的系统向量<span class="math inline">\(\textbf{x}^+\)</span>。</p>
<p><strong><em><strong>ps</strong>:大写字母表示矩阵；小写加粗字母表示向量；小写字母表示变量</em></strong></p>
<h2 id="状态方程预测方程">2、状态方程&amp;&amp;预测方程</h2>
<h3 id="状态方程">状态方程</h3>
<p><strong>状态方程</strong>描述了将上一时刻的状态向量<span class="math inline">\(\textbf{x}_{t-1}\)</span>映射到当前的系统状态<span class="math inline">\(\textbf{x}_t\)</span> <span class="math display">\[ \textbf{x}_t = A_t\textbf{x}_{t-1}+ B_t\textbf{u}_t+\textbf{w}_t \tag{1}\]</span></p>
<p>其中，矩阵<span class="math inline">\(A\)</span>称为转换矩阵（Transition Matrix），<span class="math inline">\(\textbf{u}_t\)</span>是当前时刻的系统输入，矩阵<span class="math inline">\(B\)</span>称为控制矩阵（Control Matrix）反映了系统输入到系统状态的映射关系，<span class="math inline">\(\textbf{w}_t\)</span>是过程噪声，我们假定其符合均值为0，协方差矩阵为<span class="math inline">\(Q_t\)</span>的高斯噪声。这里要注意的有几点：</p>
<ol type="1">
<li>矩阵<span class="math inline">\(A、B\)</span>都随着时间演进进行更新</li>
<li>从公式1的形式可以看出，卡尔曼滤波的数学建模形式是线性方程，这也是卡尔曼滤波的限制之一。扩展卡尔曼滤波器（Extended Kalman Filter）支持非线性模型。</li>
<li>这里的状态方程是一个“准确”的表达，因为不准确的部分已经放在噪声项中，要跟下面的预测方程区分开来。这个“准确”的表达由于有噪声（随机向量），所以我们没办法使用它作为输出，只能用它来分析、推导。</li>
</ol>
<h3 id="预测方程">预测方程</h3>
<p><strong>预测方程</strong>跟状态方程基本一样，要强调的一点是，噪声<span class="math inline">\(\textbf{w}_t\)</span>是均值为0的高斯噪声，因此最大概率对应的值为0，因此我们在预测状态向量的时候其实不用管最后一项 <span class="math display">\[ \hat{\textbf{x}}^-_t = \textbf{A}_t\hat{\textbf{x}}^+_{t-1} + \textbf{B}_t\textbf{u}_t\tag{2}\]</span></p>
<p>这里对系统状态向量上面加上一个帽子表示这是一个估计量，也就是我们实际输出的量。其中<span class="math inline">\(\hat{\textbf{x}}^+ _{t-1}\)</span>表示上一时刻执行完步骤二<strong>更新</strong>后的状态向量，<span class="math inline">\(\hat{\textbf{x}}^- _{t}\)</span>表示当前时候只执行了步骤1<strong>预测</strong>的状态向量。</p>
<h3 id="理解预测方程">理解预测方程</h3>
<p>预测方程（公式2）从形式上看只是把状态方程（公式1）去掉了噪声项，但其中包含了很多含义。其中，要时刻记得的是我们把系统状态当作一个随机向量处理，严格的表述需要引入随机过程的相关知识，但其实没太大必要。由于公式（1）中状态向量是一个随机向量，且噪声项是均值为0的高斯噪声，那么状态向量<span class="math inline">\(\textbf{x}_t\)</span>也满足高斯分布，其最大概率的地方就对应这噪声为0的地方，因此我们有理由将这个概率最大处对应的值当作我们的<strong>预测</strong>。</p>
<figure>
<img src="./imgs/gaussian.png" alt="" /><figcaption>gaussian</figcaption>
</figure>
<h2 id="测量方程测量估计方程">3、测量方程&amp;&amp;测量估计方程</h2>
<h3 id="测量方程">测量方程</h3>
<p><strong>测量方程</strong>反映了系统的测量值和系统状态向量之间的关系 <span class="math display">\[ \textbf{z}_t=H_t\textbf{x}_t+v_t\tag{3}\]</span></p>
<p>其中，<span class="math inline">\(\textbf{z}_t\)</span>是当前时刻的测量值，<span class="math inline">\(H_t\)</span>称为测量矩阵（Measurement Matrix），描述了从系统状态到测量值的转换关系（举一个最简单的关系，系统状态是物体的直线距离，测量值是使用激光笔测出来的光从原点到物体的时间，那么<span class="math inline">\(H\)</span>就是光速的倒数）, <span class="math inline">\(\textbf{v}_t\)</span>是测量噪声，我们假定其符合均值为0，协方差为<span class="math inline">\(R_t\)</span>的高斯噪声。注意这里无论是状态向量还是测量向量都没有加帽子（<span class="math inline">\(\hat{.}\)</span>），表示这是个"准确"的表达式。</p>
<h3 id="测量估计方程">测量估计方程</h3>
<p>同样，我们如果忽略噪声项，就变成了对此时测量量的估计（注意状态向量的上标和角标）：</p>
<p><span class="math display">\[ \hat{\textbf{z}}_t=H_t\hat{\textbf{x}}^-_t\tag{4}\]</span></p>
<h2 id="测量更新方程">4、测量更新方程</h2>
<p>上面给出了对测量量的估计，但是现在的情况是，我们有了一个测量值（通过某些测量方式或者传感器数据），这是一个不需要计算得到的量，我们如何用这个测量得出的量来更新我们对状态向量的估计？这就涉及到测量更新方程，这也是卡尔曼滤波里最难的部分，这里先给出更新方程的形式。</p>
<p><span class="math display">\[ \hat{\textbf{x}}^+_t=\hat{\textbf{x}}^-_t+K_t(z_t-H_t\hat{\textbf{x}}^-_t)\tag{5}\]</span> <span class="math display">\[ K_t=\frac{P^-_tH_t^T}{H_tP^-_tH_t^T+R_t}\tag{6}\]</span></p>
<p>其中，<span class="math inline">\(K_t\)</span>叫做卡尔曼增益；<span class="math inline">\(P^-_t\)</span>是系统测量值<span class="math inline">\(\hat{\textbf{x}}^-_t\)</span>的误差协方差矩阵。</p>
<h1 id="四误差和协方差矩阵">四、误差和协方差矩阵</h1>
<p>根据公式（1）减去公式（2），我们可以得出误差的协方差矩阵的表达形式</p>
<p><span class="math display">\[ e^-_t \triangleq \textbf{x}_t - \hat{\textbf{x}}^-_t\\\]</span> <span class="math display">\[ P^-_t = \mathbb{E}[\textbf{e}^-_t {\textbf{e}^{-}_{t}}^T]\\\]</span></p>
<p>把公式（1）和（2）带入误差表达式，可以推导出系统状态的协方差矩阵的递归表达形式</p>
<p><span class="math display">\[
\begin{split}
P^-_t&amp;=\mathbb{E}[\big((A_tx_{t-1}+w_t)-A_tx_{t-1}^+\big)\big((A_tx_{t-1}+w_t)-A_tx_{t-1}^+\big)^T]\\&amp;=\mathbb{E}[\big(A_t(x_{t-1}-x_{t-1}^+)+w_t\big)\big(A_t(x_{t-1}-x_{t-1}^+)+w_t\big)^T]\\ &amp;=\mathbb{E}[A_t(x_{t-1}-x_{t-1}^+)(x_{t-1}-x_{t-1}^+)^TA_t^T]+\mathbb{E}[w_tw_t^T]\\ &amp;=A_tP_{t-1}^+A_t^T+Q_t
\end{split}\\\]</span></p>
<p>其中，从第二个等号到第三个等号利用了状态向量和随机噪声 的无关性（协方差为0）。因此我们可以得到下面的公式（7）</p>
<p><span class="math display">\[P^-_t=A_tP^+_{t-1}A^T_t+Q_t\tag{7}\]</span></p>
<h1 id="五更新方程的推导">五、更新方程的推导</h1>
<p>现在我们进行到了这样的情况，我们使用预测方程公式（2）得到了<span class="math inline">\(t\)</span>时刻的系统状态预测量<span class="math inline">\(\textbf{x}_t^-\)</span>；同时，我们在这个时刻得到了一个测量值，且根据测量方程，我们认为它与此时的状态向量满足公式（3）：<span class="math inline">\(\textbf{z}_t=H_t\textbf{x}_t+v_t\)</span> 。那么其实我们可以从公式（3）也得到此时系统状态的另一个估计，由公式（3）将 移动到等式左侧，可以得到：</p>
<p><span class="math display">\[\textbf{x}^2_t = \textbf{H}_t^{-1}\textbf{z}_t\\\]</span></p>
<p>这里之所以没有把噪声<span class="math inline">\(\textbf{v}_t\)</span>表示出来，是因为这里将 当作一个随机向量处理，其均值为<span class="math inline">\(\bar{z}_t\)</span>，也就是当前时刻测量得出的量；其方差为<span class="math inline">\(R_t\)</span>（在公式3中给出）</p>
<p>我们的状态方程也给出了状态向量的一个等式 <span class="math display">\[ \textbf{x}^1_t = \textbf{A}_t\textbf{x}_{t-1}+ \textbf{B}_t\textbf{u}_t+w_t\]</span></p>
<p>这里用<strong>上标1和2</strong>表示状态向量的两个来源。要强调的是，这两个等式里面都包含了一个随机噪声，因此$^1_t 、^2_t $都是随机向量。同时，他们的分布都符合高斯分布。它们的均值和方差分别是：</p>
<p><span class="math display">\[
\begin{split} &amp;\mu_1=x_t^-\\ &amp;\sigma_1^2=P_t^-\\ &amp;\mu_2=H_t^{-1}\bar{z}_t\\ &amp;\sigma_2^2=H_t^{-1}R_t(H_t^{-1})^T\\  \end{split}\\\]</span></p>
<p>现在有了两个关于状态向量的概率分布，那接下来的事情就简单了。因为这两个状态向量的来源我们可以认为是独立的，因此他们的联合概率分布是各自概率分布的乘积。重点是，高斯分布的乘积依旧是高斯分布！！！！新的高斯分布的均值和方差有如下表达形式：</p>
<figure>
<img src="./imgs/joint_gaussian.png" alt="" /><figcaption>joint gaussian</figcaption>
</figure>
<p>用上面的式子代入，可以得到联合概率分布的均值和方差： <strong>均值</strong> <span class="math display">\[ \begin{split} \mu_{fused}&amp;=\frac{\mu_1\sigma_2^2+\mu_2\sigma_1^2}{\sigma_1^2+\sigma_2^2}\\ &amp;=\mu_1+\frac{(\mu_2-\mu_1)\sigma_1^2}{\sigma_1^2+\sigma_2^2}\\ &amp;=x_t^-+\frac{(H_t^{-1}\bar{z}_t-x_t^-)P_t^-}{P_t^-+H_t^{-1}R_t(H_t^{-1})^T}\\ &amp;=x_t^-+\frac{P_t^-H_t^T}{H_tP_t^-H_t^T+R_t}(\bar{z}_t-H_tx_t^-)\\ &amp;=x_t^-+K_t(\bar{z}_t-H_tx_t^-) \end{split}\\\]</span></p>
<p><strong>方差</strong></p>
<p><span class="math display">\[
\begin{split} \sigma_{fused}^2 &amp;=\frac{\sigma_1^2\sigma_2^2}{\sigma_1^2+\sigma_2^2}\\ &amp;=\sigma_1^2-\frac{\sigma_1^4}{\sigma_1^2+\sigma_2^2}\\ &amp;=P_t^--\frac{P_t^-H_t^TH_tP_t^-}{H_tP_t^-H_t^T+R_t}\\ &amp;=P_t^--K_tH_tP_t^- \end{split}\\\]</span></p>
<p>这个<span class="math inline">\(\sigma_{fused}^2\)</span>就是更新后的系统状态误差的协方差矩阵，也就是得到下面的式子</p>
<p><span class="math display">\[ P^+_{t}=P^-_t-K_tH_tP^-_t\tag{8}\]</span></p>
<h1 id="六总结">六、总结</h1>
<p><strong>预测方程</strong> <span class="math display">\[ \hat{\textbf{x}}^-_t = \textbf{A}_t\hat{\textbf{x}}^+_{t-1} + \textbf{B}_t\textbf{u}(t)\tag{2}\]</span> <span class="math display">\[P^-_t=A_tP^+_{t-1}A^T_t+Q_t\tag{7}\]</span></p>
<p><strong>更新方程</strong> <span class="math display">\[ \hat{\textbf{x}}^+_t=\hat{\textbf{x}}^-_t+K_t(z_t-H_t\hat{\textbf{x}}^-_t)\tag{5}\]</span> <span class="math display">\[ K_t=\frac{P^-_tH_t^T}{H_tP^-_tH_t^T+R_t}\tag{6} \]</span> <span class="math display">\[ P^+_{t}=P^-_t-K_tH_tP^-_t\tag{8} \]</span></p>
<hr />
<h1 id="转载须知">转载须知</h1>
<ol type="1">
<li>请于文章标题注明转载</li>
<li>请于文章起始位置注明原始链接</li>
<li>请在推文文末的【阅读原文】链接上原始链接</li>
<li>感谢~</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/archives/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"covS4Q3Q0SaMRjqI2VomagVm-gzGzoHsz","app_key":"iK7kdlu4InjORoPr3oksi1IM","server_url":"https://covs4q3q.lc-cn-n1-shared.com","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywzGuJ0w","appkey":"7c4a236bb42c7db38424a76bf68ccf99","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
