<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeal-up.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录及分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeal&#39;s Blog">
<meta property="og:url" content="https://zeal-up.github.io/archives/index.html">
<meta property="og:site_name" content="Zeal&#39;s Blog">
<meta property="og:description" content="学习记录及分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeal">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeal-up.github.io/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeal's Blog</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SE75EDBKX6","only_pageview":true}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/zeal-up" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeal's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习～天天向上～</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zeal</p>
  <div class="site-description" itemprop="description">学习记录及分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/10/20/linux/generate_corefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/20/linux/generate_corefile/" class="post-title-link" itemprop="url">linux生成core文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-10-20 17:01:57 / 修改时间：17:06:01" itemprop="dateCreated datePublished" datetime="2023-10-20T17:01:57+08:00">2023-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span id="/2023/10/20/linux/generate_corefile/" class="post-meta-item leancloud_visitors" data-flag-title="linux生成core文件" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="linux生成core文件" href="/2023/10/20/linux/generate_corefile/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::3bbb0b02ec0e7a330bb6cb51d9eeda4d" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="关闭错误收集系统apport">关闭错误收集系统apport</h2>
<p>ubuntu有一个默认的错误搜集系统apport，必须要关掉之后才能生成core文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service apport status</span><br><span class="line">sudo service apport stop</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> apport</span><br></pre></td></tr></table></figure>
<h2 id="设置corefile生成">设置corefile生成</h2>
<h3 id="打开corefile生成">打开corefile生成</h3>
<p>设置core文件大小，默认是0，所以不会生成core文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c  <span class="comment"># 若结果是0，则不会生成core文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 不限制core文件大小</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 选择当前使用的终端</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.zshrc  <span class="comment"># 选择当前使用的终端</span></span><br></pre></td></tr></table></figure>
<h3 id="设置core文件路径">设置core文件路径</h3>
<p><strong>！！注意，路径必须普通用户可读可写，否则生成core文件会失败！！</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /corefile</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /corefile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/corefile/core-%e-%p-%t&quot;</span> | sudo <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令会永久生效，否则每次重启都得重新设置路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.core_pattern=/corefile/core-%e-%p-%t&quot;</span> | sudo <span class="built_in">tee</span> /etc/sysctl.d/60-core-pattern.conf</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>可以通过一个小方法测试产生core文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGSEGV $$</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/09/28/geometry/euclidean_cluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/28/geometry/euclidean_cluster/" class="post-title-link" itemprop="url">点云聚类算法：EuclideanClustering和Fast Euclidean Clustering</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-28 14:24:52 / 修改时间：16:02:49" itemprop="dateCreated datePublished" datetime="2023-09-28T14:24:52+08:00">2023-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E5%87%A0%E4%BD%95/" itemprop="url" rel="index"><span itemprop="name">几何</span></a>
        </span>
    </span>

  
    <span id="/2023/09/28/geometry/euclidean_cluster/" class="post-meta-item leancloud_visitors" data-flag-title="点云聚类算法：EuclideanClustering和Fast Euclidean Clustering" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="点云聚类算法：EuclideanClustering和Fast Euclidean Clustering" href="/2023/09/28/geometry/euclidean_cluster/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::24783120b34206cd060aaf584479e2a3" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>最近在项目中要用到点云聚类算法来分割点云。场景需求比较简单。点云间的间隔也足够大。开始以为应该是一个简单的算法，准确率和效率应该很容易满足。一开始使用<code>PCL</code>中的<code>EuclideanClusterExtraction</code>类，根据欧式距离进行聚类对点云分割。由于场景十分简单，所以分割效果可以满足。但是耗时却非常高。处理一个不到4w点的点云竟然耗时达到8s。后面从网上查到一个叫<code>FastEulideanClustering - FEC</code>的算法，虽然也是使用欧式距离进行分类，但是论文中与PCL中的<code>EuclideanClustering</code>相比在时间上快了几十倍。</p>
<p>这篇比较简单梳理一下<code>EuclideanClustering(EC)</code>和<code>Fast Euclidean Clustering(FEC)</code>的原理和两者的主要区别。同时，自己实现一个example,对比两者的耗时。同时把代码上传备份。</p>
<h2 id="euclideanclusteringec">EuclideanClustering(EC)</h2>
<p>详细说明可以参考PCL官方文档：<a target="_blank" rel="noopener" href="https://pcl.readthedocs.io/projects/tutorials/en/latest/cluster_extraction.html#cluster-extraction">EuclideanClusterExtraction</a></p>
<p>EC算法的原理十分简单，随机选一个点，在该点处画一个半径Radius的球，所有位于球中的点归结为该点同一类。然后再随机选一个未分类的点，重复上述过程，直到所有点都被分类。</p>
<p>为了加速，在PCL中一般会使用<code>kdtree</code>来加速搜索。</p>
<p>EC算法的具体步骤如下：</p>
<ol type="1">
<li>为点云<span class="math inline">\(P\)</span>构建Kd-tree</li>
<li>为当前类设置一个队列<span class="math inline">\(Q\)</span></li>
<li>随机选一个点<span class="math inline">\(p\)</span>，将其加入<span class="math inline">\(Q\)</span>,然后执行下面步骤
<ul>
<li>对<span class="math inline">\(Q\)</span>中的每个点<span class="math inline">\(p_i\)</span>，执行下面步骤
<ul>
<li>以<span class="math inline">\(p_i\)</span>为中心，半径为<span class="math inline">\(Radius\)</span>画一个球，找到所有位于球内的点<span class="math inline">\(P_i^k\)</span></li>
<li>对于<span class="math inline">\(P_i^k\)</span>中的每个点<span class="math inline">\(p_j\)</span>，如果该点没有被分类，将其加入<span class="math inline">\(Q\)</span></li>
</ul></li>
<li>当<span class="math inline">\(Q\)</span>中所有的点被处理完（<span class="math inline">\(Q\)</span>为空），则该类结束</li>
</ul></li>
<li>重复步骤2-3，直到所有点都被分类</li>
</ol>
<h2 id="ec算法和regiongrowing以及dbscan的区别">EC算法和RegionGrowing以及DBSCAN的区别</h2>
<h3 id="regiongrowing-basedrg方法">RegionGrowing-Based（RG）方法</h3>
<p>RG方法是一种基于区域的方法，它将点云分割为不同的区域，每个区域都有一个种子点。然后，通过将相邻的点添加到区域中来增长区域。这个过程一直持续到没有更多的点可以添加到区域中为止。这种方法的一个缺点是，它需要一个种子点，而且对于不同的种子点，可能会得到不同的结果。此外，RG方法一般会使用不同的规则来确定相邻点，比如法向量的角度，曲率等。</p>
<p>RG方法的第一步是先确定一个随机点集合。随机点集的确定可以依赖一些先验知识，来获得更好的结果。</p>
<h3 id="dbscan方法">DBSCAN方法</h3>
<p>Density-based spatial clustering of applications with noise (DBSCAN) 其实从步骤来说跟EC方法十分类似。不过在做近邻搜索的时候，还会判断近邻点的数量，如果在半径<span class="math inline">\(Radius\)</span>内的近邻点数量小于某个阈值，则认为该点为噪声点，不进行分类。这也是<code>Density</code>的含义。</p>
<p>具体的DBSCAN方法可以参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DBSCAN">DBSCAN</a></p>
<h2 id="fast-euclidean-clusteringfec">Fast Euclidean Clustering(FEC)</h2>
<p>论文：<a target="_blank" rel="noopener" href="https://www.mdpi.com/2504-446X/6/11/325">FEC: Fast Euclidean Clustering for Point Cloud Segmentation</a> 论文中的代码链接有误，应该是：<a target="_blank" rel="noopener" href="https://github.com/unageek/fast-euclidean-clustering">unageek/fast-euclidean-clustering</a></p>
<h3 id="fec算法基本原理">FEC算法基本原理</h3>
<p>FEC算法也是基于欧式距离进行聚合分类。与EC算法不同之处在于，EC算法最外层循环是<code>类别</code>，先处理完一个类别再处理下一个类别。在处理一个类别的过程中，同一个点可能会多次加入队列。而FEC算法的最外层循环是<code>点</code>，每个点只会被处理一次。这样可以减少很多重复的计算。</p>
<p>FEC算法的具体步骤如下：</p>
<figure>
<img src="./imgs/FEC_steps.png" alt="" /><figcaption>FEC算法步骤</figcaption>
</figure>
<p>虽然论文说了一大堆，但是具体步骤还是论文里这张图描述得清楚</p>
<figure>
<img src="./imgs/FEC_visualization.png" alt="" /><figcaption>FEC算法步骤可视化</figcaption>
</figure>
<h2 id="实际测试">实际测试</h2>
<h3 id="代码">代码</h3>
<p>代码已经上传到github:<a target="_blank" rel="noopener" href="https://github.com/zeal-up/PointcloudClustering">zeal-up/PointcloudClustering</a> 该仓库中包含了EC和FEC的实现代码，以及测试代码。主要测试两者的耗时对比</p>
<h3 id="数据">数据</h3>
<p>代码中包含一个生成虚拟点云数据的脚本，生成的点云效果如下：</p>
<figure>
<img src="./imgs/generated_pointcloud.png" alt="" /><figcaption>虚拟点云</figcaption>
</figure>
<p>同时，该仓库中也包含一个从激光雷达点云截取出的部分点云：</p>
<figure>
<img src="./imgs/real_pointcloud.png" alt="" /><figcaption>真实点云</figcaption>
</figure>
<h3 id="测试结果">测试结果</h3>
<p>上述的两个点云案例都十分简单，分割明确。而且均是一个二分类问题。两个算法在分割效果上均正常。 上述生成的虚拟点云一共4w个点，真实点云大约有3w个点。</p>
<p>该真实点云的耗时比合成的点云在<code>EC方法</code>上的耗时要比合成的点云高很多，这点不清楚为什么。</p>
<p>对于该真实点云，EC方法耗时为：<code>5414.84ms</code>，FEC方法耗时为：<code>36.761ms</code>。可以看到FEC方法在耗时上比EC方法快了100倍以上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/09/27/cv/otsu_method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/27/cv/otsu_method/" class="post-title-link" itemprop="url">Otsu算法（大津法）-动态阈值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-27 14:32:43 / 修改时间：16:23:50" itemprop="dateCreated datePublished" datetime="2023-09-27T14:32:43+08:00">2023-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
    <span id="/2023/09/27/cv/otsu_method/" class="post-meta-item leancloud_visitors" data-flag-title="Otsu算法（大津法）-动态阈值" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Otsu算法（大津法）-动态阈值" href="/2023/09/27/cv/otsu_method/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::72503e01a5e51eaa7fe350155b60ad5a" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="otsu算法简介">Otsu算法简介</h2>
<p>Otsu算法是一种图像二值化的算法，它的主要思想是将图像分成背景和前景两部分，背景和前景之间的差别越大越好，也就是说背景越黑，前景越白越好，这样的话，我们就可以通过阈值来将图像二值化，阈值的选取就是Otsu算法的核心。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/4310076">原始论文1979：A threshold selection method from gray-level histograms</a></p>
<figure>
<img src="./imgs/Image_processing_pre_otsus_algorithm.jpg" alt="" /><figcaption>示例图片</figcaption>
</figure>
<figure>
<img src="./imgs/Image_processing_post_otsus_algorithm.jpg" alt="" /><figcaption>示例图片-计算阈值并二值化</figcaption>
</figure>
<p><strong>虽然Otsu算法是图像中确定阈值的方法，但也可以应用到其他方面。比如点云根据强度值进行分割，就可以使用Otsu算法。本质上Otsu就是通过统计学的方法将输入根据某个值分成两个类。</strong></p>
<p>Otsu算法只能将输入分割成两类，其本质是确定一个阈值，使得用该阈值分割出来的两类的类间（between-class）方差最大，类内（within-class）方差最小。类间方差越大，说明两类之间的差别越大，类内方差越小，说明类内的差别越小。</p>
<h2 id="数学形式">数学形式</h2>
<h3 id="均值和概率">均值和概率</h3>
<p>这里主要参考原始论文中的数学形式，以及<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Otsu%27s_method">维基百科</a>中的数学形式。</p>
<p>假设图片中的所有像素灰度值可以分成<span class="math inline">\(L\)</span>个等级，<span class="math inline">\([1,2,...,L]\)</span>。比如通常对于8bit灰度图像，我们可以用256个等级表示灰度值。等级<span class="math inline">\(i\)</span>的像素数为<span class="math inline">\(n_i\)</span>，总像素数为<span class="math inline">\(N\)</span>，<span class="math inline">\(N=n_1+n_2+\cdot\cdot\cdot+n_L\)</span>。每个等级的像素出现的概率如下：</p>
<p><span class="math display">\[
p_i=\frac{n_i}{N}, \quad p_i\geq 0, \sum_{i=1}^{L}p_i=1\tag{1}
\]</span></p>
<p>确定阈值<span class="math inline">\(k\)</span>后可以将像素分成两类<span class="math inline">\(C_0,C_1\)</span> <span class="math inline">\(C_0\)</span>表示像素等级在<span class="math inline">\([1,...,k]\)</span>的像素，<span class="math inline">\(C_1\)</span>表示像素等级在<span class="math inline">\([k+1,...,L]\)</span>的像素</p>
<p>两个类的像素比例为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;w_0=Pr(C_0)=\sum_{i=1}^{k}p_i=w(k)\\
&amp;w_1=Pr(C_1)=\sum_{i=k+1}^{L}p_i=1-w(k)\\
\end{aligned}\tag{2}
\]</span></p>
<p>并且</p>
<p><span class="math display">\[
w_0+w_1=1\tag{3}
\]</span></p>
<p>两个类的平均灰度值为： <span class="math display">\[
\begin{aligned}
&amp;\mu_0=E(C_0)=\sum_{i=1}^{k} i\cdot \frac{p_i}{w_0}=\mu(k)/w(k)\\
&amp;\mu_1=E(C_1)=\sum_{i=k+1}^{L} i\cdot \frac{p_i}{w_1}=\frac{\mu_T - \mu(k)}{1 - w(k)}\\
\end{aligned}\tag{4}
\]</span></p>
<p>其中，<span class="math inline">\(\mu(k)\)</span>是等级为<span class="math inline">\(1-k\)</span>像素的一阶累积矩（first-order cumulative moments），<span class="math inline">\(\mu_T\)</span>是总的平均灰度值。</p>
<p><span class="math display">\[
\mu(k)=\sum_{i=1}^{k}i\cdot p_i\tag{5}
\]</span></p>
<p><span class="math display">\[
\mu_T=\sum_{i=1}^{L}i\cdot p_i\tag{6}
\]</span></p>
<p><span class="math inline">\(w(k)\)</span>是等级为<span class="math inline">\(1-k\)</span>像素的概率和</p>
<p><span class="math display">\[
w(k)=\sum_{i=1}^{k}p_i\tag{7}
\]</span></p>
<p>根据上面关系，我们还可以得到：</p>
<p><span class="math display">\[
w_0\mu_0+w_1\mu_1 = \mu_T\tag{8}
\]</span></p>
<h3 id="类内类间方差">类内/类间方差</h3>
<p><strong>两个类各自的方差</strong></p>
<p>根据上面的定义，我们可以得到两个类各自的方差</p>
<p><span class="math display">\[
\sigma_0^2=\sum_{i=1}^{k}(i-\mu_0)^2\cdot \frac{p_i}{w_0}\tag{9}
\]</span></p>
<p><span class="math display">\[
\sigma_1^2=\sum_{i=k+1}^{L}(i-\mu_1)^2\cdot \frac{p_i}{w_1}\tag{10}
\]</span></p>
<p><strong>总体方差</strong></p>
<p>像素总体的方差为：</p>
<p><span class="math display">\[
\sigma_T^2=\sum_{i=1}^{L}(i-\mu_T)^2\cdot p_i\tag{13}
\]</span></p>
<p><strong>类内方差</strong></p>
<p>因此，我们可以得到类内（within-class）方差的公式：</p>
<p><span class="math display">\[
\sigma_w^2=w_0\sigma_0^2+w_1\sigma_1^2\tag{11}
\]</span></p>
<p><strong>类间方差</strong></p>
<p>类间（between-class）方差为：</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_b^2&amp;=w_0(\mu_0-\mu_T)^2+w_1(\mu_1-\mu_T)^2\\
&amp;=w_0w_1(\mu_0-\mu_1)^2\\
&amp;=w(k)(1-w(k))[\frac{\mu(k)}{w(k)}-\frac{\mu_T-\mu(k)}{1-w(k)}]^2\\
&amp;=\frac{[\mu(k)(1-w(k))-(\mu_T-\mu(k))w(k)]^2}{w(k)(1-w(k))}\\
&amp;=\frac{[\mu(k)-\mu_Tw(k)]^2}{w(k)[1-w(k)]}
\end{aligned}\tag{12}
\]</span></p>
<p><strong>类内方差与类间方差的关系</strong></p>
<p>根据公式（11-13），我们可以得到：</p>
<p><span class="math display">\[
\sigma_T^2=\sigma_w^2+\sigma_b^2\tag{14}
\]</span></p>
<h3 id="otsu算法的目标">Otsu算法的目标</h3>
<p>Otsu算法的目标是找到一个阈值<span class="math inline">\(k\)</span>，使得类间方差<span class="math inline">\(\sigma_b^2\)</span>最大，也就是说，找到一个阈值<span class="math inline">\(k\)</span>，使得类内方差<span class="math inline">\(\sigma_w^2\)</span>最小。</p>
<h3 id="otsu算法步骤">Otsu算法步骤</h3>
<ol type="1">
<li>统计每个像素等级的像素数量，并计算每个像素等级的概率<span class="math inline">\(p_i\)</span>，<span class="math inline">\(i\in[1,...,L]\)</span>。</li>
<li>计算每个像素等级的概率和<span class="math inline">\(w(k)\)</span>，<span class="math inline">\(k\in[1,...,L]\)</span>。</li>
<li>计算每个像素等级的平均灰度值<span class="math inline">\(\mu(k)\)</span>，<span class="math inline">\(k\in[1,...,L]\)</span>。</li>
<li>计算总的平均灰度值<span class="math inline">\(\mu_T\)</span>。</li>
<li>根据公式（4）可以计算出每个像素等级的平均灰度值<span class="math inline">\(\mu_0\)</span>和<span class="math inline">\(\mu_1\)</span>，<span class="math inline">\(k\in[1,...,L]\)</span>。</li>
<li>遍历所有像素等级<span class="math inline">\([1,2,3...,L]\)</span> 6.1 根据公式（12）计算类间方差<span class="math inline">\(\sigma_b^2\)</span>。 6.2 如果<span class="math inline">\(\sigma_b^2\)</span>大于之前的最大值，则更新最大值，并记录当前的像素等级<span class="math inline">\(k\)</span></li>
</ol>
<h3 id="算法实现-python">算法实现-python</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, img_as_float</span><br><span class="line"><span class="keyword">from</span> skimage.filters <span class="keyword">import</span> threshold_otsu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">otsu</span>(<span class="params">gray_img</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Otsu算法</span></span><br><span class="line"><span class="string">    :param gray_img: 灰度图像</span></span><br><span class="line"><span class="string">    :return: 阈值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 统计每个像素等级的像素数量，并计算每个像素等级的概率</span></span><br><span class="line">    <span class="comment"># 灰度图像的像素等级为[0,1,2,...,255]</span></span><br><span class="line">    pixel_nums = np.zeros((<span class="number">256</span>, <span class="number">1</span>))  <span class="comment"># 每个像素等级的像素数量</span></span><br><span class="line">    pixel_probs = np.zeros((<span class="number">256</span>, <span class="number">1</span>))  <span class="comment"># 每个像素等级的概率</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">1</span>]):</span><br><span class="line">            pixel_nums[gray_img[i][j]] += <span class="number">1</span></span><br><span class="line">    pixel_probs = pixel_nums / (gray_img.shape[<span class="number">0</span>] * gray_img.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个像素等级的概率和</span></span><br><span class="line">    pixel_probs_sum = np.zeros((<span class="number">256</span>, <span class="number">1</span>))  <span class="comment"># 每个像素等级的概率和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            pixel_probs_sum[i] = pixel_probs[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pixel_probs_sum[i] = pixel_probs_sum[i - <span class="number">1</span>] + pixel_probs[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个像素等级的平均灰度值</span></span><br><span class="line">    pixel_means = np.zeros((<span class="number">256</span>, <span class="number">1</span>))  <span class="comment"># 每个像素等级的平均灰度值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            pixel_means[i] = <span class="number">0</span> * pixel_probs[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pixel_means[i] = pixel_means[i - <span class="number">1</span>] + i * pixel_probs[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总的平均灰度值</span></span><br><span class="line">    img_mean = pixel_means[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有像素等级</span></span><br><span class="line">    max_sigma_b = <span class="number">0</span>  <span class="comment"># 最大类间方差</span></span><br><span class="line">    best_threshold = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="comment"># 根据上文公式（12）计算类间方差</span></span><br><span class="line">        <span class="comment"># \frac&#123;[\mu(k)-\mu_Tw(k)]^2&#125;&#123;w(k)[1-w(k)]&#125;</span></span><br><span class="line">        sigma_b = (img_mean * pixel_probs_sum[i] - pixel_means[i]) ** <span class="number">2</span> / (pixel_probs_sum[i] * (<span class="number">1</span> - pixel_probs_sum[i]))</span><br><span class="line">        <span class="comment"># 如果类间方差大于之前的最大值，则更新最大值，并记录当前的像素等级</span></span><br><span class="line">        <span class="keyword">if</span> sigma_b &gt; max_sigma_b:</span><br><span class="line">            max_sigma_b = sigma</span><br><span class="line">            k = i</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/09/05/toolchains/bazel_notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/05/toolchains/bazel_notes/" class="post-title-link" itemprop="url">BazelNotes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-05 14:06:49 / 修改时间：14:11:32" itemprop="dateCreated datePublished" datetime="2023-09-05T14:06:49+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/Toolchains/" itemprop="url" rel="index"><span itemprop="name">Toolchains</span></a>
        </span>
    </span>

  
    <span id="/2023/09/05/toolchains/bazel_notes/" class="post-meta-item leancloud_visitors" data-flag-title="BazelNotes" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="BazelNotes" href="/2023/09/05/toolchains/bazel_notes/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::06f155b09959d28809461e0e2d48695c" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="一些链接">一些链接</h2>
<p>ubuntu安装Bazel直接参考：<a target="_blank" rel="noopener" href="https://bazel.build/install/ubuntu?hl=zh-cn">Bazel Install</a></p>
<p>官方教程：<a target="_blank" rel="noopener" href="https://bazel.build/start/cpp?hl=en">Bazel Tutorial</a></p>
<h2 id="build文件中rule的路径">BUILD文件中rule的路径</h2>
<p>BUILD文件中，在加入source或者headers的时候，文件路径都是在BUILD文件所在目录下的文件，跟CMake文件一样</p>
<h2 id="关于target的label规则需要先看一下">关于target的label规则需要先看一下</h2>
<p>很简单，但描述得很清晰</p>
<p><a target="_blank" rel="noopener" href="https://bazel.build/tutorials/cpp-labels?hl=en">Use labels to reference targets</a></p>
<h2 id="依赖图可视化dependency-graph">依赖图可视化Dependency Graph</h2>
<p><a target="_blank" rel="noopener" href="https://bazel.build/tutorials/cpp-dependency?hl=en">Review the dependency graph</a></p>
<p>之前不知道用指令输出的依赖图可以用在线工具<a target="_blank" rel="noopener" href="http://www.webgraphviz.com/">GraphViz</a>可视化</p>
<h2 id="include的一些规则">Include的一些规则</h2>
<h3 id="指明include目录">指明include目录</h3>
<p>如果在source文件中include的文件不是相对于package的根目录，则需要使用<code>copts=[-Ipath/to/include/dir"]</code>来指明include的目录</p>
<p>假设工作空间如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">└── my-project</span><br><span class="line">    ├── legacy</span><br><span class="line">    │   └── some_lib</span><br><span class="line">    │       ├── BUILD</span><br><span class="line">    │       ├── include</span><br><span class="line">    │       │   └── some_lib.h</span><br><span class="line">    │       └── some_lib.cc</span><br><span class="line">    └── WORKSPACE</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>直接引用</li>
</ol>
<p>如果<code>some_lib.cc</code>在引用头文件的时候是<code>#include "legacy/some_lib/include/some_lib.h"</code>,则bazel rule可以直接这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;some_lib&quot;,</span><br><span class="line">    srcs = [&quot;some_lib.cc&quot;],</span><br><span class="line">    hdrs = [&quot;include/some_lib.h&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>否则需要加入include的目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;some_lib&quot;,</span><br><span class="line">    srcs = [&quot;some_lib.cc&quot;],</span><br><span class="line">    hdrs = [&quot;include/some_lib.h&quot;],</span><br><span class="line">    copts = [&quot;-Ilegacy/some_lib/include&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="debug选项">Debug选项</h2>
<p>调试程序的时候需要在编译时关闭编译器优化选项，这样在gdb调试的时候才能有较丰富的调试信息。</p>
<hr />
<h3 id="gccg-选项">gcc/g++ 选项</h3>
<p>说bazel的选项之前先说一下编译器的选项</p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Invoking-GCC.html">gnc-gcc: Command Line Options</a></p>
<h4 id="o0o1o2o3og">-O0/O1/O2/O3/Og</h4>
<p>编译器的4个优化级别，-O0表示没有优化，默认为-O1,-O3优化级别最高</p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Optimize-Options.html">gcc - 3.11 Options That Control Optimization</a></p>
<ul>
<li>-O0选项或者没有指定-O选项 - 完全不进行优化，可以提供准确的行号，程序打断点也是准确的，但是运行速度慢</li>
<li>-O1/-O选项 - 由于进行优化，错误信息的行号可能不准确，但是相比O0速度会有显著提高</li>
<li>-Og选项 - 进行适当的优化，但是为调试尽可能保存必要的信息。在官方文档中，建议调试时使用-Og选项而不是-O0选项</li>
</ul>
<h4 id="g-ggdb">-g/-ggdb</h4>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Debugging-Options.html">gcc - 3.10 Options for Debugging Your Program</a></p>
<p>调试信息。可以和-O选项同时使用，更建议和-Og选项配合使用</p>
<ul>
<li>-g/-gdb选项 - 使得编译器在编译时会加入调试信息。并且调试信息可供gdb使用。这两者的具体区别不是很清楚</li>
</ul>
<hr />
<h3 id="linker-选项">linker 选项</h3>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Options.html">gnu-linker - Command Line Options</a></p>
<p>除了编译器需要使用选项来指定是否保存调试信息之外，链接器也有选项来选择是否要保留调试符号</p>
<h4 id="strip">strip</h4>
<ul>
<li>-s/--strip-all 选项 - 去除所有符号信息</li>
<li>-S/--strip-debug 选项 - 只去除调试器的符号信息</li>
</ul>
<p><strong>不过有一点没有搞清楚的是，-S似乎不会去除gcc -g生成的所有调试符号。也就是说，编译是用<code>gcc -g -Wl,-S</code>并不是没有意义的，依旧会保留部分的调试符号。如果不加<code>-Wl,-S</code>，则生成的文件会非常大</strong></p>
<p><em>PS：使用<code>strip --strip-debug bin</code>命令可以对二进制文件去除调试符号</em></p>
<h4 id="wl">-Wl</h4>
<p>如果链接器不是单独调用，而是通过编译器驱动（比如gcc/g++），则链接器的选项需要在前面加上<code>-Wl，</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wl,--start-group foo.o bar.o -Wl, --end-group</span><br></pre></td></tr></table></figure>
<p>如果不加<code>-Wl,</code>，则编译器驱动会直接忽略掉链接器选项，导致错误的链接 <a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Options.html#:~:text=Note%E2%80%94if%20the,Map%3Da.map">原文说明</a></p>
<hr />
<h3 id="bazel选项">bazel选项</h3>
<h4 id="stripalways-never-sometimes">--strip(always | never | sometimes)</h4>
<p><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#strip">bazel-UserGuide-Options : strip</a></p>
<p>这一个选项对应链接器的<code>-s/--strip-debug</code>选项。</p>
<ul>
<li><p>默认值<code>--strip=sometimes</code> - 表示当<code>--compilation_mode=fastbuild</code>的时候才会去除调试符号。也就是在不指定任何<code>--strip</code>选项的时候，除非<code>--compilation_mode=fastbuild</code>，否则不会去除调试信息</p></li>
<li><p><code>--strip=always</code> - 相当于在编译时加上<code>-Wl,--strip-debug</code>选项（<code>-Wl</code>指明这个选项是链接器选项）</p></li>
<li><p><code>--strip=never</code> - 指明不去除调试符号。<code>--strip=sometimes</code>选项使得当<code>--compilation_mode=fastbuild</code>的时候才会去除调试符号</p></li>
</ul>
<p>注意这个选项只对应链接器的<code>--strip-debug</code>选项，如果想要在链接时去掉所有符号，也就是链接器的<code>--strip-all</code>选项，需要单独指定<code>--linkopt=-Wl,--strip-all</code>。</p>
<p><strong>--strip选项会覆盖--linkopt=-Wl,--strip-all`</strong></p>
<p><code>--strip</code>只是指明链接阶段是否保留调试符号。但是编译阶段是否生成调试信息也需要单独指定。可以通过<code>-c dbg</code>或者<code>--copt -g</code>指定</p>
<h4 id="compilation_mode-c-fastbuild-opt-dbg">--compilation_mode/-c (fastbuild | opt | dbg)</h4>
<p>这个选项其实大概对应了编译器的几个优化等级，但又不完全一样</p>
<ul>
<li><code>fastbuild</code> - 表示最快编译，不进行优化（-O0），并在链接阶段去掉调试符号（-Wl,--strip-debug/-S）</li>
<li><code>dbg</code> - 表示开启编译时的<code>-g</code>选项（看上文中编译器选项），生成调试信息</li>
<li><code>opt</code> - 表示使用<code>-O2</code>等级的编译器优化。与是否打开调试信息无关，调试信息可以另外指定<code>--copt -g</code>开启（实际测试中好像会开启）。不仅如此，<code>opt</code>模式还会在加入<code>-DNDEBUG</code>选项定义一个<code>NDEBUG</code>的宏。</li>
</ul>
<hr />
<h3 id="bazel几种编译模式对应的编译器链接器选项">bazel几种编译模式对应的编译器链接器选项</h3>
<p><strong>上述的关于<code>--compilation_mode</code>的官方说明似乎跟实际中的不太一样</strong>。通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel aquery //target</span><br></pre></td></tr></table></figure>
<p>指令可以查看bazel执行的过程执行和参数。下面整理一下三种编译模式对应的编译器和链接器部分选项</p>
<ol type="1">
<li>--compilation_mode=fastbuild - <strong>文件大小65.36M</strong></li>
</ol>
<p>此时相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Wl,-S</span><br><span class="line"></span><br><span class="line"># gcc在没有指定优化级别的时候应该相当于-O0,因此也相当于</span><br><span class="line">-O0 -Wl,-S</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>--compilation_mode=dbg - <strong>文件大小20.4M</strong></li>
</ol>
<p>此时相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-g -O2 -Wl,-S</span><br></pre></td></tr></table></figure>
<p>可以看到，当使用<code>dbg</code>编译模式的时候，相当于编译器开启调试符号（-g），二级优化（-O2），链接器去除调试信息（-Wl,-S） <strong>但是要注意-S似乎不会去除gcc -g生成的所有调试符号。也就是说，编译是用<code>gcc -g -Wl,-S</code>并不是没有意义的，依旧会保留部分的调试符号。如果不加<code>-Wl,-S</code>，则生成的文件会非常大</strong></p>
<ol start="3" type="1">
<li>--compilation_mode=opt - <strong>文件大小3.56M</strong></li>
</ol>
<p>此时相当于（其实还有很多其他选项）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-g -O2 -DNDEBUG -Wl,-S -Wl,--gc-sections</span><br></pre></td></tr></table></figure>
<p>虽然还是用<code>-S/--strip-debug</code>，但是加上其他选项后，实际上相当于去掉了所有调试符号（但还没有去掉所有符号）。使用<code>strip</code>工具再进行<code>--strip-debug</code>已经没有作用了。</p>
<ol start="4" type="1">
<li>--compilation_mode=dbg --strip=never - <strong>文件大小1.07</strong></li>
</ol>
<p>此时相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-g -O2 </span><br></pre></td></tr></table></figure>
<p>此时由于保留了所有调试符号，所以文件非常大</p>
<ol start="5" type="1">
<li>--compilation_mode=opt --strip=never - <strong>文件大小1.05G</strong></li>
</ol>
<p>此时相当于<code>opt</code>模式下，但是保留所有调试符号。文件也很大</p>
<hr />
<h3 id="总结">总结</h3>
<p>当需要进行调试的时候，可以选择几种模式</p>
<ol type="1">
<li>fastbuild + -g</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build -c fastbuild --copt -g //target</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：编译快，没有进行优化所以出错位置的行号绝对准确;开始调试信息并保留部分调试信息 <strong>缺点</strong>：由于没有进行优化，程序运行可能会慢很多。文件大小会稍大一点</p>
<ol start="2" type="1">
<li>dbg</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build -c dbg //target</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：开始二级优化，程序运行快，文件稍小。保留部分调试信息 <strong>缺点</strong>：二级优化（-O2）可能导致报错位置的行号会稍微不准确。</p>
<ol start="3" type="1">
<li>dbg + strip=never</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build -c dbg --strip=never</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：二级优化。保留所有调试信息！ <strong>缺点</strong>：编译过程可能较慢。最终的文件大小会非常大。</p>
<ol start="4" type="1">
<li>其他注意要点</li>
</ol>
<p>在使用bazel的时候尽量还是用bazel推荐的方式，也就是上面的几个方式。bazel的几种编译模式除了指定上面的优化等级、是否开启调试信息、删除调试符号之外还加了很多其他的选项。这样也导致虽然默认都加了<code>-Wl,-S</code>选项，但是不会完全删除掉调试符号。但是如果是自己手工指定<code>--copt=-g</code>，则bazel会提示一下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Stripping enabled, but &#x27;--copt=-g&#x27; (or --per_file_copt=...@-g) specified. Debug information will be generated and then stripped away. This is probably not what you want! Use &#x27;</span><br><span class="line">-c dbg&#x27; for debug mode, or use &#x27;--strip=never&#x27; to disable stripping</span><br></pre></td></tr></table></figure>
<p>并且编译出的二进制文件完全删除了调试符号。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/09/05/toolchains/vscode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/05/toolchains/vscode/" class="post-title-link" itemprop="url">BazelNotes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-05 14:06:49" itemprop="dateCreated datePublished" datetime="2023-09-05T14:06:49+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-19 17:58:28" itemprop="dateModified" datetime="2023-10-19T17:58:28+08:00">2023-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/Toolchains/" itemprop="url" rel="index"><span itemprop="name">Toolchains</span></a>
        </span>
    </span>

  
    <span id="/2023/09/05/toolchains/vscode/" class="post-meta-item leancloud_visitors" data-flag-title="BazelNotes" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="BazelNotes" href="/2023/09/05/toolchains/vscode/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::cdd57cd9fb314784f185a55f07daea8f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="配置项">配置项</h2>
<h3 id="使用代码格式化formating时修改column-length">使用代码格式化（formating）时修改column length</h3>
<p>谷歌的代码格式化标准是80列，但是对于现在的电脑屏幕太窄了。这个选项的修改有点隐秘，似乎必须通过<code>settings.json</code>来修改。 在<code>settings.json</code>中添加如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;C_Cpp.clang_format_fallbackStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123; BasedOnStyle: Google, ColumnLimit: 120 &#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/07/11/linux/dev_env_setting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/linux/dev_env_setting/" class="post-title-link" itemprop="url">开发环境配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-11 22:40:33" itemprop="dateCreated datePublished" datetime="2023-07-11T22:40:33+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-28 10:10:47" itemprop="dateModified" datetime="2023-08-28T10:10:47+08:00">2023-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span id="/2023/07/11/linux/dev_env_setting/" class="post-meta-item leancloud_visitors" data-flag-title="开发环境配置" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="开发环境配置" href="/2023/07/11/linux/dev_env_setting/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::ce410fb8cb2a2ba6481538d47672b8c3" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="开发环境配置">开发环境配置</h2>
<h3 id="ohmyzsh安装">ohmyzsh安装</h3>
<p><strong>安装</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>
<p><strong>字体安装解决乱码</strong>（https://github.com/powerline/fonts）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fonts-powerline</span><br></pre></td></tr></table></figure>
<p><strong>插件安装</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autojump</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p><strong>设置默认终端</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<h3 id="zshrc配置">.zshrc配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/bin:/usr/local/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable glob</span></span><br><span class="line"><span class="built_in">setopt</span> nonomatch</span><br><span class="line"><span class="built_in">setopt</span> EXTENDED_GLOB</span><br><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="comment"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=C.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=C.UTF-8</span><br><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$HOME</span>/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line">ZSH_THEME=<span class="string">&quot;agnoster&quot;</span></span><br><span class="line"></span><br><span class="line">plugins=(git autojump zsh-autosuggestions zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br></pre></td></tr></table></figure>
<h3 id="tmux-安装及配置">Tmux 安装及配置</h3>
<p><strong>安装</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p><strong>配置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start windows and panes index at 1, not 0.</span></span><br><span class="line"><span class="built_in">set</span> -g base-index 1</span><br><span class="line">setw -g pane-base-index 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure window index numbers get reordered on delete.</span></span><br><span class="line">set-option -g renumber-windows on</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable mouse mode (tmux 2.1 and above)</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"></span><br><span class="line"><span class="comment"># set window index from 1</span></span><br><span class="line"><span class="built_in">set</span> -g base-index 1</span><br><span class="line">setw -g pane-base-index 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable vim mode</span></span><br><span class="line"><span class="built_in">set</span> -g status-keys vi</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the status line&#x27;s colors</span></span><br><span class="line"><span class="built_in">set</span> -g status-style <span class="built_in">fg</span>=white,<span class="built_in">bg</span>=blue</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set different background color for active window</span></span><br><span class="line"><span class="built_in">set</span> -g window-status-style <span class="built_in">bg</span>=yellow</span><br><span class="line"><span class="built_in">set</span> -g window-status-current-style <span class="built_in">bg</span>=red,<span class="built_in">fg</span>=white</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># Themes</span></span><br><span class="line"><span class="comment"># List of plugins</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tpm&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-sensible&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-cpu&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;xamut/tmux-network-bandwidth&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g status-style <span class="string">&quot;fg=#2188ff,bg=#1f2428&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-left-length <span class="string">&quot;100&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-right-length <span class="string">&quot;100&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-left-length 20</span><br><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot;#[fg=#1f2428,bg=#2188ff,bold] #S #[fg=#2188ff,bg=#1f2428,nobold,nounderscore,noitalics]&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;#[fg=#1f2428,bg=#1f2428,nobold,nounderscore,noitalics]#[fg=#1f2428,bg=#1f2428] #&#123;prefix_highlight&#125; #[fg=#e1e4e8,bg=#1f2428,nobold,nounderscore,noitalics]#[fg=#586069,bg=#e1e4e8] %Y-%m-%d  %I:%M %p #[fg=#2188ff,bg=#e1e4e8,nobold,nounderscore,noitalics]#[fg=#1f2428,bg=#2188ff,bold] CPU: #&#123;cpu_percentage&#125;#[fg=#1f2428,bg=#2188ff,bold] MEM: #&#123;ram_percentage&#125;#[fg=#2188ff,bg=#2188ff,bold] &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># SPLIT WINDOW</span></span><br><span class="line">new -s lz -n win1 -c ~   <span class="comment"># ... create new session (1) with new window (0)</span></span><br><span class="line"></span><br><span class="line">select-window -t win1       <span class="comment"># select myWindow (0)</span></span><br><span class="line">splitw -v -p 50 -t win1 -c ~/     <span class="comment"># split myWindow (0) vertically into halves(50 percent)</span></span><br><span class="line"><span class="comment">#send-keys -t lz:win1.1 &quot;conda deactivate &amp;&amp;source ./install/setup.zsh&amp;&amp;source /opt/ros/foxy/setup.zsh&quot; Enter</span></span><br><span class="line"><span class="comment">#send-keys -t lz:win1.2 &quot;conda deactivate &amp;&amp;source ./install/setup.zsh&amp;&amp;source /opt/ros/foxy/setup.zsh&quot; Enter</span></span><br><span class="line"></span><br><span class="line">new-window -n win2 -c ~/</span><br><span class="line">select-window -t win2</span><br><span class="line">splitw -v -p 50 -t win2 -c ~/</span><br><span class="line"></span><br><span class="line">new-window -n sys -c ~/</span><br><span class="line">select-window -t sys</span><br><span class="line">splitw -h -p 50 -t sys</span><br><span class="line">send-keys -t lz:sys.2 <span class="string">&quot;htop&quot;</span> Enter</span><br><span class="line"></span><br><span class="line">select-window -t win1</span><br><span class="line">select-pane -t 1</span><br></pre></td></tr></table></figure>
<h2 id="解决ros2终端无法tab补全">解决ROS2终端无法tab补全</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /opt/ros/humble/setup.zsh</span><br><span class="line"><span class="comment"># 末尾添加下面指令</span></span><br><span class="line">complete -o nospace -o default -F _python_argcomplete <span class="string">&quot;ros2&quot;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/06/12/slam-theory/manifold-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/12/slam-theory/manifold-integration/" class="post-title-link" itemprop="url">从IMU预积分理解最大后验概率问题及李代数应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-12 17:36:16" itemprop="dateCreated datePublished" datetime="2023-06-12T17:36:16+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 16:15:51" itemprop="dateModified" datetime="2023-06-14T16:15:51+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/06/12/slam-theory/manifold-integration/" class="post-meta-item leancloud_visitors" data-flag-title="从IMU预积分理解最大后验概率问题及李代数应用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="从IMU预积分理解最大后验概率问题及李代数应用" href="/2023/06/12/slam-theory/manifold-integration/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6de792b20332fd968c280dccbaee3292" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="本文内容">本文内容</h2>
<p>为了能够更深刻地理解</p>
<ol type="1">
<li>后端优化中的最小二乘问题</li>
<li>李代数在定位后端的应用</li>
</ol>
<p>这两个问题，本文使用IMU预积分作为一个实际问题来联系上面两个内容。IMU预积分可以在欧拉角表达下进行，但是更优的方法是在流形（特殊正交群<span class="math inline">\(SO(3)\)</span>是一种流形）上进行。因此，本文使用论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1512.02363">《On-Manifold Preintegration for Real-TimeVisual-Inertial Odometry》</a>提出的IMU预积分方法作为应用实例，在讲述方法的同时将上面两个问题结合其中，使得读者不止对理论基础能够有所了解，也能够明白最小二乘和李代数是如何被用来解决实际问题的。</p>
<h2 id="一基础理论知识">一、基础理论知识</h2>
<p>关于定位后端优化是如何从最大后验概率形式变成最小二乘问题，可以阅读笔者的两篇文章：《后端优化如何从最大后验概率到最小二乘（理论篇）/（应用篇）》</p>
<p>关于李代数基础知识可以阅读笔者这篇文章：《SLAM/定位中李代数基础概念及公式》（李代数基础知识也可以阅读SLAM十四讲的相应内容）</p>
<h3 id="重要定理性质备忘">重要定理/性质备忘</h3>
<p>PS:这部分直接跳过，后文推导过程中使用到这些性质再回头看即可</p>
<p><strong>斜对称矩阵性质</strong></p>
<p><span class="math display">\[
\begin{array}{lcl}
\boldsymbol{a}^{\wedge}\boldsymbol{b} = -\boldsymbol{b}^{\wedge}\boldsymbol{a} &amp;&amp; \forall \boldsymbol{a,b} \in \mathbb{R}^3
\end{array}\tag{1-1}
\]</span></p>
<p><strong>指数映射公式</strong></p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge}) = \mathbf{I}+\frac{\sin{(||\boldsymbol{\phi}||)}}{||\boldsymbol{\phi}||}\boldsymbol{\phi}^{\wedge}+\frac{1-\cos{(||\boldsymbol{\phi}||)}}{||\boldsymbol{\phi}||^2}(\boldsymbol{\phi}^{\wedge})^2\tag{1-2}
\]</span></p>
<p><strong>指数映射一阶近似</strong></p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge})\approx \mathbf{I}+\boldsymbol{\phi}^{\wedge}\tag{1-3}
\]</span></p>
<p><strong>向量形式的指数/对数映射</strong></p>
<p>为了方便，我们记<span class="math inline">\(\operatorname{Exp}(\cdot)\)</span>和<span class="math inline">\(\operatorname{Log}(\cdot)\)</span>为向量形式的对数和指数映射</p>
<p><span class="math display">\[
\begin{array}{}
\operatorname{Exp}:&amp;\mathbb{R}^3 \rightarrow SO(3)\\
\operatorname{Log}:&amp;SO(3)\rightarrow \mathbb{R}^3
\end{array}\tag{1-4}
\]</span></p>
<p><strong>BCH一阶近似</strong></p>
<p><span class="math display">\[
\operatorname{Exp}(\phi+\delta{\phi})\approx \operatorname{Exp}(\phi)\operatorname{Exp}(J_r(\phi)\delta{\phi})\tag{1-5}
\]</span></p>
<p>其中，<span class="math inline">\(J_r(\phi)\)</span>称为右雅可比矩阵</p>
<p>BCH一阶近似还有另一种写法</p>
<p><span class="math display">\[
\operatorname{Log}\left(\operatorname{Exp}(\phi)\operatorname{Exp}(\delta{\phi})\right)\approx 
\phi + J_r^{-1}(\phi)\delta{\phi}\tag{1-6}
\]</span></p>
<p><strong>指数映射性质</strong></p>
<p><span class="math display">\[
R\operatorname{Exp}(\phi)R^T=\operatorname{Exp}(R\phi^{\wedge}R^T)=\operatorname{Exp}(R\phi)\tag{1-7}
\]</span></p>
<p>上式也可得</p>
<p><span class="math display">\[
\operatorname{Exp}(\phi)R = R\operatorname{Exp}(R^T\phi)\tag{1-8}
\]</span></p>
<p>另有，当<span class="math inline">\(\delta{\phi}\)</span>为微小量</p>
<p><span class="math display">\[
\operatorname{Exp}(-\delta{\phi})^T=\operatorname{Exp}(\delta{\phi})\tag{1-9}
\]</span></p>
<p><strong>右雅可比矩阵性质</strong></p>
<p>在公式（1-5）中的<span class="math inline">\(J_r(\phi)\)</span>，如果<span class="math inline">\(\phi\)</span>是微小量，则其近似为单位矩阵。记为</p>
<p><span class="math display">\[
J_r(\delta{\phi})\approx\mathbf{I},\quad \text{when }\delta{\phi}\text{ is small}\tag{1-10}
\]</span></p>
<p><strong>旋转矩阵的扰动模型</strong></p>
<p>当旋转矩阵的分布具有如下形式：</p>
<p><span class="math display">\[
\tilde{R}=R\operatorname{Exp}(\epsilon),\quad \epsilon \sim \mathcal{N}(0,\Sigma)\tag{1-11}
\]</span></p>
<p>其负对数似然（negative log-likelihood）有如下形式</p>
<p><span class="math display">\[
\begin{split}
\mathcal{L}(R)&amp;=\frac{1}{2}||\operatorname{Log}(R^{-1}\tilde{R})||^2_{\Sigma}+const\\
&amp;=\
\frac{1}{2}||\operatorname{Log}(\tilde{R}^{-1}R)||^2_{\Sigma}+const
\end{split}\tag{1-12}
\]</span></p>
<h2 id="二问题引出">二、问题引出</h2>
<p>目前SLAM方案包含前端和后端。前端使用视觉/激光，融合IMU数据输出一个里程计;后端尝试从历史轨迹和回环检测中优化出更准确的历史位姿。IMU在前后端都承担一个比较重要的角色。IMU数据进行积分，可以的到旋转和位置的估计，这个估计可以用来做视觉/点云匹配的初始位姿。IMU积分需要以某一帧的状态作为基础往下持续累加，但是SLAM后端的优化会改变历史轨迹位姿，导致IMU积分需要重新计算。为了避免重复积分的问题，可以将IMU的积分形式变化为对两个关键帧之间数据进行累积，获得两帧之间的相对状态变化，此称为<strong>IMU预积分</strong></p>
<figure>
<img src="./imgs/01-keyframes_imu_pre.png" alt="" /><figcaption>IMU预积分</figcaption>
</figure>
<h3 id="imu预积分积分">IMU预积分/积分</h3>
<p><strong>IMU积分</strong> : 以某一时刻的状态为基础（位姿、速度），对后续的IMU输出（角速度、加速度）进行积分（累加），得到后续时刻的状态（位姿、速度）</p>
<p><strong>IMU预积分</strong> ： 将两帧之间的IMU输出（角速度、加速度）进行积分（累加），得到两帧之间的相对状态（相对旋转、相对速度、相对位置）</p>
<h3 id="坐标系">坐标系</h3>
<figure>
<img src="./imgs/02-coordinate_system.png" alt="" /><figcaption>坐标系定义</figcaption>
</figure>
<p>本文以视觉惯性SLAM为应用场景。IMU坐标系又称作Body坐标系，相机坐标系（Cam）与Body坐标系有一个固定位姿变换<span class="math inline">\(T_{BC}\)</span>。车辆位姿为车辆在世界（World）坐标系下的姿态<span class="math inline">\(T_{WB}=(R_{WB},_W\boldsymbol{p})\)</span></p>
<h3 id="推导的最终目的重要">推导的最终目的（重要！！）</h3>
<p><strong>推导最终目的是为了能够将预积分后的结果（状态State）构造成最小二乘形式，也就是误差的平方</strong></p>
<p>为了能够获得最小二乘形式，需要将状态构造成真值+高斯噪声的形式，也就是测量值的似然函数，这样，只需要对似然函数取负对数即可。注意，还需要获得噪声的协方差表达，因为协方差的倒数，即信息矩阵，需要用来对二次项加权</p>
<p><span class="math display">\[
\begin{array}{lcl}
\tilde{\mathcal{X}} = \mathcal{X} \oplus \epsilon, &amp;&amp; \epsilon \sim \mathcal{N}\left(0,\Sigma\right)\tag{2-1}
\end{array}
\]</span></p>
<p>上述中<span class="math inline">\(\mathcal{X}\)</span>表示状态，通常是旋转、平移、速度、IMU偏差等。上面公式之所以用复合符号<span class="math inline">\(\oplus\)</span>是因为有些状态变量，比如旋转是不能直接相加的，对于旋转矩阵，<span class="math inline">\(\oplus\)</span>是矩阵乘法</p>
<p>只要我们推导出公式（2-1），就可以将高斯分布用负对数的形式变化为最小二乘形式</p>
<p><span class="math display">\[
\underset{\mathcal{X}}{\operatorname{argmin}}||\tilde{\mathcal{X}}\ominus\mathcal{X}||^2_{\Sigma}\tag{2-2}
\]</span></p>
<p><strong>重申，我们需要推导出以下内容</strong></p>
<ol type="1">
<li>状态向量的高斯分布形式（真值+高斯噪声）</li>
<li>噪声的协方差表达</li>
</ol>
<h3 id="方法要点重要">方法要点（重要！！）</h3>
<ol type="1">
<li>所有的推导都在流形（李群）上推导。本文的推导只用到了特殊正交群<span class="math inline">\(SO(3)\)</span>。这样，优化过程可以在李代数空间上进行，不用考虑旋转矩阵的约束</li>
<li>为了避免优化的时候每一个IMU测量就需要增加一个优化因素，将两个关键帧之间的的所有IMU数据积分作为一个约束加入后端优化。（常见做法）</li>
<li>将IMU的积分公式重新推导成IMU预积分形式，使得当后端优化改变历史位姿时，不需要重新执行积分过程</li>
</ol>
<h3 id="推导过程总述">推导过程总述</h3>
<ol type="1">
<li>根据IMU模型，构造IMU积分形式（在流形上进行推导，使得优化可以在李代数空间上进行，不需要考虑旋转的约束）</li>
<li>将IMU积分公式变化为在两个关键帧之间所有IMU测量的积分</li>
<li>构造状态变化的预积分形式，使得积分过程在历史位姿由于后端优化变化之后不需要重新执行。此时还依赖历史时刻的IMU偏差</li>
<li>将噪声从预积分公式从预积分公式中剥离出来，构造（2-1）的标准形式</li>
<li>推导协方差的递推形式</li>
<li>将历史时刻的Bias从预积分公式中剥离，使得预积分公式完全不依赖历史时刻的状态</li>
<li>推导当IMU偏差更新的时候，如何更新预积分结果，避免重复计算</li>
</ol>
<h2 id="三状态向量及优化目标">三、状态向量及优化目标</h2>
<p>状态向量（State）描述<span class="math inline">\(i\)</span>时刻车辆的旋转、位置、速度、IMU偏差</p>
<p><span class="math display">\[
\textbf{x}_i\overset{\cdot}{=}[\text{R}_i,\textbf{p}_i,\textbf{v}_i,\textbf{b}_i]\tag{3-1}
\]</span></p>
<p>车辆（Body）坐标系与IMU坐标系假设为相同坐标系，因此上式也是<span class="math inline">\(i\)</span>时刻的IMU状态</p>
<p>其中</p>
<ul>
<li><span class="math inline">\(\textbf{v}_i \in \mathbb{R}^3\)</span></li>
<li><span class="math inline">\(\textbf{b}_i = [\textbf{b}_i^g \quad \textbf{b}_i^a] \in \mathbb{R}^6\)</span>是角速度（gyroscope）和加速度（accelerometer）的偏差</li>
</ul>
<hr />
<p><strong>记下列符号</strong></p>
<ul>
<li><p><span class="math inline">\(\mathcal{K}_k\)</span>为<span class="math inline">\(k\)</span>时刻之前的所有关键帧</p></li>
<li><p>并记状态集合为</p></li>
</ul>
<p><span class="math display">\[
\mathcal{X}_k \overset{\cdot}{=}\{\textbf{x}_i\}_{i\in \mathcal{K}_k}\tag{3-2}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathcal{I}_{ij},(i,j)\in \mathcal{K}_k\)</span>为关键帧<span class="math inline">\(i,j\)</span>之间的所有IMU测量</li>
</ul>
<hr />
<p>似然函数</p>
<p><span class="math display">\[
\begin{split}
p(\mathcal{X}_k|\mathcal{I}_k) &amp; \propto p(\mathcal{X}_0)p(\mathcal{I}_k|\mathcal{X}_k)\\
&amp;=\
p(\mathcal{X}_0)\prod_{(i,j)\in \mathcal{K}_k}p(\mathcal{I}_{ij}|\textbf{x}_i, \textbf{x}_j)
\end{split}\tag{3-3}
\]</span></p>
<p>其中用到了独立同分布性质和马尔可夫假设</p>
<hr />
<p>优化的最小二乘形式</p>
<p><span class="math display">\[
\begin{split}
\mathcal{X}^{*}_k
&amp;=\
\underset{\mathcal{K}_k}{\operatorname{argmin}} -\log_ep(\mathcal{X}_k|\mathcal{I}_k)\\
&amp;=\
\underset{\mathcal{K}_k}{\operatorname{argmin}}\sum_{(i,j)\in \mathcal{K}_k}||\mathbf{r}_{\mathcal{I}_{ij}}||^2_{\Sigma_{ij}} + ||\textbf{r}_0||^2_{\Sigma_0}
\end{split}\tag{3-4}
\]</span></p>
<h2 id="四imu模型">四、IMU模型</h2>
<p><span class="math display">\[
_\text{B}\tilde{\boldsymbol{\omega}}(t)= {_\text{B}\boldsymbol{\omega(t)}} + \textbf{b}^g(t)+ \boldsymbol{\eta}^g(t)\tag{4-1}
\]</span></p>
<p><span class="math display">\[
_\text{B}\tilde{\textbf{a}}(t)=R^T_{\text{WB}}(t)\left({_\text{W}\textbf{a}(t)} - {_\text{W}\textbf{g}}\right) + \textbf{b}^a(t) + \boldsymbol{\eta}^a(t)\tag{4-2}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(_\text{B}\)</span> 前下标意味着该量是在Body坐标系下。如 <span class="math inline">\(_\text{B}\tilde{\boldsymbol{\omega}}(t)\)</span>是在Body坐标系下的角速度，也就是IMU陀螺仪的输出</li>
<li><span class="math inline">\(\textbf{b}^g,\textbf{b}^a\)</span>是IMU角速度和加速度的偏差，这两者也是一个随着时间缓慢变化的量</li>
<li><span class="math inline">\(\boldsymbol{\eta}^g, \boldsymbol{\eta}^a\)</span>是角速度和加速度的噪声。均值为0的高斯噪声</li>
</ul>
<p>对于离散（discret）形式的高斯噪声<span class="math inline">\(\boldsymbol{\eta}^{gd}, \boldsymbol{\eta}^{ad}\)</span>，他们的协方差与连续形式高斯噪声的功率谱强度具有如下关系</p>
<p><span class="math display">\[
\text{Cov}(\boldsymbol{\eta}^{gd}) = \frac{1}{\Delta{t}}\text{Cov}(\boldsymbol{\eta}^{g})\tag{4-3}
\]</span></p>
<p>其中<span class="math inline">\(\Delta{t}\)</span>是采样时间周期</p>
<h2 id="五运动模型及积分">五、运动模型及积分</h2>
<p><strong><em>为了使得整体思路清晰，简化推导过程，后文都会重点放在状态向量中的旋转部分</em></strong></p>
<h3 id="运动模型">运动模型</h3>
<p><span class="math display">\[
\begin{split}
&amp;\dot{R}_{\text{WB}}=R_{\text{WB}}\ {_{\text{B}}\boldsymbol{\omega}^{\wedge}}\\
\end{split}\tag{5-1}
\]</span></p>
<p>上式中<span class="math inline">\(\dot{R}_{\text{WB}}\)</span>表示<span class="math inline">\({R}_{\text{WB}}\)</span>的导数。上式是旋转矩阵角运动方程，具体推导过程读者可以查找旋转矩阵求导相关资料</p>
<h3 id="运动模型的积分">运动模型的积分</h3>
<p>假设<span class="math inline">\(_{\text{B}}\boldsymbol{\omega}\)</span>在时间间隔<span class="math inline">\([t,t+\Delta{t}]\)</span>内保持不变，则公式（5-1）的<strong>离散形式积分</strong> 为</p>
<p><span class="math display">\[
R_{\text{WB}}(t+\Delta{t})=R_{\text{WB}}(t)\operatorname{Exp}\Big({_{\text{B}}\boldsymbol{\omega}}(t)\Delta{t}\Big)\tag{5-2}
\]</span></p>
<p>公式（5-2）是微分方程（5-1）的解。如果这里思维卡住了，不要深究，记住（5-2）的结论即可</p>
<p>将IMU模型——公式（4-1）带入公式（5-1），可得</p>
<p><span class="math display">\[
R(t+\Delta{t})=R(t)\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}(t)-\textbf{b}^g(t)-\boldsymbol{\eta}^{gd}(t)\right)\Delta{t}\Big) \tag{5-3}
\]</span></p>
<p>上式中<span class="math inline">\(\boldsymbol{\eta}^{gd}(t)\)</span>是高斯噪声的离散形式，且协方差与连续形式的功率谱强度有公式（4-3）的联系</p>
<p>公式（5-3）去掉了上下标，不过现在应该不会引起歧义了</p>
<p><strong><em>要注意的是</em></strong> ，公式（5-3）是假设在IMU的采样周期<span class="math inline">\(\Delta{t}\)</span>内角速度是不变的，这一点虽然不是事实，但是可以通过较高频率的IMU避免由于这一点引起的误差。（常见的IMU频率为200-500Hz）</p>
<h3 id="运动模型积分的累积形式">运动模型积分的累积形式</h3>
<p>公式（5-3）是对一个IMU的测量数据做积分，为了得到两个关键帧之间的积分，我们将关键帧<span class="math inline">\((i,j)\)</span>之间的所有IMU测量都累计起来，可以得到如下形式</p>
<p><span class="math display">\[
R_j = R_i\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{5-4}
\]</span></p>
<p>由于偏差是缓慢变化的（所谓的布朗运动，也就是白噪声的积分），所以在本文中，我们令关键帧<span class="math inline">\((i,j)\)</span>之间的偏差保持不变</p>
<p><span class="math display">\[
\boldsymbol{\eta}^{gd}_i=\boldsymbol{\eta}^{gd}_{i+1}=...=\boldsymbol{\eta}^{gd}_{j-1}\tag{5-5}
\]</span></p>
<h2 id="六预积分相对增量形式">六、预积分/相对增量形式</h2>
<p>公式（5-4）让我们根据IMU的输出得到了两帧之间旋转的约束，但是公式（5-4）等号的右侧与<span class="math inline">\(i\)</span>时刻的旋转和 <strong>偏差</strong> 相关，也就是与<span class="math inline">\(i\)</span>时刻的状态 <span class="math inline">\(\textbf{x}_i\)</span>相关。这里的缺憾在于，当我们在后端优化对历史轨迹优化之后，<span class="math inline">\(\textbf{x}_i\)</span>会改变，这样公式（5-4）就需要重新计算。为了避免重复计算，我们将公式（5-4）进行调整为相对增量形式</p>
<p><span class="math display">\[
\Delta{R_{ij}}\overset{\cdot}{=}\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{6-1}
\]</span></p>
<p><strong><em>要注意的是</em></strong> ，公式（6-1）依旧与<span class="math inline">\(i\)</span>时刻的偏差<span class="math inline">\(\boldsymbol{\eta}^{gd}_i\)</span>。我们暂时忽略这一点。在第九节，我们推导当偏差改变的时候，如何避免重复计算公式（6-1）</p>
<h2 id="七将噪声项独立构造高斯分布形式">七、将噪声项独立构造高斯分布形式</h2>
<p>公式（6-1）已经使用IMU的输出将<span class="math inline">\(i,j\)</span>时刻的旋转联系起来。但是公式（6-1）之中将噪声项杂糅在各个累积项之中，这导致了我们无法简单地写出<span class="math inline">\(\Delta{R_{ij}}\)</span>的概率分布函数。回顾第二节，我们的目标是构造标准的测量方程形式（2-1），这样我们才可以将MAP问题改写为最小二乘问题。为了达到这一个目的，我们进一步将噪声项独立出来</p>
<p>我们首先利用BCH一阶近似公式，即公式（1-5），将噪声项独立。公式（6-1）可以写成</p>
<p><span class="math display">\[
\Delta{R_{ij}}\overset{eq(1-5)}{\approx}\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_i\right) \Delta{t} \Big)\
\operatorname{Exp}\left(-J_r^k\boldsymbol{\eta}^{gd}_k\Delta{t}\right)\tag{7-1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
J_r^k \overset{\cdot}{=}J_r^k\left(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_i\right)\Delta{t}\right)\tag{7-2}
\]</span></p>
<p>我们记</p>
<p><span class="math display">\[
\Delta{\tilde{R}_{ij}} \overset{\cdot}{=}\
\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_i\right)\Delta{t}\Big)\tag{7-3}
\]</span></p>
<p>观察公式（7-1），我们将累积中的最后两项抽出来</p>
<p><span class="math display">\[
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 2}-\textbf{b}^g_i\right) \Delta{t} \Big)\
\Bigg[\
\operatorname{Exp}\left(-J_r^{j \text{-} 2}\boldsymbol{\eta}^{gd}_{j \text{-} 2}\Delta{t}\right)\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 1}-\textbf{b}^g_i\right) \Delta{t} \Big)\
\Bigg]\
\operatorname{Exp}\left(-J_r^{j \text{-} 1}\boldsymbol{\eta}^{gd}_{j \text{-} 1}\Delta{t}\right)\tag{7-3}
\]</span></p>
<p>利用公式（1-8）<span class="math inline">\(\operatorname{Exp}(\phi)R = R\operatorname{Exp}(R^T\phi)\)</span>，我们可以将中间两项改写如下</p>
<p><span class="math display">\[
\begin{split}
&amp;\operatorname{Exp}\left(-J_r^{j \text{-} 2}\boldsymbol{\eta}^{gd}_{j \text{-} 2}\Delta{t}\right)\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 1}-\textbf{b}^g_i\right) \Delta{t} \Big)\\
=&amp;\
\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_{j \text{-} 1}-\textbf{b}^g_i\right) \Delta{t} \Big)\
\operatorname{Exp}\Big(-\Delta{\tilde{R}^T_{j\text{-}1j}}J_r^{j \text{-} 2}\boldsymbol{\eta}^{gd}_{j \text{-} 2}\Delta{t}\Big)
\end{split}\tag{7-4}
\]</span></p>
<p>对公式（7-1）从后往前应用公式（7-4），我们可以将噪声项独立出来</p>
<p><span class="math display">\[
\begin{split}
\Delta{R_{ij}}\
&amp;=\
\Delta{\tilde{R}_{ij}}\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(-\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\Big)\\
&amp;\overset{\cdot}{=}\
\Delta{\tilde{R}_{ij}}\
\operatorname{Exp}(-\delta\phi_{ij})
\end{split}\tag{7-5}
\]</span></p>
<p>于是，我们可以将<span class="math inline">\(\Delta{\tilde{R}_{ij}}\)</span>写为如公式（2-1）的标准形式，回顾公式（1-9）<span class="math inline">\(\operatorname{Exp}(-\delta{\phi})^T=\operatorname{Exp}(\delta{\phi})\)</span></p>
<p><span class="math display">\[
\begin{split}
\Delta{\tilde{R}_{ij}}\
=\
\Delta{R_{ij}}\
\operatorname{Exp}(\delta\phi_{ij})\
\end{split}\tag{7-6}
\]</span></p>
<h2 id="八协方差矩阵的递归形式">八、协方差矩阵的递归形式</h2>
<p>公式（7-6）推导出了如公式（2-1）的标准形式，但是还差一点，就是噪声项<span class="math inline">\(\operatorname{Exp}(-\delta\phi_{ij})\)</span>是否符合0均值的高斯分布，以及它的协方差是怎么样的。</p>
<p>这一节的目的是推导噪声项的分布以及协方差的增量形式</p>
<p>让我们从公式（7-5）摘录噪声项</p>
<p><span class="math display">\[
\operatorname{Exp}(-\delta\phi_{ij})\
=\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(-\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\Big)\tag{8-1}
\]</span></p>
<p>记</p>
<p><span class="math display">\[
\xi_k=\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\tag{8-2}
\]</span></p>
<p>由于<span class="math inline">\(\boldsymbol{\eta}^{gd}_{k}\)</span>是个极微小量，而且<span class="math inline">\(\delta{\phi}_{ij}\)</span>也是个微小量，所以<span class="math inline">\(\xi_k\)</span>整体也是微小量，因此，根据性质（1-9）</p>
<p><span class="math display">\[
J_r(\xi_k)\approx \mathbf{I}\tag{8-3}
\]</span></p>
<p>因此，我们根据公式（1-6），将（8-1）可以写成</p>
<p><span class="math display">\[
\operatorname{Exp}(-\delta\phi_{ij})\
=\
\operatorname{Exp}\left(-\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\right)\tag{8-4}
\]</span></p>
<p>即</p>
<p><span class="math display">\[
\delta\phi_{ij}\
\approx\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\tag{8-5}
\]</span></p>
<hr />
<p>从公式（8-5）我们可以看到，公式（7-6）的噪声项是高斯噪声<span class="math inline">\(\boldsymbol{\eta}^{gd}\)</span>的线性组合，因此其本身也是高斯噪声</p>
<p>我们接下来进一步推导这个噪声的协方差的表达形式</p>
<p><span class="math display">\[
\begin{split}
\delta\phi_{ij}\
&amp;\approx\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\\
&amp;=\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k+1,j}}J_r^k\boldsymbol{\eta}^{gd}_k\Delta{t}\
+\
\overset{=\mathbf{I}_{3\times 3}}{\overbrace{\Delta{\tilde{R}^T_{j,j}}}}\
J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}\\
&amp;=\
\sum^{j-1}_{k=i}(\overset{=\Delta{\tilde{R}_{k+1,j}}}{\overbrace{\Delta{\tilde{R}_{k+1,j-1}}\Delta{\tilde{R}_{j-1,j}}}})\
+\
J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}\\
&amp;=\
\Delta{\tilde{R}^T_{j-1,j}}\sum^{j-2}_{k=i}\Delta{\tilde{R}^T_{k+1,j-1}}J_r^k\boldsymbol{\eta}^{gd}_k\Delta{t}\
+\
J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}\\
&amp;=\
\Delta{\tilde{R}^T_{j-1,j}}\delta{\phi}_{ij-1}+J_r^{j-1}\boldsymbol{\eta}^{gd}_{j-1}\Delta{t}
\end{split}\tag{8-6}
\]</span></p>
<p>根据高斯分布协方差的性质</p>
<p><span class="math display">\[
\Sigma_{ij}\
=\
\Delta{\tilde{R}^T_{j-1,j}}\
\Sigma_{ij-1}\
\Delta{\tilde{R}_{j-1,j}}\
+\
(J_r^{j-1}\Delta{t})\
\Sigma_{\boldsymbol{\eta}}\
(J_r^{j-1}\Delta{t})^T\tag{8-7}
\]</span></p>
<p>同时我们可以令协方差的初始值<span class="math inline">\(\Sigma_{ii}=\textbf{0}_{9\times 9}\)</span></p>
<p>于是，我们就得出了协方差的递归形式</p>
<h2 id="九偏差项bias更新">九、偏差项Bias更新</h2>
<h3 id="暂时性总结">暂时性总结</h3>
<p>到目前位置，我们已经推导出了如下内容</p>
<ol type="1">
<li>测量方程的标准表达形式，即公式（7-6）</li>
<li>测量方程噪声协方差的递归表达形式，即公式（8-7）</li>
</ol>
<p>但是要注意，公式（7-6）里面还偏差项<span class="math inline">\(\textbf{b}_i^g\)</span>。也就是其依旧依赖<span class="math inline">\(i\)</span>时刻的系统状态。那么如何在偏差更新的时候，避免测量方程的重复计算？这就是本节要推导的内容</p>
<h3 id="纳入偏差更新">纳入偏差更新</h3>
<p>当偏差项更新</p>
<p><span class="math display">\[
\hat{\textbf{b}} \leftarrow \bar{\textbf{b}}+\delta{\textbf{b}}\tag{9-1}
\]</span></p>
<p>我们希望计算更新后的测量<span class="math inline">\(\Delta{\tilde{R}_{ij}(\hat{\textbf{b}}^g_i)}\)</span>，相比与原先的值<span class="math inline">\(\Delta{\tilde{R}_{ij}(\bar{\textbf{b}}^g_i)}\)</span>的更新量</p>
<p>这样我们就不需要重复计算<span class="math inline">\(\Delta{\tilde{R}_{ij}}\)</span></p>
<p>把<span class="math inline">\(\hat{\textbf{b}}^g_i\)</span>代入<span class="math inline">\(\Delta{\tilde{R}_{ij}}\)</span>的表达式（7-3）</p>
<p><span class="math display">\[
\Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
=\
\prod^{j-1}_{k=i}\
\operatorname{Exp}\Big(
    \left(
        \tilde{\boldsymbol{\omega}}_k-\hat{\textbf{b}}^g_i
    \right)\Delta{t}
    \Big)\tag{9-2}
\]</span></p>
<p>将公式（9-1）代入（9-2），并利用BCH一阶近似公式（1-5）展开</p>
<p><span class="math display">\[
\begin{split}
    \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
        &amp; = \prod^{j-1}_{k=i}\
            \operatorname{Exp}\Big(
                \left(
                    \tilde{\boldsymbol{\omega}}_k-(\bar{\textbf{b}}^g_i+\delta{\textbf{b}}^g_i)
                \right)\Delta{t}
            \Big)\\
        &amp; = \prod^{j-1}_{k=i}\
            \operatorname{Exp}\Big(
                \left(\tilde{\boldsymbol{\omega}}_k-\bar{\textbf{b}}^g_i\right)\Delta{t}
            \Big)\
            \operatorname{Exp}\Big(
                -J_r^k\delta{\textbf{b}}^g_i\Delta{t}
            \Big)
\end{split}\tag{9-3}
\]</span></p>
<p>采用推导公式（7-1）到（7-5）的方式，从后往前推，并利用公式（1-8），上式可以写为</p>
<p><span class="math display">\[
\begin{split}
  \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
    =\Delta{\bar{R}_{ij}}\prod^{j-1}_{k=i}\
      \operatorname{Exp}\Big(
        -\Delta{\bar{R}}_{k+1,j}^TJ_r^k\delta{\textbf{b}^g_i}\Delta{t}
      \Big)
\end{split}\tag{9-4}
\]</span></p>
<p>我们再采用类似（8-1）到（8-5）的推导方法，（<span class="math inline">\(\delta{\textbf{b}}\)</span>是一个极小量，所以展开时的右雅可比接近单位矩阵）</p>
<p>公式（9-4）可以写为</p>
<p><span class="math display">\[
\begin{split}
  \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
    &amp; \approx \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \sum^{j-1}_{k=i}-\Delta{\bar{R}}_{k+1,j}^TJ_r^k\delta{\textbf{b}^g_i}\Delta{t}
      \Big)\\
    &amp; \overset{\cdot}{=} \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
        \delta{\textbf{b}^g_i}
      \Big)
\end{split}\tag{9-5}
\]</span></p>
<h2 id="十最小二乘形式误差">十、最小二乘形式/误差</h2>
<p>从公式（1-12）我们提前构造好了旋转的最大似然的负对数形式</p>
<p><span class="math display">\[
\begin{split}
  \mathcal{L}(R) &amp; =
    \frac{1}{2}||\operatorname{Log}(\tilde{R}^{-1}R)||^2_{\Sigma}+const
\end{split}
\]</span></p>
<p>我们已经构造了相对旋转的表达形式（9-5），因此我们可以进一步得出了旋转的误差模型</p>
<p><span class="math display">\[
\begin{split}
  \textbf{r}_{\Delta{R}_{ij}} = 
    \operatorname{Log}\left(
        \bigg(
          \Delta{\bar{R}_{ij}}\
            \operatorname{Exp}\big(
                \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
                \delta{\textbf{b}^g_i}
            \big)
        \bigg)^T
        R_i^TR_j
    \right)
\end{split}\tag{10-1}
\]</span></p>
<h2 id="总结">总结</h2>
<p>本文主要从论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1512.02363">《On-Manifold Preintegration for Real-TimeVisual-Inertial Odometry》</a>出发，挑选其中的旋转矩阵相关内容，目的是为了能够从实际应用出发，联系后端优化的非线性最小二乘优化问题和李群李代数知识，加深理论知识的印象。</p>
<p>再次强调，本文需要拥有一定的李群李代数基础知识，以及后端优化中如何将最大后验概率问题转化到最小二乘问题，没有这两个部分的知识可以参考笔者整理的两篇笔记。</p>
<p><strong>本文只挑选了系统状态中的旋转分量相关的内容。实际上原论文对位置、速度的推导也十分详细。但是太过杂乱的内容不仅对理解整个推导过程思路是如何来的没有帮助，还会让读者一头雾水。</strong></p>
<p>本文首先给出一些基础知识和后续推导用的性质（第一节）</p>
<p>第二节的重点是让读者要明白这么长篇大论的推导过程的线索是什么，最终目的是什么？我们的最终目的是将测量与真实值能够写成如公式（2-1）的标准形式，这样可以直接根据高斯分布的性质将最大似然问题通过负对数转化为最小二乘问题。</p>
<p><span class="math display">\[
\begin{array}{lcl}
\tilde{\mathcal{X}} = \mathcal{X} \oplus \epsilon, &amp;&amp; \epsilon \sim \mathcal{N}\left(0,\Sigma\right)\tag{2-1}
\end{array}
\]</span></p>
<p>第三节到第五节，我们推导了如何根据IMU的输出数据，将关键帧<span class="math inline">\((i,j)\)</span>的位姿中的旋转分量联系起来，即通过公式（5-4）</p>
<p><span class="math display">\[
R_j = R_i\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{5-4}
\]</span></p>
<p>为了避免优化过后关键帧<span class="math inline">\(i\)</span>的状态改变，积分需要重复计算的问题，我们在第六节推导了IMU预积分形式，也就是两帧之间的相对运动形式，即公式（6-1）</p>
<p><span class="math display">\[
\Delta{R_{ij}}\overset{\cdot}{=}\prod^{j-1}_{k=i}\operatorname{Exp}\Big(\left(\tilde{\boldsymbol{\omega}}_k-\textbf{b}^g_k-\boldsymbol{\eta}^{gd}_k\right)\Delta{t}\Big)\tag{6-1}
\]</span></p>
<p>为了构造标准形式（2-1），我们在第七节中将噪声项独立出来，成功构造标准形式，即公式（7-6）</p>
<p><span class="math display">\[
\begin{split}
\Delta{\tilde{R}_{ij}}\
=\
\Delta{R_{ij}}\
\operatorname{Exp}(\delta\phi_{ij})\
\end{split}\tag{7-6}
\]</span></p>
<p>为了在最小二乘问题中使用噪声的协方差矩阵加权，我们在第八节推导了噪声的分布及方差的递归形式，即公式（8-5）</p>
<p><span class="math display">\[
\delta\phi_{ij}\
\approx\
\sum^{j-1}_{k=i}\Delta{\tilde{R}^T_{k\text{+}1j}}J_r^{k}\boldsymbol{\eta}^{gd}_{k}\Delta{t}\tag{8-5}
\]</span></p>
<p>最后，我们来解决如何在IMU偏差更新的时候，避免积分过程需要重复计算的问题，即公式（9-5）</p>
<p><span class="math display">\[
\begin{split}
  \Delta{\tilde{R}}_{ij}(\hat{\textbf{b}}^g_i)\
    &amp; \approx \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \sum^{j-1}_{k=i}-\Delta{\bar{R}}_{k+1,j}^TJ_r^k\delta{\textbf{b}^g_i}\Delta{t}
      \Big)\\
    &amp; \overset{\cdot}{=} \Delta{\bar{R}_{ij}}\
      \operatorname{Exp}\Big(
        \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
        \delta{\textbf{b}^g_i}
      \Big)
\end{split}\tag{9-5}
\]</span></p>
<p>剩下的问题也就自然解决，我们可以根据标准形式构造误差函数的表达，即公式（10-1）</p>
<p><span class="math display">\[
\begin{split}
  \textbf{r}_{\Delta{R}_{ij}} = 
    \operatorname{Log}\left(
        \bigg(
          \Delta{\bar{R}_{ij}}\
            \operatorname{Exp}\big(
                \frac{\partial{\Delta{\bar{R}^{\vee}_{ij}}}}{\partial{\textbf{b}^g}}\
                \delta{\textbf{b}^g_i}
            \big)
        \bigg)^T
        R_i^TR_j
    \right)
\end{split}\tag{10-1}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/06/08/cv/surround-view-projection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/08/cv/surround-view-projection/" class="post-title-link" itemprop="url">超详细！从单应矩阵推导到自动驾驶环视投影应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-08 09:38:44" itemprop="dateCreated datePublished" datetime="2023-06-08T09:38:44+08:00">2023-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 12:07:02" itemprop="dateModified" datetime="2023-06-14T12:07:02+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
    <span id="/2023/06/08/cv/surround-view-projection/" class="post-meta-item leancloud_visitors" data-flag-title="超详细！从单应矩阵推导到自动驾驶环视投影应用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="超详细！从单应矩阵推导到自动驾驶环视投影应用" href="/2023/06/08/cv/surround-view-projection/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::f13a6e5ecc3be4fc943645106759d469" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="本文内容">本文内容</h2>
<p>本文的主要目的在于介绍自动驾驶中环视投影，也就是所谓的俯瞰图/鸟瞰图/BEV图，其背后的计算机视觉原理。环视投影的背后理论基础就是单应矩阵（Homography Matrix）。为了建立从直观到一般形式，本文从以下章节内容展开</p>
<p>在第一节中先规定相机坐标系和图像坐标系，以及介绍常用的车辆坐标系的规定。同时，对相机投影中常使用的齐次坐标做了简要介绍，顺带回顾相机投影方程。</p>
<p>第二节先对单应矩阵做介绍。对于一个空间中一个平面，以及两个不同姿态的相机，两个相机的对该平面的成像之间的联系是单应矩阵。但是如何从相机间的关系推导单应矩阵的具体形式？该节从特殊化形式和一般化形式两个角度对单应矩阵的表达进行推导。</p>
<p>环视投影是多个方向的地面成像结果到一个位于车辆上方，平行于地面往下成像的虚拟相机的成像结果的变换。第三节详细推导这个应用中的投影过程以及相机内外参与单应矩阵的关系。</p>
<p>第四节介绍如何在不知道相机内外参的情况下通过点对匹配的方法求解单应矩阵。</p>
<h2 id="基础知识及相关定义">基础知识及相关定义</h2>
<h3 id="相机坐标系与图像坐标系">相机坐标系与图像坐标系</h3>
<p>在计算机视觉的一般任务中，我们规定<strong>相机坐标系</strong>为光轴（经过相机原点）往前为<span class="math inline">\(Z\)</span>轴正方向，右为<span class="math inline">\(X\)</span>，下为<span class="math inline">\(Y\)</span> 对空间中的点放缩到归一化平面，归一化平面的坐标系定义也类似相机坐标系。 但是在图像中，我们一般令图片的左上角为坐标原点，横轴往右为<span class="math inline">\(u/X\)</span>正方向，竖轴往下为<span class="math inline">\(v/Y\)</span>正方向，又叫<strong>像素坐标系</strong></p>
<p>如下图所示</p>
<figure>
<img src="./imgs/01-pinhole.png" alt="" /><figcaption>相机及像素坐标系</figcaption>
</figure>
<h3 id="车辆坐标系">车辆坐标系</h3>
<p>我们一般规定车的后轮横轴中心在地面的点为坐标系原点，<span class="math inline">\(X\)</span>正方向指向车头，<span class="math inline">\(Y\)</span>轴正方向指向车左</p>
<figure>
<img src="./imgs/02-vehical_coordinate.png" alt="" /><figcaption>车辆坐标系</figcaption>
</figure>
<h3 id="齐次坐标homogeneous-coordinate">齐次坐标（Homogeneous Coordinate）</h3>
<p>当我们对三维空间中一个点<span class="math inline">\(P_1=[X_1,Y_1,Z_1]^T\)</span>做旋转平移变换到另一个点<span class="math inline">\(P_2\)</span>，可以用下面的公式</p>
<p><span class="math display">\[
P_2 = RP_1+\boldsymbol{t}
\]</span></p>
<p>其中<span class="math inline">\(R\in \mathbb{R}^{3\times3}\)</span>为旋转矩阵，<span class="math inline">\(\boldsymbol{t}\in \mathbb{R}^{3\times 1}\)</span>为平移向量</p>
<p>上式也可以将点坐标写为<span class="math inline">\(P_1=[X_1,Y_1,Z_1,1]^T\)</span>的形式，然后用变换矩阵对点做坐标变换</p>
<p><span class="math display">\[
P_2 = T_{21}P_1
\]</span></p>
<p><span class="math display">\[
T_{21} =
\begin{bmatrix}
R&amp;\boldsymbol{t}\\
\boldsymbol{0}&amp;1
\end{bmatrix}\in \mathbb{R}^{4\times 4}
\]</span></p>
<p><span class="math inline">\(T_{21}\)</span>称为变换矩阵;<span class="math inline">\(P_1=[X_1,Y_1,Z_1,1]^T\)</span>这种形式也叫齐次坐标（Homogeneous Coordinate）</p>
<p><strong>注意</strong>：齐次坐标其实有严格的定义，具体形式可以参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87">Wiki:Homogeneous Coordinate</a></p>
<p>同理，在做像素坐标的逆变换，也通常将像素坐标<span class="math inline">\([u,v]^T\)</span>后面添加一个1变为齐次坐标<span class="math inline">\(p=[u,v,1]^T\)</span></p>
<p><span class="math display">\[
p_n=K^{-1}p
\]</span></p>
<h3 id="投影方程">投影方程</h3>
<p>空间中的一个点<span class="math inline">\(P_W\)</span>投影到图像上的点<span class="math inline">\(\boldsymbol{p}\)</span>，我们直接记这个过程为</p>
<p><span class="math display">\[
\begin{split}
\lambda \boldsymbol{p}
&amp;=\
KT_{CW}P_W\\
&amp;=\
\begin{bmatrix}
u&amp;v&amp;1
\end{bmatrix}^T
\end{split}
\]</span></p>
<p>这里面包含了一次齐次坐标的转换（<span class="math inline">\(T_{CW}P_W \in \mathbb{R}^{4\times 1}\)</span>,<span class="math inline">\(K\in \mathbb{R}^{3\times 1}\)</span>），但是不会对理解有歧义</p>
<h2 id="单应矩阵homography-matrix">单应矩阵（Homography Matrix）</h2>
<p>在计算机视觉中，两个相机对于空间中的同一个平面的成像结果可以通过单应矩阵进行映射（相差一个常量系数）</p>
<p>另<span class="math inline">\([x,y,1]^T\)</span>为图片1的像素齐次坐标，<span class="math inline">\([x^{\prime},y^{\prime},1]^T\)</span>为同一个点在图片2的像素齐次坐标，则上面那句话可以等价为如下关系：</p>
<p><span class="math display">\[
\lambda
\begin{bmatrix}
x^{\prime}\\
y^{\prime}\\
1
\end{bmatrix}=
\boldsymbol{H}
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}=
\begin{bmatrix}
h_{00} &amp; h_{10} &amp; h_{20}\\
h_{01} &amp; h_{11} &amp; h_{21}\\
h_{02} &amp; h_{12} &amp; h_{22}
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}\tag{2-1}
\]</span></p>
<p>公式（2-1）中的系数<span class="math inline">\(\lambda\)</span>用来将变换后的坐标归一化（将第三个维度的值放缩为1） <strong>同时要注意，单应矩阵虽然有9个元素，但自由度只有8，可以除以<span class="math inline">\(h_{22}\)</span>进行归一化</strong></p>
<p>下面我们分别从用形象化的解释和一般化的推导来建立单应矩阵与相机内参、外参的关系</p>
<h3 id="特殊形式推导">特殊形式推导</h3>
<p>我们假设空间中有一平面，两个相机<span class="math inline">\(C_1,C_2\)</span>在两个不同的姿态下对这个平面进行成像。同时，我们令世界坐标系（<span class="math inline">\(O_G\)</span>)<span class="math inline">\(的\)</span>Z<span class="math inline">\(轴垂直于该平面，并且令该平面刚好位于世界坐标系的\)</span>XY<span class="math inline">\(平面，这样这个平面上的点\)</span>z$坐标等于0。可以用下图帮忙理解</p>
<figure>
<img src="./imgs/03-multi_camera.png" alt="" /><figcaption>双相机成像统一平面</figcaption>
</figure>
<p>同时，我们记世界坐标系到相机<span class="math inline">\(C_1\)</span>的变换矩阵为<span class="math inline">\(T_{C_1W}\)</span>，到相机<span class="math inline">\(C_2\)</span>的变换矩阵为<span class="math inline">\(T_{C_2W}\)</span>;<span class="math inline">\(K_1,K_2\)</span>为两个相机的内参。</p>
<p>我们现在对平面上的一个点<span class="math inline">\(P_W=[X_w,Y_w,Z_w=0,1]^T\)</span>进行投影，得到在两个相机成像的图片上对应的像素点<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2\)</span>。投影过程具有如下形式</p>
<p><span class="math display">\[
\begin{split}
\lambda_1\boldsymbol{p}_1
&amp;=\
\begin{bmatrix}
u_1\\
v_1\\
1
\end{bmatrix}
=\
K_1T_{C_1W}P_W\\
&amp;=\
K_1
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; r_{02} &amp; t_0\\
r_{10} &amp; r_{11} &amp; r_{12} &amp; t_1\\
r_{20} &amp; r_{21} &amp; r_{22} &amp; t_2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_W\\
Y_W\\
0\\
1
\end{bmatrix}\\
&amp;=\
K_1
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; t_0\\
r_{10} &amp; r_{11} &amp; t_1\\
r_{20} &amp; r_{21} &amp; t_2
\end{bmatrix}
\begin{bmatrix}
X_W\\
Y_W\\
1
\end{bmatrix}\\
&amp;=\
K_1T_{C_1W}^{0:3;0:2,3}P_W
\end{split}
\]</span></p>
<p>上式中<span class="math inline">\(T^{0:3;0:2,3}\)</span>表示变换矩阵前3行的0,1,3列。为了方便记号，我们将<span class="math inline">\(T_{C_1W}^{0:3;0:2,3}\)</span>记为<span class="math inline">\(J_{C_1W}\)</span></p>
<p>同理，我们可以得到图像2的类似投影方程，我们整理如下</p>
<p><span class="math display">\[
\begin{split}
\lambda_1\boldsymbol{p}_1 &amp;= K_1J_{C_1W}P_W\\
\\
\lambda_2\boldsymbol{p}_2 &amp;= K_2J_{C_2W}P_W\\
\end{split}\tag{2-2}
\]</span></p>
<p>注意上式中<span class="math inline">\(P_W=[X_W,Y_W,1]\)</span>，且上式中矩阵相乘的行列数量都是对应的</p>
<p>我们将上式（2-2）重新整理一下，将<span class="math inline">\(P_W\)</span>写为<span class="math inline">\(p_1\)</span>的函数，有</p>
<p><span class="math display">\[
P_W=\lambda_1J_{C_1W}^{-1}K_1^{-1}\boldsymbol{p}_1\tag{2-3}
\]</span></p>
<p>将（2-3）带入（2-2）中的相机2方程</p>
<p><span class="math display">\[
\lambda_2\boldsymbol{p}_2=\lambda_1K_2J_{C_2W}J_{C_1W}^{-1}K_1^{-1}\boldsymbol{p}_1
\]</span></p>
<p>其中<span class="math inline">\(\lambda_1,\lambda_2\)</span>只是为了将投影后的值进行放缩，使得第三个元素的值为1,所以两者可以写成一个，最后我们可以得到如下形式</p>
<p><span class="math display">\[
\begin{split}
&amp;\lambda\boldsymbol{p}_2=\boldsymbol{H}_{21}\boldsymbol{p}_1\\
&amp; \boldsymbol{H}_{21} = K_2J_{C_2W}J_{C_1W}^{-1}K_1^{-1}\\
&amp;J=T^{0:3,0:2,3}
\end{split}\tag{2-4}
\]</span></p>
<p>可以看到，公式（2-4）的形式和公式（2-1）是一样的，同时将单应矩阵与相机的内参外参联系起来</p>
<h3 id="单应矩阵与相机内外参关系的一般形式">单应矩阵与相机内外参关系的一般形式</h3>
<p>上一个小节我们对单应矩阵与相机的内外参之间的关系建立了公式化的联系和直观上的理解。上一小节的推导可以看出，对于空间中的一快平面，存在一个<span class="math inline">\(3 \times 3\)</span>的矩阵（自由度为8）将两个相机对这块平面的成像结果联系起来。</p>
<p>在上一小节中，我们假设世界坐标系与成像平面对齐。我们在这一小节中继续推导更一般的表达形式，这一小节的内容主要参考<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Homography_(computer_vision)">Wiki:Homography (computer vision)</a></p>
<p>由于一般情况下，我们都是知道相机的外参（也就是世界坐标系到相机坐标系的变换关系），所以我们这一节不假设平面的坐标系与世界坐标系对齐，我们假设平面在相机<span class="math inline">\(C_1\)</span>下的法向量为<span class="math inline">\(\boldsymbol{n}\)</span>，平面到相机<span class="math inline">\(C_1\)</span>的距离为<span class="math inline">\(d\)</span>，且对于法向量的方向，我们做如下规定：对于平面上的点<span class="math inline">\(P_{C_1}\)</span>，满足<span class="math inline">\(\boldsymbol{n}^TP_{C_1}+d=0\)</span>，其中<span class="math inline">\(\boldsymbol{n}^TP_{C_1}\)</span>为点到法向量的投影</p>
<figure>
<img src="./imgs/04-homo_general.png" alt="" /><figcaption>单应矩阵的一般形式推导</figcaption>
</figure>
<p>假设相机<span class="math inline">\(C_1\)</span>的外参为<span class="math inline">\(T_{C_1W}=[R_1|\boldsymbol{t}_1]\)</span>，相机<span class="math inline">\(C_2\)</span>的外参为<span class="math inline">\(T_{C_2W}=[R_2|\boldsymbol{t}_2]\)</span>，由变换矩阵的性质，我们可以得到</p>
<p><span class="math display">\[
\begin{split}
T_{WC_1} &amp;= T_{C_1W}^{-1}\\
&amp;= 
\begin{bmatrix}
R_1&amp;\boldsymbol{t}_1\\
\boldsymbol{0}&amp;1
\end{bmatrix}^{-1}\\
&amp;=\
\begin{bmatrix}
R_1^{-1}&amp;-R_1^{-1}\boldsymbol{t}_1\\
\boldsymbol{0}&amp;1
\end{bmatrix}
\end{split}\tag{2-5}
\]</span></p>
<p>所以相机1到相机2的变换矩阵为</p>
<p><span class="math display">\[
\begin{split}
T_{C_2C_1} &amp;= T_{C_2W}T_{WC_1}\\
&amp;= 
\begin{bmatrix}
R_2&amp;\boldsymbol{t}_2\\
\boldsymbol{0}&amp;1
\end{bmatrix}
\begin{bmatrix}
R_1^{-1}&amp;-R_1^{-1}\boldsymbol{t}_1\\
\boldsymbol{0}&amp;1
\end{bmatrix}\\
&amp;=\
\begin{bmatrix}
R_2R_1^{-1}&amp;-R_2R_1^{-1}\boldsymbol{t}_1+\boldsymbol{t}_2\\
\boldsymbol{0}&amp;1
\end{bmatrix}\\
&amp;=\
\begin{bmatrix}
R_{21}&amp;\boldsymbol{t}_{21}\\
\boldsymbol{0}&amp;1
\end{bmatrix}
\end{split}\tag{2-6}
\]</span></p>
<p>根据相机投影关系，我们有</p>
<p><span class="math display">\[
\begin{split}
&amp;\boldsymbol{p}_1=\frac{1}{Z_{C_1}}K_1P_1\\
&amp;\boldsymbol{p}_2=\frac{1}{Z_{C_2}}K_2P_2\\
\end{split}\tag{2-7}
\]</span></p>
<p><span class="math display">\[
P_1 = Z_{C_1}K_1^{-1}\boldsymbol{p}_1\tag{2-8}
\]</span></p>
<p>又<span class="math inline">\(P_1,P_2\)</span>为点<span class="math inline">\(P_W\)</span>在两个相机坐标系下的坐标，这两个点又可以通过下面的变换联系</p>
<p><span class="math display">\[
P_2 = R_{21}P_1 + \boldsymbol{t}_{21}\tag{2-9}
\]</span></p>
<p>联合（2-7）到（2-9），我们可以得出</p>
<p><span class="math display">\[
\boldsymbol{p}_2=\frac{1}{Z_{C_2}}K_2(R_{21}Z_{C_1}K_1^{-1}\boldsymbol{p}_1+\boldsymbol{t}_{21})\tag{2-10}
\]</span></p>
<p>对于平面，我们已经做了如下规定： 在相机<span class="math inline">\(C_1\)</span>坐标系下，对于平面上的点<span class="math inline">\(P_{1}\)</span>，满足<span class="math inline">\(\boldsymbol{n}^TP_{1}+d=0\)</span>，其中<span class="math inline">\(\boldsymbol{n}^TP_{1}\)</span>为点到法向量的投影。即</p>
<p><span class="math display">\[
\frac{\boldsymbol{n}^TP_1}{-d}=1\tag{2-11}
\]</span></p>
<p>将（2-11）带入公式（2-10）中的<span class="math inline">\(\boldsymbol{t}_{21}\)</span>可以得到</p>
<p><span class="math display">\[
\begin{split}
\boldsymbol{t}_{21}
&amp;=\
\boldsymbol{t}_{21}\frac{\boldsymbol{n}^TP_1}{-d}\\
&amp;=\
\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{-d}P_1\\
&amp;\overset{2-8}{=}\
-\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{d}Z_{C_1}K_1^{-1}\boldsymbol{p}_1
\end{split}\tag{2-12}
\]</span></p>
<p>将（2-12）代入公式（2-10）中，我们可以得到</p>
<p><span class="math display">\[
\begin{split}
\boldsymbol{p}_2&amp;=\frac{1}{Z_{C_2}}K_2\left(R_{21}-\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{d}\right)Z_{C_1}K_1^{-1}\boldsymbol{p}_1\\
&amp;=\
\frac{Z_{C_1}}{Z_{C_2}}K_2H_{21}K_1^{-1}\boldsymbol{p_1}
\end{split}\tag{2-13}
\]</span></p>
<p>于是，我们可以得到单应矩阵的表达形式</p>
<p><span class="math display">\[
H_{21} = R_{21}-\frac{\boldsymbol{t}_{21}\boldsymbol{n}^T}{d}\tag{2-14}
\]</span></p>
<p>如果我们将<span class="math inline">\(R_{21}\)</span>与<span class="math inline">\(t_{21}\)</span>的展开形式，即公式（2-6），则我们可以得到</p>
<p><span class="math display">\[
H_{21} = R_2R_1^{-1} - \frac{\left(-R_2R_1^{-1}\boldsymbol{t}_1+\boldsymbol{t}_2\right)\boldsymbol{n}^T}{d}\tag{2-15}
\]</span></p>
<hr />
<p>这篇论文<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1145/3343031.3350885">Online Camera Pose Optimization for the Surround-viewSystem</a>，中关于环视图的地平面投影一章的公式推导很详细，作为基础理论学习很不错。</p>
<h2 id="环视投影bev">环视投影/BEV</h2>
<h3 id="基础概念">基础概念</h3>
<p>从前文中我们可以得出，对于空间中的一个平面，不同位姿的相机成像的图片可以通过单应矩阵在不同的图片中进行变换。对于自动驾驶车辆来说，环绕车周的多个摄像头(一般是4个及以上)会同时拍摄到地面。同时，我们可以假设有一个虚拟相机位于车辆正上方往下拍摄。这样，车周的摄像头可以根据地平面对应的单应矩阵投影到虚拟相机，得到所谓的俯瞰图/鸟瞰图，也就是 <strong>BEV(Bird Eye View)</strong></p>
<h3 id="图示说明">图示说明</h3>
<hr />
<figure>
<img src="./imgs/05-ground_coor.png" alt="" /><figcaption>地面坐标系与环视图片坐标系的联系</figcaption>
</figure>
<p>上图中<span class="math inline">\(O_G\)</span>是地面坐标系，这里与第一节中说明的车辆坐标系有一点不同，主要是为了方便后文进行公式推导。实际中只需要把图中的地面坐标系与车辆坐标系根据车身参数简单计算出变换矩阵即可。</p>
<p>上图中<span class="math inline">\(O_I\)</span>是图像坐标系，以左上角为坐标原点，<span class="math inline">\(u,v\)</span>为像素的横轴、纵轴坐标值。<span class="math inline">\(H,W\)</span>为我们希望得到的地平面投影图像的投影范围，单位是<span class="math inline">\(米\)</span>。同时，我们令<span class="math inline">\(d_W,d_H\)</span>为图像每个像素对应的实际中方格的大小，单位也是<span class="math inline">\(米\)</span></p>
<hr />
<h3 id="地平面点到相机投影">地平面点到相机投影</h3>
<p>假设车周有4个相机<span class="math inline">\(C_1,C_2,C_3,C_4\)</span>，4个相机的与地面坐标系的位姿关系为<span class="math inline">\(T_{C_1G}, T_{C_2G}, T_{C_3G}, T_{C_4G}\)</span></p>
<p>对于一个地面坐标系下的点<span class="math inline">\(P_{G}=[X_G,Y_G,Z_G,1]^T\)</span>，在通过投影方程投影在相机<span class="math inline">\(C_i\)</span>上的图像像素坐标<span class="math inline">\(\boldsymbol{p}_i\)</span>有如下关系：</p>
<p><span class="math display">\[
\begin{split}
P_{C_i}&amp;=T_{C_iG}P_G\\
&amp;=
\begin{bmatrix}
X_{C_i} &amp; Y_{C_i} &amp; Z_{C_i} &amp; 1
\end{bmatrix}^T
\end{split}
\]</span></p>
<p>则<span class="math inline">\(P_G\)</span>在相机<span class="math inline">\(C_i\)</span>中对应的像素坐标为</p>
<p><span class="math display">\[
\begin{split}
\lambda_{C_i} \boldsymbol{p}_{C_i} 
&amp;=\
K_{C_i}P_{C_{i}}\\
&amp;=\
K_{C_i}T_{C_iG}P_G
\end{split}\tag{3-1}
\]</span></p>
<p><span class="math inline">\(K_{C_i}\)</span>是相机<span class="math inline">\(C_i\)</span>的内参，<span class="math inline">\(\lambda_{C_i}\)</span>是放缩系数，确保最后<span class="math inline">\(\boldsymbol{p}_{C_i}\)</span>的第三个维度值为1,也就是具有如下形式：<span class="math inline">\(\boldsymbol{p}_{C_i}=[u,v,1]^T\)</span>。另外，要注意（3-1）中包含一个齐次坐标的变换。</p>
<p>现在假设点<span class="math inline">\(P_G\)</span>的<span class="math inline">\(Z\)</span>轴坐标是0,也就是点位于地面，则 <span class="math inline">\(P_{G}=[X_G,Y_G,0,1]^T\)</span>，上面<span class="math inline">\(P_{C_i}=T_{C_iG}P_G\)</span>展开会变成</p>
<p><span class="math display">\[
\begin{split}
P_{C_i}&amp;=T_{C_iG}P_G\\
&amp;=
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; r_{02} &amp; t_0\\
r_{10} &amp; r_{11} &amp; r_{12} &amp; t_1\\
r_{20} &amp; r_{21} &amp; r_{22} &amp; t_2\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_{G_i}\\
Y_{G_i}\\
0\\
1
\end{bmatrix}\\
&amp;=
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; t_0\\
r_{10} &amp; r_{11} &amp; t_1\\
r_{20} &amp; r_{21} &amp; t_2\\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_{G_i}\\
Y_{G_i}\\
1
\end{bmatrix}
\end{split}
\]</span></p>
<p>我们可以重新记公式（3-1）为</p>
<p><span class="math display">\[
\begin{split}
\lambda_{C_i}\boldsymbol{p}_{C_i}=K_{C_i}T_{C_iG}^{0:3;0:2,3}P_G
\end{split}\tag{3-3}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
T_{C_iG}^{0:3;0:2,3} =
\begin{bmatrix}
r_{00} &amp; r_{01} &amp; t_0\\
r_{10} &amp; r_{11} &amp; t_1\\
r_{20} &amp; r_{21} &amp; t_2
\end{bmatrix}
\]</span></p>
<p>表示变换矩阵的前三行，第0,1,3列</p>
<p>公式（3-3）实际就是第二节中推导出的公式（2-2）</p>
<h3 id="地平面点虚拟相机投影">地平面点虚拟相机投影</h3>
<p>根据上图，假设我们想要投影以地面坐标系原点为中心，<span class="math inline">\(H\times W\)</span>的地面区域。同时，我们希望投影后的像素分辨率为一个像素对应横轴、长轴为<span class="math inline">\(d_W,d_H\)</span>长度的地面方格。<strong>（PS:实际上相机的焦距的定义就是每个像素对应的实际尺寸，焦距的单位为<span class="math inline">\(pixel/meter\)</span>）</strong>。对于地平面投影，我们可以假设有一个虚拟相机位于地面上1米，这样<span class="math inline">\(u=f_xX_G+c_x\)</span>，<span class="math inline">\(f_x=\frac{1}{d_W}\)</span>，<span class="math inline">\(c_x=\frac{W}{2d_W}\)</span>。我们可以写成如下的形式</p>
<p><span class="math display">\[
\begin{bmatrix}
u_G\\
v_G\\
1
\end{bmatrix}=
\begin{bmatrix}
\frac{1}{d_W} &amp; 0 &amp; \frac{W}{2d_W}\\
0 &amp; \frac{1}{d_H} &amp; \frac{H}{2d_H}\\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
X_G\\
Y_G\\
1
\end{bmatrix}\tag{3-4}
\]</span></p>
<p>上式可以写成矩阵形式，我们记<span class="math inline">\(K_G\)</span>为上式中的矩阵（虚拟相机的内参）</p>
<p><span class="math display">\[
\boldsymbol{p}_G = K_GP_G\tag{3-5}
\]</span></p>
<p>联立公式（3-3）和公式（3-5）可以写为如下形式</p>
<p><span class="math display">\[
\lambda \boldsymbol{p}_G=K_G\left(T_{C_iG}^{0:3;0:2,3}\right)^{-1}K_{C_i}^{-1}\boldsymbol{p}_{C_i}\tag{3-6}
\]</span></p>
<p>其中，<span class="math inline">\(\lambda\)</span>系数只是为了将<span class="math inline">\(\boldsymbol{p}_G\)</span>的最后一个维度归一化，不需要具体形式。</p>
<h2 id="直接估计环视投影的单应矩阵">直接估计环视投影的单应矩阵</h2>
<p>除了根据第三节的推导，从相机内外参直接推导出车周相机到地平面的投影矩阵，还可以直接人工选点估计单应矩阵。这一点跟透视矫正（Perspective Correction）任务基本类似。所谓的透视矫正，就是对于同一个平面的不同成像结果（两张图片），我们选择两张图片上的对应点构建对应点集，根据单应矩阵的定义</p>
<p><span class="math display">\[
\boldsymbol{p}_2 = H_{21}\boldsymbol{p}_1
\]</span></p>
<p>我们可以从对应的点集中求解出单应矩阵。由于前面第二节我们知道单应矩阵的实际自由度为8，而一个对应点对可以构建两个约束方程（<span class="math inline">\(x,y\)</span>），所以我们一共最少需要4个点对来求解单应矩阵。</p>
<h3 id="示例图">示例图</h3>
<p>还是以上文的简笔图来说明</p>
<figure>
<img src="./imgs/06-perspective_correction.png" alt="" /><figcaption>透视矫正示意图</figcaption>
</figure>
<p>上图中两个相机对同一个平面成像，得到两张图片。两张图片中<span class="math inline">\(A,B,C,D\)</span>四个点是一一对应的关系，记这些点对为<span class="math inline">\(\boldsymbol{p}_i,\boldsymbol{p}_i^{\prime}\)</span>，则我们可以建立方程</p>
<p><span class="math display">\[
\begin{split}
\lambda \boldsymbol{p}_i^{\prime}&amp;=H\boldsymbol{p}_i
\end{split}
\]</span></p>
<p>即 <span class="math display">\[
\lambda
\begin{bmatrix}
u_i^{\prime}\\
v_i^{\prime}\\
1
\end{bmatrix}
=\
\begin{bmatrix}
h_{00}&amp;h_{01}&amp;h_{02}\\
h_{10}&amp;h_{11}&amp;h_{21}\\
h_{20}&amp;h_{21}&amp;h_{22}\\
\end{bmatrix}
\begin{bmatrix}
u_i\\
v_i\\
1
\end{bmatrix}\tag{4-1}
\]</span></p>
<h3 id="单应矩阵求解">单应矩阵求解</h3>
<p>公式（4-1）的求解可以用最小二乘法，或者最小二乘法+RANSAC等算法，优化目标为：</p>
<p><span class="math display">\[
J = \sum_{i}\left(u_i^{\prime}-\frac{h_{00}u_i+h_{01}v_i+h_{02}}{h_{20}u_i+h_{21}v_i+h_{22}}\right)^2+\left(v_i^{\prime}-\frac{h_{10}u_i+h_{11}v_i+h_{21}}{h_{20}u_i+h_{21}v_i+h_{22}}\right)^2
\]</span></p>
<p>这部分的求解可以使用OpenCV的函数<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780">OpenCV:findHomography</a></p>
<h3 id="环视投影单应矩阵求解">环视投影单应矩阵求解</h3>
<p>在环视投影中，我们需要一些额外的标定物要求解单应矩阵。主要的原理就是我们将地面上的坐标和图像中的坐标联立写成如公式（4-1）的形式，然后调用接口计算单应矩阵。图像中的坐标可以通过手工选点，也可以通过一些角点检测程序。</p>
<figure>
<img src="./imgs/07-compute-homo.png" alt="" /><figcaption>环视单应矩阵求解</figcaption>
</figure>
<p>上图引用自：https://www.guyuehome.com/39649</p>
<p>上图中0,1,2,3四个点是在图片上选择的点，因此知道像素值。同时，我们又可以通过标定布的几何属性以及我们提前设定的投影图的分辨率，得出这四个点在BEV上的等效像素值，于是我们就可以求解方程（4-1）得出单应矩阵</p>
<h2 id="单应矩阵的其他应用">单应矩阵的其他应用</h2>
<p>单应矩阵还可以用在求解平面标定板的位姿、全景图拼接等应用，<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html">OpenCV的这一篇教程</a>写得十分详细，这里就不再赘述。</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Homography_(computer_vision)">Wiki:Homography_(computer_vision)</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780">OpenCV:findHomography</a></li>
<li><a target="_blank" rel="noopener" href="https://www.guyuehome.com/39649">古月居:AVM 环视拼接方法介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html">OpenCV：Basic concepts of the homography explained with code</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/06/05/cv/camera-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/05/cv/camera-model/" class="post-title-link" itemprop="url">吐血整理：从相机模型（针孔、鱼眼、全景）到OpenCV源码实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-05 17:35:04" itemprop="dateCreated datePublished" datetime="2023-06-05T17:35:04+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-12 15:42:27" itemprop="dateModified" datetime="2023-06-12T15:42:27+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
    <span id="/2023/06/05/cv/camera-model/" class="post-meta-item leancloud_visitors" data-flag-title="吐血整理：从相机模型（针孔、鱼眼、全景）到OpenCV源码实现" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="吐血整理：从相机模型（针孔、鱼眼、全景）到OpenCV源码实现" href="/2023/06/05/cv/camera-model/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::7f7d0e7ebf1819ceb3ada055941a8a17" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="本文内容">本文内容</h2>
<p>本文旨在较为直观地介绍相机成像背后的数学模型，主要的章节组织如下：</p>
<ol type="1">
<li>第一章用最简单的针孔投影模型为例讲解一个三维点是如何映射到图像中的一个像素</li>
<li>第二章介绍除了针孔投影模型外其他一些经典投影模型，旨在让读者建立不同投影模型之间的建模过程</li>
<li>第三章介绍如何把不同的投影模型用一个统一的投影过程表达</li>
<li>第四章进一步补充第三章的统一投影模型，并介绍畸变的定义和去畸变的原理</li>
<li>第五章针对全景相机的基本概念和两种应用广泛的全景相机模型做出介绍</li>
<li>第六章用代码示例介绍如何使用OpenCV的接口对图像去畸变</li>
</ol>
<h2 id="一相机是如何成像的">一、相机是如何成像的？</h2>
<p>祭上一张经典图</p>
<figure>
<img src="./imgs/01-pinhole.png" alt="" /><figcaption>针孔相机模型</figcaption>
</figure>
<h3 id="一个三维空间中的点怎样映射到图片上的一个像素">一个三维空间中的点怎样映射到图片上的一个像素？</h3>
<p>我们从一个最简单的问题开始：一个三维空间中的点<span class="math inline">\(P=[X,Y,Z]\)</span>是如何经过相机成像变为图像上的一个像素<span class="math inline">\(\boldsymbol{p}=[u,v]\)</span>的？</p>
<p>我们最常见的投影模型<strong>Perspective Projection Model</strong> 描述的就是<strong>针孔相机</strong> 的成像原理。从上面的图根据相似三角形可以得出</p>
<p><span class="math display">\[
\frac{X_c}{Z_c} = \frac{u - c_x}{f}\tag{1-1}
\]</span></p>
<p>其中<span class="math inline">\(c_x\)</span>为光轴在图像中的<span class="math inline">\(x\)</span>坐标，如果相机的光轴与感光元器件完全对齐的话，<span class="math inline">\(c_x = \frac{1}{2}W\)</span>, <span class="math inline">\(W\)</span>是图像的宽度（单位是像素）</p>
<p>从上面的关系可以得出，将一个三维点投影到像素坐标系的时候，可以直接使用下面的公式。对应的就是针孔相机模型。<strong>下标<span class="math inline">\((\cdot)_c\)</span></strong> 表示这个点是在相机坐标系下的点</p>
<p><span class="math display">\[
\begin{split}
\lambda
\begin{bmatrix}
u\\
v\\
1
\end{bmatrix}=
\begin{bmatrix}
f_x&amp;0&amp;c_x\\
0&amp;f_y&amp;c_y\\
0&amp;0&amp;1
\end{bmatrix}
\begin{bmatrix}
X_c\\
Y_c\\
Z_c\\
\end{bmatrix}
\end{split}\tag{1-2}
\]</span></p>
<p>公式（1-2）在代码中也经常对<span class="math inline">\(u,v\)</span>分开进行计算</p>
<p><span class="math display">\[
\begin{split}
u = f_x \frac{X_c}{Z_c} + c_x
\\
\\
v = f_y \frac{Y_c}{Z_c} + c_y
\end{split}\tag{1-3}
\]</span></p>
<p>当然，为了简化记号，公式（1-2）也通常记为矩阵相乘的形式</p>
<p><span class="math display">\[
\lambda\boldsymbol{p}=KP_c\tag{1-4}
\]</span></p>
<p>如果我们提前对<span class="math inline">\(P_c\)</span>做归一化处理，也就是除以<span class="math inline">\(Z_c\)</span>（假设点位于相机前，即<span class="math inline">\(Z_c&gt;0\)</span>），则可以去掉<span class="math inline">\(\lambda\)</span>系数，即如下形式：</p>
<p><span class="math display">\[
\begin{split}
&amp;\boldsymbol{p}_n=\frac{P_c}{Z_c}=
\begin{bmatrix}
\frac{X_c}{Z_c}&amp;\frac{Y_c}{Z_c}&amp;1
\end{bmatrix}^T
\\
&amp;\boldsymbol{p}=K\boldsymbol{p}_n
\end{split}\tag{1-5}
\]</span></p>
<p>公式（1-4）中<span class="math inline">\(\boldsymbol{p}_n\)</span>位于<span class="math inline">\(Z=1\)</span>的平面，又叫归一化平面（nomalized plane），后文会再次讲到这个平面。</p>
<p>公式（1-2）到公式（1-5）其实都是等价的</p>
<p>如果给的三维点是在世界坐标系下，也就是<span class="math inline">\(P_w=[X_w,Y_w,Z_w]\)</span>，那么我们只需要先把该点用相机的外参转换到相机坐标系下（刚性变换）即可：</p>
<p><span class="math display">\[
\begin{split}
\lambda\boldsymbol{p} = KT_{cw}P_w\\
\\
T_{cw} = [R|t]
\end{split}\tag{1-6}
\]</span></p>
<p>由于刚性变换过程不影响对相机投影模型的讨论，因此后面都假设三维点是处于相机坐标系</p>
<h3 id="相机坐标系">相机坐标系</h3>
<p>在OpenCV中以及大部分视觉处理库中，相机坐标系的规定都与上述的图一致，就是相机光轴往前为<span class="math inline">\(Z\)</span>，图像水平往右为<span class="math inline">\(X\)</span>，图像垂直往下为<span class="math inline">\(Y\)</span>。不过要注意的是在一些仿真渲染器或者特定任务的数据集中可能会规定图像垂直往上为<span class="math inline">\(Z\)</span>，前为<span class="math inline">\(X\)</span>，朝左为<span class="math inline">\(Y\)</span>，但是这一点是无关紧要的，这一点差别可以反映在相机的外参里，也就是公式（1-6）中的<span class="math inline">\(T_{cw}\)</span>，只要按照OpenCV的方式规定相机坐标系，总是可以找到一个外参矩阵<span class="math inline">\(T_{cw}\)</span>将世界坐标系下的点变换到相机坐标系（前<span class="math inline">\(Z\)</span>右<span class="math inline">\(X\)</span>下<span class="math inline">\(Y\)</span>）</p>
<h3 id="大白话总结">大白话总结</h3>
<p>问：相机是如何成像的？ 答：光束从物体表面反射，经过相机镜头，到达感光原件，这一系列物理过程可以通过数学公式表达，最终变成一个简单的矩阵操作将三维空间中的点对应到图片的一个像素。</p>
<h2 id="二不同的相机投影模型">二、不同的相机投影模型</h2>
<p>第一节介绍的是针孔投影模型，但是事实上相机镜头都是多种多样的，不可能都是符合针孔投影模型。本节会介绍经典的相机投影模型，并从直观感受和形式化定义上介绍不同的投影模型是如何联系在一起的</p>
<h3 id="什么是相机投影模型">什么是相机投影模型</h3>
<p><strong>相机投影模型用数学的方式描述了一个真实世界中的三维点到图像上像素坐标的映射关系</strong></p>
<p>相机投影模型实际上就是对相机成像过程（物理）的数学建模。建模的目的是为了能够尽量符合真实的成像过程。不同的建模方式就对应不同的相机投影模型</p>
<h3 id="经典的相机投影模型">经典的相机投影模型</h3>
<p>我们回头看看公式（1-3），并暂时<strong>只关注<span class="math inline">\(X\)</span>轴的映射关系</strong></p>
<p><span class="math display">\[
\begin{split}
u = f_x \frac{X_c}{Z_c} + c_x
\end{split}\tag{1-3}
\]</span></p>
<p>上式中<span class="math inline">\(f_x\)</span>称为相机焦距，反应了一个单位长度应该映射为几个像素，单位是<span class="math inline">\(pixels/m\)</span>，<span class="math inline">\(c_x\)</span>是相机坐标系（以光轴点为原点）到图像坐标系（以左上角为原点），这两个参数都是相机的固有参数。 而上式轴<span class="math inline">\(\frac{X_c}{Z_c}\)</span>刚好是点<span class="math inline">\(P_c\)</span>到相机光心连线与光轴角度的正切值，我们记光束与光轴的夹角为<span class="math inline">\(\theta\)</span>，并将图片原点移动到图片中心，则公式（1-3）可以写为</p>
<p><span class="math display">\[
u^{\prime}=f_x\tan(\theta)\tag{2-1}
\]</span></p>
<p>上式的示意图如下（图中的<span class="math inline">\(r\)</span>在只考虑<span class="math inline">\(X\)</span>轴的时候就是<span class="math inline">\(u^{\prime}\)</span>）：</p>
<figure>
<img src="./imgs/02-theta_projection.jpg" alt="" /><figcaption>光束与光轴夹角</figcaption>
</figure>
<p>在公式（2-1）中，<span class="math inline">\(X\)</span>轴的投影坐标是<span class="math inline">\(\theta\)</span>的函数，于是，我们是否可以用不同的函数表达这个过程？答案是肯定的！不同的函数就对应了不同的投影模型。下图就给出了在经典投影模型中对<span class="math inline">\(\theta\)</span>的不同映射方式</p>
<figure>
<img src="./imgs/03-classic_projection.jpg" alt="" /><figcaption>经典投影模型</figcaption>
</figure>
<p>事实上，<span class="math inline">\(f\)</span>作为相机的焦距，在上图中的不同投影模型都统一出现，于是我们可以舍弃焦距符号。于是，上图中不同的函数关系与投影模型的对应关系如下：</p>
<ul>
<li><span class="math inline">\(r(\theta)=\tan(\theta)\)</span>，perspective projection/针孔投影模型/rectilinear model</li>
<li><span class="math inline">\(r(\theta)=2\tan{\big(\frac{\theta}{2}\big)}\)</span>, stereographic projection</li>
<li><span class="math inline">\(r(\theta)=\theta\)</span>, equidistant projection</li>
<li><span class="math inline">\(r(\theta)=\sin{(\theta)}\)</span>, sine-law projection</li>
<li><span class="math inline">\(r(\theta)=2\sin{\big(\frac{\theta}{2}\big)}\)</span>, equi-solid angle projection</li>
</ul>
<p>上面两幅图出自:<a target="_blank" rel="noopener" href="http://michel.thoby.free.fr/Fisheye_history_short/Projections/Models_of_classical_projections.html">Models for the various classical lens projections</a>，这篇文章比较形象地介绍各种经典的相机投影模型，并给出他们的函数曲线分析。不过总体偏形象化，没有引入更形式化的描述。</p>
<h2 id="三相机投影模型的统一表达形式">三、相机投影模型的统一表达形式</h2>
<p>上一节我们将投影关系限制在<span class="math inline">\(X\)</span>轴，并且给出了较为直观的图示。目的在于两个：1）给读者建立更深刻的相机投影过程;2）让读者对几种经典的投影模型有初步的直观了解。在这一小节中，我们给出更为统一的相机投影表达方式，同时为后文讨论相机的<strong>畸变</strong> 建立必要的理论基础。</p>
<p>我们将相机的投影过程拆分为三个过程：1）将空间中的点投影到单位球表面;2）将单位球上的点投影到归一化平面;3）将归一化平面上的点利用针孔模型投影到图像坐标系。下面详细介绍这几个过程</p>
<h3 id="单位球投影">单位球投影</h3>
<p>想象一下一束光束从相机光心射出，经过图像中的一个像素然后往外无限延伸，可以想象到，这个光束经过的任何点到图像的投影都是经过的那个像素。这个简单的事实告诉我们，我们可以对一个三维点进行任意的放缩，其在图像上的成像点都不会改变。于是，我们将三维点<span class="math inline">\(P_c\)</span>除以它自身的膜，将其投影到一个单位球，其投影坐标为<span class="math inline">\(P_s\)</span></p>
<p><span class="math display">\[
\begin{split}
P_s = \frac{P_c}{||P_c||}=
\begin{bmatrix}
\frac{X_c}{||P_c||}&amp;\frac{Y_c}{||P_c||}&amp;\frac{Z_c}{||P_c||}
\end{bmatrix}^T
\end{split}\tag{3-1}
\]</span></p>
<p>示意图如下：</p>
<figure>
<img src="./imgs/04-unit_sphere.png" alt="" /><figcaption>单位球投影示意图</figcaption>
</figure>
<p>在上图中，<span class="math inline">\(\theta\)</span>是光束与光轴的夹角，<span class="math inline">\(\alpha\)</span>为光束与水平轴的夹角。</p>
<p>两个角度有如下关系：</p>
<p><span class="math display">\[
\begin{split}
&amp;\rho = \sqrt{(X_s^2+Y_s^2)}\\
&amp;\theta=\operatorname{atan}(\frac{\rho}{Z_s})=\operatorname{asin}(\rho)\\
&amp;\alpha=\operatorname{atan}(\frac{Y_s}{X_s})
\end{split}\tag{3-2}
\]</span></p>
<p>之所以构建<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\alpha\)</span>是因为，我们后续可以将投影过程建立为这两个角度的函数，也就是只与光束的角度有关，而与具体的点坐标无关，这也是符合直观的。</p>
<p>另外，从前面的叙述以及常识，我们知道针孔成像结果是一个倒立的像，为了方便叙述，我们可以将相机做一个镜像，如下图所示：</p>
<figure>
<img src="./imgs/05-mirror_camera.png" alt="" /><figcaption>对相机做镜像</figcaption>
</figure>
<p>这个单位球有时候又叫视球（Viewing Sphere）</p>
<h3 id="归一化平面模型平面">归一化平面&amp;&amp;模型平面</h3>
<p>将世界坐标系的点投影到单位球后，我们进一步将其映射到<span class="math inline">\(Z=1\)</span>的平面上，这个平面又叫归一化平面（Normalized Plane）。 此时不同的投影模型会对在归一化平面上的点到原点的连线做放缩<span class="math inline">\(r(\theta)\)</span>，为了后文叙述的统一性，我们再拆分出一个模型平面。在归一化平面上的点只是<span class="math inline">\(P_c\)</span>与光心点的连线和平面的交点，即：</p>
<p><span class="math display">\[
p_n = \frac{P_c}{||Z_c||}\tag{3-3}
\]</span></p>
<p>在模型平面上（Model Plane），对归一化平面上的点做半径放缩，即</p>
<p><span class="math display">\[
\begin{split}
\boldsymbol{p}_d=
\begin{bmatrix}
r(\theta)\cos(\alpha)\\
r(\theta)\sin(\alpha)\\
1
\end{bmatrix}=
\begin{bmatrix}
u_d\\
v_d\\
1
\end{bmatrix}
\end{split}\tag{3-4}
\]</span></p>
<p>这两个平面的变换过程如下图所示</p>
<figure>
<img src="./imgs/06-normalized_plane.png" alt="" /><figcaption>归一化平面投影&amp;&amp;模型平面</figcaption>
</figure>
<p>从第二节中经典的投影模型我们发现，其实不同的投影模型都没有对<span class="math inline">\(\alpha\)</span>产生影响，而是对投影点到原点的距离<span class="math inline">\(r(\theta)\)</span>建立不同的函数形式</p>
<p>稍后我们会看到，为了能够将所有模型都统一为针孔投影模型，会将模型平面变为畸变平面，用更具有一般性的多项式代替前面<span class="math inline">\(r(\theta)\)</span>的表达形式。（因此，现在模型平面上的点用下标<span class="math inline">\(d\)</span>标明，表示distortion）</p>
<h3 id="透视变换">透视变换</h3>
<p>得到模型平面上的坐标<span class="math inline">\(\boldsymbol{p}_d=[u_d,v_d,1]^T\)</span>后，我们可以用相机内参<span class="math inline">\(K\)</span>将其变换到图像平面，这个步骤实际上就只是坐标的变换了。</p>
<p><span class="math display">\[
\begin{split}
u = f_xu_d+c_x\\
v = f_yv_d+c_y
\end{split}\tag{3-5}
\]</span></p>
<p>最后，我们可以得到一张完整地表达相机投影模型的示意图：</p>
<figure>
<img src="./imgs/07-unified_model.png" alt="" /><figcaption>相机投影模型统一表达形式</figcaption>
</figure>
<h3 id="将针孔投影带入上述统一模型">将针孔投影带入上述统一模型</h3>
<p>我们可以将针孔模型，即<span class="math inline">\(r(\theta)=\tan(\theta)\)</span>代入上面的模型，联立公式（3-1）-（3-5）,最后可以发现，公式（3-5）的结果其实就是公式（1-3），也就是针孔投影模型的公式。这个过程比较简单，就不再展开公式。读者自己推导一下这个过程非常有利于理解上述的过程。</p>
<h3 id="不同投影模型的函数图">不同投影模型的函数图</h3>
<p>我们可以将不同的经典投影模型的函数画出来（横轴为<span class="math inline">\(\theta\)</span>，纵轴为<span class="math inline">\(r(\theta)\)</span>），结果如下</p>
<figure>
<img src="./imgs/07-classic_proj_plot.jpg" alt="" /><figcaption>经典投影模型的函数曲线</figcaption>
</figure>
<p>从上图我们应该至少要观察到一个重要的事实：针孔投影模型无法对<span class="math inline">\(&gt;=90\degree\)</span>的视野成像。因为<span class="math inline">\(\tan(\cdot)\)</span>在90度的时候会趋于无穷大。实际上，从上面的函数图可以看到，针孔投影模型只能在大约水平140度以内的视野成像</p>
<h3 id="相机投影模型总结">相机投影模型总结</h3>
<p>到目前位置，我们应该建立至少以下几个方面的认识：</p>
<ol type="1">
<li>统一化的投影模型经过：单位球投影-&gt;归一化平面-&gt;透视变换几个过程，将一个三维点投影到图像上的像素</li>
<li>不同的经典投影模型在投影过程中不会改变光束与<span class="math inline">\(X\)</span>轴的夹角，只是对像素到图像原点的距离建立不同的方程</li>
</ol>
<h2 id="四相机的畸变">四、相机的畸变</h2>
<h3 id="针孔模型的优越性">针孔模型的优越性</h3>
<p>首先描述一下我们人类直观上对于“标准的图像”这个词的一个感性认识，是不是我们会觉得横平竖直，真实中是直线则图像中也是直线，这样的图片会比较“标准”？事实上，针孔投影模型就刚好具有这样的性质。这个性质也可以从其投影方程看出来。经过针孔成像的物体，好像就是把整个物体缩小放在图片上，因此圆是圆，直线是直线。而其他投影模型就可能会呈现膨胀、紧缩的成像效果。如下图</p>
<figure>
<img src="./imgs/08-image_affect.png" alt="" /><figcaption>标准的针孔成像与其他投影模型的图像</figcaption>
</figure>
<h3 id="定义">定义</h3>
<p>“畸变”这个词从词语上应该理解成由于镜头加工等因素造成镜头与投影模型的差异。但实际上，<strong>相机畸变现在描述的是相机成像过程与针孔投影模型的差异（a deviation from the pinhole model）</strong> ，也就是：针孔投影+畸变模型=实际成像</p>
<p>而“去畸变”则是使用畸变模型对图像进行逆操作，使得图像就像用针孔投影模型成像出来的一样。</p>
<h3 id="在归一化平面插入畸变模型">在归一化平面插入畸变模型</h3>
<p>为了能够利用针孔模型的性质，我们在前文给出的统一相机投影模型中将模型平面用畸变平面代替。这里的核心思想是，<strong>用一个更具一般性的多项式替代各个投影模型中的模型函数，以此达到用一个方程表达多个投影模型的目的。</strong></p>
<p>替换后的示意图如图所示：</p>
<figure>
<img src="./imgs/09-distortion_plane.png" alt="" /><figcaption>加入畸变平面的投影模型</figcaption>
</figure>
<p>注意上图与上一节最后的统一投影模型其实是一样的，不过Model Plane名字换成Distortion Plane</p>
<p>我们这一节采用<a href="#OpenCV2.4">OpenCV实现的畸变模型</a>来讲解畸变过程</p>
<p>我们还是先将<span class="math inline">\(P_c\)</span>点投影到归一化平面得到<span class="math inline">\(\boldsymbol{p}_n=[u_n,v_n]\)</span>，并令其到原点的半径为<span class="math inline">\(r=\sqrt{(u_n^2+v_n^2)}\)</span></p>
<h3 id="径向畸变radial-distortion">径向畸变（Radial Distortion）</h3>
<p>所谓的径向畸变（Radial Distortion）就是指只对点<span class="math inline">\(p_n\)</span>做半径上的伸缩变化，这一点其实就跟经典投影模型一样用一个函数建立半径的变化，在OpenCV中，标准镜头的径向畸变可以用如下方程表达：</p>
<p><span class="math display">\[
\begin{split}
&amp;u^{\prime}=u_n(1+k_1r^2+k_2r^4+k_3r^6)\\
&amp;v^{\prime}=v_n(1+k_1r^2+k_2r^4+k_3r^6)
\end{split}\tag{4-1}
\]</span></p>
<p>径向畸变对于环绕光轴一周的改变是一致的，因此也叫做半径对称畸变（Radial Symmetric Distortion）或者畸变的对称部分（Symmetric Part Of Distortion Model）</p>
<h3 id="切向畸变tangential-distortion">切向畸变（Tangential Distortion）</h3>
<p>真实的镜头由于加工误差和安装误差，会导致镜头与感光原件的中心不是完全对齐的，因此在平行的方向上会与标准的针孔成像模型有差异，这种差异对于光轴不是旋转对称的，也叫做切向畸变（Tangential Distortion）</p>
<p>OpenCV中镜头的切向畸变方程如下：</p>
<p><span class="math display">\[
\begin{split}
u_{d}=u^{\prime}+2p_1u_nv_n+p_2(r^2+2u_n)\\
v_{d}=v^{\prime}+p_1(r^2+2{v_n}^2) + 2p_2u_nv_n
\end{split}\tag{4-2}
\]</span></p>
<p>公式（4-1）和公式（4-2）中的<span class="math inline">\(k_1,k_2,k_3,p_1,p_2\)</span>叫做畸变参数（Distortion Coefficients）</p>
<h3 id="去畸变">去畸变</h3>
<p>有了畸变模型之后，我们就可以将一个三维点经过：单位球投影-&gt;归一化平面投影-&gt;畸变模型-&gt;透视变换，得到该点在图像中的像素位置。我们可以通过一些标定物，经过求解得到上述的畸变系数，进而得到畸变过程的反过程。我们将图像上的点先经过透视变换的反变换得到在畸变平面上的点，再经过畸变过程的反过程，再投回图像中，这样我们就得到一副没有畸变的图像，其看起来就像是用完全标准的针孔投影模型成像的照片。</p>
<p>下面的图片展示了从畸变到去畸变的图像变化</p>
<figure>
<img src="./imgs/10-distorted_to_undistorted.png" alt="" /><figcaption>去畸变图像变化</figcaption>
</figure>
<p>做完去畸变后，整个的成像过程就像直接用针孔投影模型（公式1-3）成像一般，就像下图一样。</p>
<figure>
<img src="./imgs/11-undistorted_model.png" alt="" /><figcaption>去畸变的等效投影过程</figcaption>
</figure>
<p>提出畸变模型的文章需要给出如何标定出畸变参数，同时如何计算从畸变点到非畸变点，这里面主要是一些数学求解，这里就不展开讨论，有兴趣的可以看看<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction">wiki:Distortion</a></p>
<h2 id="五全景相机omidirectional-camera">五、全景相机（Omidirectional Camera）</h2>
<p>所谓的全景相机广泛概念上指成像角度能够大于等于180度的相机，他们看起来大概像是下面这样</p>
<figure>
<img src="./imgs/12-omni_cam.png" alt="" /><figcaption>全景相机类型</figcaption>
</figure>
<p>从第二节（不同的相机投影模型）我们可以知道，根据针孔投影模型设计出的镜头无法对大于等于90度（左右）的视野成像，通常由于进光量等问题，这类相机一般只有140度左右的成像视野。</p>
<p>一般的畸变模型的设计以针孔相机模型为基础，通过参数模型修正真实的成像与针孔成像的差异，因为在很多的应用中我们希望能够通过“去畸变”的方式，将图片变成“直线还是直线（Straight lines are straight），在<a href="#KannalaBrandt">KannalaBrandt论文</a>中是这样描述的：</p>
<blockquote>
<p>It is impossible to project the hemispherical field of view on a finite image plane by a perspective projection so fish-eye lenses are designed to obey some other projection model.This is the reason why the inherent distortion of a fish-eye lens should not be considered only as a deviation from the pinhole model</p>
</blockquote>
<p>于是，就有很多专门针对全景相机（<strong>Omidirection Camera/Fisheye Camera/Wide-Angle camera</strong>）的建模研究出现。</p>
<p>重新理清一下我们的目的：</p>
<ol type="1">
<li>拥有一种统一的表达方式能够尽量拟合真实的全景相机的成像过程</li>
<li>这种表达方式应该简洁有效</li>
<li>能够对模型的参数求解，并将图像通过“去畸变”变成像是由针孔相机拍摄出来的横平竖直的图像</li>
</ol>
<p>OpenCV中针对全景相机的标定和去畸变给出了两种实现</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/TPAMI.2006.153">KannalaBrandt模型</a>.对应实现<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/db/d58/group__calib3d__fisheye.html">OpenCV::Fisheye</a></li>
<li><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ROBOT.2007.364084">CMei模型</a>. 对应实现<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/dd/d12/tutorial_omnidir_calib_main.html">OpenCV::Omnidir</a></li>
</ol>
<p>下面简单介绍这两种模型</p>
<h3 id="kannalabrandt模型">KannalaBrandt模型</h3>
<p>第一步还是先将点投影到单位球模型，这样我们就得出了<span class="math inline">\(\theta,\alpha\)</span>两个角度，后续的畸变模型就是关于这两个角度的函数</p>
<p>这里这里摘录OpenCV的描述方式<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/db/d58/group__calib3d__fisheye.html">OpenCV_Fisheye</a>，相比于论文，在模型参数上简化了很多</p>
<p>KannalaBrandt模型使用一个多项式描述径向畸变（畸变的对称部分）</p>
<p><span class="math display">\[
\begin{split}
&amp;\boldsymbol{p}_n=\frac{P_c}{P_z}=[u_n,v_n,1]^T\\
\\
&amp;r = \sqrt{u_n^2+v_n^2}\\
\\
&amp;\theta_d = k_1\theta + k_2\theta^3 + k_3\theta^5+k_4\theta^7+k_5\theta^9+....
\end{split}\tag{5-1}
\]</span></p>
<p>径向畸变后坐标变为：</p>
<p><span class="math display">\[
\begin{split}
u^{\prime} = \frac{\theta_d}{r}u_n\\
v^{\prime} = \frac{\theta_d}{r}v_n
\end{split}\tag{5-2}
\]</span></p>
<p>最后再进行非对称畸变</p>
<p><span class="math display">\[
\begin{split}
&amp;u_d=u^{\prime}+\alpha v^{\prime}\\
&amp;v_d=v^{\prime}
\end{split}\tag{5-3}
\]</span></p>
<p>最后再经过公式（3-5）变换到图像坐标系</p>
<h3 id="cmei模型">CMei模型</h3>
<p>CMei模型相比于其他模型有一个较大不同之处在于在从单位球投影到归一化平面时将相机光心往后移动了距离<span class="math inline">\(\xi\)</span>，总体的投影过程如下图：</p>
<figure>
<img src="./imgs/13-cmei_model.png" alt="" /><figcaption>CMei投影模型</figcaption>
</figure>
<p>上图出自引用CMei的一篇论文：Design and Calibration of an Omni-RGB+D Camera</p>
<h2 id="六代码实例">六、代码实例</h2>
<h3 id="实例一针孔投影模型去畸变">实例一：针孔投影模型去畸变</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># undistort image</span></span><br><span class="line">h,  w = img.shape[:<span class="number">2</span>]</span><br><span class="line">newcameramtx, roi = cv2.getOptimalNewCameraMatrix(K, distortions, (w,h), alpha, (w,h))</span><br><span class="line">undistorted_img = cv2.undistort(img, K, distortions, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">x, y, w, h = roi</span><br><span class="line">undistorted_img = undistorted_img[y:y+h, x:x+w]</span><br><span class="line"></span><br><span class="line"><span class="comment"># undistort image points</span></span><br><span class="line"><span class="keyword">if</span> points2d.ndim == <span class="number">2</span>:</span><br><span class="line">    points2d = points2d[:, <span class="literal">None</span>, :]</span><br><span class="line">undistorted_points = cv2.undistortPoints(points2d, K, distortions, P=K)</span><br><span class="line">undistorted_points = undistorted_points.reshape(-<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="实例二cmei模型去畸变">实例二：CMei模型去畸变</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># undistort image</span></span><br><span class="line"><span class="keyword">if</span> newK:</span><br><span class="line">        K_new = np.zeros((<span class="number">3</span>,<span class="number">3</span>), np.float64)</span><br><span class="line">        h,w = img.shape[:<span class="number">2</span>]</span><br><span class="line">        K_new[<span class="number">0</span>, <span class="number">0</span>] = w/<span class="number">4</span></span><br><span class="line">        K_new[<span class="number">0</span>, <span class="number">2</span>] = w/<span class="number">2</span></span><br><span class="line">        K_new[<span class="number">1</span>, <span class="number">1</span>] = h/<span class="number">4</span></span><br><span class="line">        K_new[<span class="number">1</span>, <span class="number">2</span>] = h/<span class="number">2</span></span><br><span class="line">        K_new[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        K_new = <span class="literal">None</span></span><br><span class="line">undistorted_img = cv2.omnidir.undistortImage(</span><br><span class="line">img, K, distortions, Xi, cv2.omnidir.RECTIFY_PERSPECTIVE, Knew=K_new)</span><br><span class="line"></span><br><span class="line"><span class="comment"># undistort image points</span></span><br><span class="line"><span class="keyword">if</span> points2d.ndim == <span class="number">2</span>:</span><br><span class="line">    points2d = points2d[:, <span class="literal">None</span>, :]</span><br><span class="line">undistorted_points = cv2.omnidir.undistortPoints(points2d, K, distortions, Xi, <span class="literal">None</span>)</span><br><span class="line">undistorted_points = undistorted_points.squeeze()</span><br><span class="line"></span><br><span class="line">f0 = K_new[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">f1 = K_new[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">c0 = K_new[<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">c1 = K_new[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">undistorted_points[:, <span class="number">0</span>] = f0* undistorted_points[:, <span class="number">0</span>] + c0</span><br><span class="line">undistorted_points[:, <span class="number">1</span>] = f1 * undistorted_points[:, <span class="number">1</span>] + c1</span><br></pre></td></tr></table></figure>
<p><strong>PS</strong>:cv2::omnidir::undisortPoints的旧版本有bug，参考这个<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv_contrib/issues/1612">issue</a>。omnidir空间目前还没有成为opencv的正式稳定接口，因此维护在opencv-contrib-python包中，最新的包（4.6.x）已经修复了bug。一定要检查一下是不是有那个bug！！！！</p>
<h3 id="实例三kannalabrandt模型去畸变">实例三：KannalaBrandt模型去畸变</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You should replace these 3 lines with the output in calibration step</span></span><br><span class="line">DIM=XXX</span><br><span class="line">K=np.array(YYY)</span><br><span class="line">D=np.array(ZZZ)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">undistort</span>(<span class="params">img_path</span>):</span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line">    h,w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    map1, map2 = cv2.fisheye.initUndistortRectifyMap(K, D, np.eye(<span class="number">3</span>), K, DIM, cv2.CV_16SC2)</span><br><span class="line">    undistorted_img = cv2.remap(img, map1, map2, interpolation=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;undistorted&quot;</span>, undistorted_img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">        undistort(p)</span><br></pre></td></tr></table></figure>
<h2 id="相机标定方法">相机标定方法</h2>
<p>最经典的是使用张正友标定法。<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf">原文</a>;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94244568">中文讲解</a></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/d9/d0c/group__calib3d.html#:~:text=Detailed%20Description">OpenCV:Camera Calibration</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html">OpenCV2.4:Camera Calibration</a></p></li>
<li><p><a target="_blank" rel="noopener" href="http://michel.thoby.free.fr/Fisheye_history_short/Projections/Models_of_classical_projections.html">Models for the various classical lens projections</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction">Wiki:Distortion</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/TPAMI.2006.153">KannalaBrandt:A Generic Camera Model and Calibration Method for Conventional, Wide-Angle, and Fish-Eye Lenses</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ROBOT.2007.364084">CMei: Single View Point Omnidirectional Camera Calibration from Planar Grids</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/db/d58/group__calib3d__fisheye.html">OpenCV::Fisheye</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.7.0/dd/d12/tutorial_omnidir_calib_main.html">OpenCV::Omnidir</a></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/31/slam-theory/lie-group-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/31/slam-theory/lie-group-01/" class="post-title-link" itemprop="url">SLAM基础——李代数基础概念及公式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-31 21:56:58" itemprop="dateCreated datePublished" datetime="2023-05-31T21:56:58+08:00">2023-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 11:31:48" itemprop="dateModified" datetime="2023-06-14T11:31:48+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/05/31/slam-theory/lie-group-01/" class="post-meta-item leancloud_visitors" data-flag-title="SLAM基础——李代数基础概念及公式" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="SLAM基础——李代数基础概念及公式" href="/2023/05/31/slam-theory/lie-group-01/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::2cf0b705b902423269f4cebef74df287" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="李群李代数基础概念">李群李代数基础概念</h2>
<h3 id="群groups-李群liegroups">群（Groups） &amp;&amp; 李群（LieGroups）</h3>
<h4 id="群的定义">群的定义</h4>
<p>群是一种 <strong><em>集合</em></strong> 加上 <strong><em>一种运算</em></strong> 的代数结构，这种运算需要满足几个条件（可以不用记住）</p>
<p><strong>例</strong> ：旋转矩阵（集合）和矩阵乘法（运算），矩阵乘法对于旋转矩阵具有很良好的性质（符合群运算的定义），于是旋转矩阵是一种群。</p>
<h4 id="特殊正交群">特殊正交群</h4>
<p>特殊正交群（Special Orthogonal Group）记为<span class="math inline">\(SO(n)\)</span>，又叫旋转矩阵群。 例：<strong><em>三维</em></strong> 旋转矩阵构成特殊正交群<span class="math inline">\(SO(3)\)</span></p>
<p><span class="math display">\[
SO(3) = \{R \in \mathbb{R}^{3\times 3}:R^{T}R=\mathbf{I},det(R)=1\}
\]</span></p>
<h4 id="特殊欧式群">特殊欧式群</h4>
<p>特殊欧式群记为<span class="math inline">\(SE(n)\)</span>，对应<span class="math inline">\(n\)</span>维的欧式变换（旋转加平移）</p>
<h4 id="李群">李群</h4>
<p>李群是具有连续（光滑）性质的群</p>
<p>例：旋转可以连续地进行，平移也可以连续地进行，所以<span class="math inline">\(SO(3)\)</span>、<span class="math inline">\(SE(3)\)</span>都是李群</p>
<h3 id="李代数">李代数</h3>
<h4 id="反对称矩阵符号">反对称矩阵符号</h4>
<p>对于一个三维向量<span class="math inline">\(\boldsymbol{\phi}=[\phi_1,\phi_2,\phi_3]^T\)</span>，记其对应的反对称矩阵<span class="math inline">\(\boldsymbol{\phi}^{\wedge}\in \mathbb{R}^{3\times3}\)</span>，具有如下形式。符号<span class="math inline">\(\wedge\)</span>称作<em>hat</em></p>
<p><span class="math display">\[
\boldsymbol\phi^{\wedge} = 
\begin{bmatrix}
\phi_1\\
\phi_2\\
\phi_3
\end{bmatrix}^{\wedge}
=\
\begin{bmatrix}
0&amp;-\phi_3&amp;\phi_2\\
\phi_3&amp;0&amp;-\phi_1\\
-\phi_2&amp;\phi_1&amp;0
\end{bmatrix}\tag{hat}
\]</span></p>
<p>同样的，任意一个反对称矩阵通过<em>vee</em>操作得到对应的三维向量</p>
<p><span class="math display">\[
(\boldsymbol\phi^{\wedge})^{\vee}
=\
\begin{bmatrix}
0&amp;-\phi_3&amp;\phi_2\\
\phi_3&amp;0&amp;-\phi_1\\
-\phi_2&amp;\phi_1&amp;0
\end{bmatrix}^{\vee}
=\begin{bmatrix}
\phi_1\\
\phi_2\\
\phi_3
\end{bmatrix}\tag{vee}
\]</span></p>
<h4 id="李代数与李群的关系">李代数与李群的关系</h4>
<ul>
<li><p>每个李群都对应一个李代数。<span class="math inline">\(SO(3)\)</span>群的李代数是<span class="math inline">\(\mathfrak{so}(3)\)</span></p></li>
<li><p>为了不造成理解困难，这里只用<span class="math inline">\(SO(3)\)</span>群作为讲解。（笔者发现，用<span class="math inline">\(SO(3)\)</span>群作为例子，不看<span class="math inline">\(SE(3)\)</span>群理解起来会更容易）</p></li>
<li><p>为什么要引入李代数？ 一句话说明：在<span class="math inline">\(SO(3)\)</span>群上求导不太容易，因为旋转矩阵上的加法没有良好性质（两个旋转矩阵的加法不一定是一个旋转矩阵;回忆导数的定义，输入的微小变化造成的输出的改变量），而旋转矩阵的乘积在其中一者为微小量的时候，可以对应到李代数空间的线性关系。利用这一性质可以对旋转矩阵进行求导。旋转矩阵的更性也可以对应到李代数空间上的线性更新。后文会详细解说。</p></li>
<li><p>李代数对应李群单位元处的切空间 旋转矩阵群的单位元就是单位矩阵。李代数对应李群单位元处的切空间这一点只是两者的性质，与后文的指数/对数映射没有太大关系。（笔者一开始总是误会指数/对数映射只能在李群单位元处进行）</p></li>
</ul>
<h4 id="对数映射log和指数映射exp">对数映射（log）和指数映射（exp）</h4>
<p>《视觉SLAM十四讲》中这部分内容（第四讲）是通过旋转矩阵求导引出的，但其实这部分的推导只是建立一个感性的理解。李群李代数的指数/对数映射应该具有更严格的定义。所以这部分内容其实不要太过纠结。</p>
<p><strong><em>再次强调</em></strong>：这部分推导只是为了建立感性认识</p>
<p>由于旋转矩阵的性质：</p>
<p><span class="math display">\[
RR^T = \mathbf{I}
\]</span></p>
<p>上式对旋转矩阵求导（<span class="math inline">\(\dot{R}\)</span>表示<span class="math inline">\(R\)</span>的导数）：</p>
<p><span class="math display">\[
\dot{R}R^T + R\dot{R}^T=\mathbf{0}
\]</span></p>
<p>（这里对旋转矩阵求导，应该将其看作是一个变量，在时刻变化）</p>
<p>即：</p>
<p><span class="math display">\[
\dot{R}R^T = -R\dot{R}^T=-(\dot{R}R^T)^T
\]</span></p>
<p>也就是<span class="math inline">\(\dot{R}R^T\)</span>是一个反对称矩阵，我们将其记为<span class="math inline">\(\boldsymbol{\phi}^{\wedge}\)</span>，则我们可以得到：</p>
<p><span class="math display">\[
\begin{split}
\dot{R}R^T &amp;= \boldsymbol{\phi}^{\wedge}\\
\dot{R} &amp;= \boldsymbol{\phi}^{\wedge}R
\end{split}
\]</span></p>
<p>上式是关于<span class="math inline">\(R\)</span>的一个微分方程，我们可以看出，当</p>
<p><span class="math display">\[
R=\exp(\boldsymbol{\phi}^{\wedge})
\]</span></p>
<p>的时候，刚好满足上面的微分方程。同时，当<span class="math inline">\(R=\mathbf{I}\)</span>时，上面的微分方程刚好是<span class="math inline">\(\dot{R}=\boldsymbol{\phi}^{\wedge}\)</span>，所以说反对称矩阵空间是旋转矩阵单位元处的切平面（导数）。</p>
<p>于是，我们直接地引入定义：指数映射将李代数空间映射到李群空间，指数映射将李群映射到李代数空间。</p>
<p><span class="math display">\[
\begin{split}
\exp(\cdot):\mathfrak{so}(3)\rightarrow SO(3)\\
\log(\cdot):SO(3) \rightarrow \mathfrak{so}(3)
\end{split}
\]</span></p>
<h2 id="so3上的对数映射mathfrakso3的指数映射">SO(3)上的对数映射/<span class="math inline">\(\mathfrak{so}(3)\)</span>的指数映射</h2>
<h3 id="mathfrakso3的指数映射"><span class="math inline">\(\mathfrak{so}(3)\)</span>的指数映射</h3>
<p>令三维向量<span class="math inline">\(\boldsymbol{\phi}\)</span>的模为<span class="math inline">\(\theta\)</span>，方向向量为<span class="math inline">\(\boldsymbol{a}\)</span>，即</p>
<p><span class="math display">\[
\theta = ||\boldsymbol{\phi}||\\
\boldsymbol{a} = \frac{\boldsymbol{\phi}}{||\boldsymbol{\phi}||}
\]</span></p>
<p>经过一系列的推导，可以得到指数映射的公式如下：</p>
<p><span class="math display">\[
\begin{split}
\exp(\boldsymbol{\phi}^{\wedge}) &amp;= \exp(\theta\boldsymbol{a})\\
&amp;= \cos{\theta}\mathbf{I} + (1 - \cos{\theta})\boldsymbol{a}\boldsymbol{a}^T+\sin{\theta}\boldsymbol{a}^{\wedge}
\end{split}\tag{exp-1}
\]</span></p>
<p>上面公式的一种等价写法（不使用模和方向代替）为：</p>
<p><span class="math display">\[
\begin{split}
\exp(\boldsymbol{\phi}^{\wedge}) = \mathbf{I} + \frac{\sin{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||} + \frac{1 - \cos{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||^2}(\boldsymbol{\phi}^{\wedge})^2
\end{split}\tag{exp-2}
\]</span></p>
<p>上面这两个公式叫做罗德里格斯（Rodrigues' formula），也是将 <strong><em>旋转向量</em></strong> 变换为旋转矩阵的变换公式。从上面两个公式我们也可以看出，<span class="math inline">\(\mathfrak{so}(3)\)</span>李代数空间实际上也是 <strong><em>旋转向量</em></strong> 组成的空间。又因为旋转角的周期为<span class="math inline">\(2\pi\)</span>，所以一个旋转向量可以对应到一个旋转矩阵，但是一个旋转矩阵会对应到多个旋转向量（满射）。但是如果将旋转角限制在<span class="math inline">\([-\pi,\pi)\)</span>，则是单射。</p>
<h3 id="so3上的对数映射">SO(3)上的对数映射</h3>
<p>从上面的关系，我们可以知道要把李群<span class="math inline">\(SO(3)\)</span>映射到李代数，只需要用旋转矩阵计算旋转矢量即可。从旋转矩阵<span class="math inline">\(R\)</span>计算旋转角公式为：</p>
<p><span class="math display">\[
\theta = \arccos \frac{tr(R)-1}{2}\tag{ln-01}
\]</span></p>
<p>又由于旋转轴使用旋转矩阵旋转后方向不变，即：</p>
<p><span class="math display">\[
R\boldsymbol{a} = \boldsymbol{a}\tag{ln-02}
\]</span></p>
<p>所以<strong>旋转轴对应<span class="math inline">\(R\)</span>特征值为1的特征向量</strong></p>
<p>轴向量也可以使用下面公式计算</p>
<p><span class="math display">\[
\log(R) = 
\frac{\theta \cdot (R-R^T)}{2sin(\theta)}\quad \text{with} \quad R\neq\mathbf{I}\tag{ln-03}
\]</span></p>
<h3 id="指数映射的一阶近似">指数映射的一阶近似</h3>
<p>指数映射的严格展开形式为:</p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge}) = \sum^{\infty}_{n=0}\frac{1}{n!}(\boldsymbol{\phi}^{\wedge})^n
\]</span></p>
<p>当<span class="math inline">\(\boldsymbol{\phi}\)</span>是微小量时，忽略二次项及以上，得到指数映射的一阶近似：</p>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge})\approx \mathbf{I} + \boldsymbol{\phi}^{\wedge} \tag{exp-1st}
\]</span></p>
<p><strong><em>上面这个公式经常被使用到，要牢记</em></strong></p>
<h2 id="李群李代数总结">李群李代数总结</h2>
<ul>
<li>引入李代数的原因是在SLAM中常用的群：<span class="math inline">\(SO(3),SE(3),Sim(3)\)</span>没有良好定义的加法，因此在优化的时候没法直接往上更新一个微小增量</li>
<li>另一个原因是<span class="math inline">\(SO(3),SE(3),Sim(3)\)</span>这些群都有额外的限制，直接优化就变成了带约束的优化，而转到李代数空间则是一个无约束的优化问题</li>
<li>在后面我们可以看到当旋转矩阵乘以一个微小扰动可以对应到李代数空间的近似线性相加，这为优化带来很大的好处</li>
<li>李代数通过指数映射到李群，李群通过对数映射到李代数</li>
<li>李代数是李群单位元处的切平面</li>
<li>不要纠结上面的这句话！！！！对数映射/指数映射可以对整个李群/李代数空间进行映射！！！</li>
</ul>
<h2 id="bch近似">BCH近似</h2>
<p>BCH(Baker-Campbell-Hausdorff)公式表达两个李代数指数映射乘积的完整形式（很复杂，不用记），但是但忽略高阶项后则会出现优美的线性表达。</p>
<p>当旋转矩阵<span class="math inline">\(R\)</span>左乘或者右乘上一个微小量<span class="math inline">\(\Delta{R}\)</span>时，会近似（BCH近似）对应李代数空间线性相加，记<span class="math inline">\(R\)</span>的李代数为<span class="math inline">\(\boldsymbol{\phi}\)</span>，<span class="math inline">\(\Delta{R}\)</span>的李代数为<span class="math inline">\(\Delta \boldsymbol{\phi}\)</span></p>
<p><strong>BCH近似有左乘右乘两种形式，笔者发现学习的时候以一种形式去推导即可，更容易理解，下面以右乘的形式进行讲解（十四讲中是以左乘作为讲解）</strong></p>
<h3 id="bch近似右乘形式">BCH近似右乘形式</h3>
<p><span class="math display">\[
\exp(\boldsymbol{\phi}^{\wedge})\exp(\boldsymbol{\Delta{\phi}}^{\wedge})=\exp\big(J_r^{-1}(\boldsymbol{\phi})\Delta{\boldsymbol{\phi}}+\boldsymbol{\phi}\big)\tag{BCH}
\]</span></p>
<p>其中<span class="math inline">\(J_r(\boldsymbol{\phi})\)</span>乘为右乘雅各比：</p>
<p><span class="math display">\[
J_r(\boldsymbol{\phi}) = \mathbf{I}-\frac{1-\cos{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||^2} + \frac{||\boldsymbol{\phi}||-\sin{||\boldsymbol{\phi}||}}{||\boldsymbol{\phi}||^3}(\boldsymbol{\phi}^{\wedge})^2\tag{BCH-Jr}
\]</span></p>
<p>也可以写成轴-角的形式</p>
<p><span class="math display">\[
J_r{(\boldsymbol{\phi})} = \frac{\sin{\theta}}{\theta}\mathbf{I}+(1-\frac{\sin{\theta}}{\theta})\boldsymbol{a}\boldsymbol{a}^T-\frac{1-\cos{\theta}}{\theta}\boldsymbol{a}^{\wedge}
\]</span></p>
<p>上面两种等价关系的变换中需要用到一个性质</p>
<p><span class="math display">\[
\boldsymbol{a}^{\wedge}\boldsymbol{a}^{\wedge} = \boldsymbol{a}\boldsymbol{a}^T - \mathbf{I}
\]</span></p>
<p>另外</p>
<p><span class="math display">\[
J_r^{-1}(\boldsymbol{\phi})=\mathbf{I}+\frac{1}{2}\boldsymbol{\phi}^{\wedge}+\big(\frac{1}{||\boldsymbol{\phi}||^2}-\frac{1+\cos{||\boldsymbol{\phi}||}}{2||\boldsymbol{\phi}||\sin{||\boldsymbol{\phi}||}}\big)(\boldsymbol{\phi}^{\wedge})^2
\]</span></p>
<h3 id="bch近似的其他表达形式">BCH近似的其他表达形式</h3>
<p>BCH近似是为了能够将<span class="math inline">\(SO(3)\)</span>上的矩阵乘积变成李代数上的加法，下面几条公式只是公式（BCH）的其他表达形式，后面也会频繁用到</p>
<p><span class="math display">\[
\exp\big((\boldsymbol{\phi}+\Delta{\boldsymbol{\phi}})^{\wedge}\big) = \exp(\boldsymbol{\phi}^{\wedge})\exp(J_r\Delta{\boldsymbol{\phi}}^{\wedge})\tag{BCH-2}
\]</span></p>
<h2 id="so3上的李代数求导"><span class="math inline">\(SO(3)\)</span>上的李代数求导</h2>
<p>加入我们对一个空间点<span class="math inline">\(\boldsymbol{p}\)</span>进行旋转，得到<span class="math inline">\(R\boldsymbol{p}\)</span>，要求相对于<span class="math inline">\(R\)</span>的导数。由于<span class="math inline">\(SO(3)\)</span>上没有加法，于是我们没法直接使用导数的定义进行计算。但是我们可以将<span class="math inline">\(R\)</span>映射到李代数空间<span class="math inline">\(\boldsymbol{\phi}{\wedge}\)</span>，并在李代数空间进行求导（SLAM十四讲公式4.41使用BCH左乘模型推导，这里使用右乘模型推导）</p>
<h3 id="李代数空间求导">李代数空间求导</h3>
<p><span class="math display">\[
\begin{split}
\frac{\partial(R\boldsymbol{p})}{\partial{R}} &amp;= \frac{\partial{\big(\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}\big)}}{\partial{\boldsymbol{\phi}}}\\
&amp;\overset{1}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}\frac{\exp(\big(\boldsymbol{\phi}+\Delta{\boldsymbol{\phi}})^{\wedge}\big)\boldsymbol{p} - \exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{2}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})\exp(J_r\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{3}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})(\mathbf{I}+J_r\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{4}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})J_r\Delta{\boldsymbol{\phi}^{\wedge}}\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{5}{=}\lim_{\Delta{\boldsymbol{\phi}}\rightarrow0}
\frac
{-\exp(\boldsymbol{\phi}^{\wedge})J_r\boldsymbol{p}^{\wedge}\Delta{\boldsymbol{\phi}}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;=-RJ_r\boldsymbol{p}^{\wedge}
\end{split}
\]</span></p>
<p>上式的推导中，等号1是导数的定义;等号2使用BCH右乘近似公式，也就是上文公式（BCH-2）;等号3是指数映射的一阶近似，也就是上文公式（exp-1st）;等号5利用了下面的性质</p>
<p><span class="math display">\[
\boldsymbol{a}^{\wedge}\boldsymbol{b} = -\boldsymbol{b}^{\wedge}\boldsymbol{a}\tag{skew-prop}
\]</span></p>
<p>将上面的结果记为 <span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=-RJ_r\boldsymbol{p}^{\wedge}\tag{dR-alg-R}
\]</span></p>
<p>如果在上面的推导中使用左乘模型进行推导，结果会稍微有点不同：</p>
<p><span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=(-R\boldsymbol{p})^{\wedge}J_l\tag{dR-alg-L}
\]</span></p>
<h3 id="李群空间求导">李群空间求导</h3>
<p>另一种更常见的做法是在李群上对<span class="math inline">\(R\)</span>进行一个扰动<span class="math inline">\(\exp(\Delta{\boldsymbol{\phi}^{\wedge}})\)</span>，计算结果相对于扰动的变化率。SLAM十四讲中使用左扰动推导，这里使用右扰动推导一下</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial(R\boldsymbol{p})}{\partial{R}}
&amp;=\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})\exp(\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{1}{=}\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})(\mathbf{I}+\Delta{\boldsymbol{\phi}^{\wedge}})\boldsymbol{p}-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{2}{=}\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{\exp(\boldsymbol{\phi}^{\wedge})\Delta{\boldsymbol{\phi}^{\wedge}}\boldsymbol{p}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;\overset{3}{=}\lim_{\Delta{\boldsymbol{\phi}\rightarrow0}}
\frac
{-\exp(\boldsymbol{\phi}^{\wedge})\boldsymbol{p}^{\wedge}\Delta{\boldsymbol{\phi}}}
{\Delta{\boldsymbol{\phi}}}\\
\\
&amp;=-R\boldsymbol{p}^{\wedge}
\end{split}
\]</span></p>
<p>其中等号1使用指数映射的一阶近似，也就是公式（exp-1st）;等号3使用反对称矩阵的性质，也就是公式（skew-prop）。</p>
<p>如果使用左扰动推导，结果会稍有不同，我们将两者记为如下</p>
<p>右扰动模型：</p>
<p><span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=-R\boldsymbol{p}^{\wedge}\tag{dR-group-R}
\]</span></p>
<p>左扰动模型：</p>
<p><span class="math display">\[
\frac{\partial(R\boldsymbol{p})}{\partial{R}}=-(R\boldsymbol{p})^{\wedge}\tag{dR-group-L}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/30/slam-theory/MAP2LSP_02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/30/slam-theory/MAP2LSP_02/" class="post-title-link" itemprop="url">SLAM基础——如何从最大后验概率到最小二乘（应用篇）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-30 10:12:01" itemprop="dateCreated datePublished" datetime="2023-05-30T10:12:01+08:00">2023-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 11:53:54" itemprop="dateModified" datetime="2023-06-14T11:53:54+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/05/30/slam-theory/MAP2LSP_02/" class="post-meta-item leancloud_visitors" data-flag-title="SLAM基础——如何从最大后验概率到最小二乘（应用篇）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="SLAM基础——如何从最大后验概率到最小二乘（应用篇）" href="/2023/05/30/slam-theory/MAP2LSP_02/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::996c42066e615cfa17c6dba93a63cf5f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="理论篇回顾">理论篇回顾</h2>
<p>总结一下《理论篇》的推理过程：</p>
<ol type="1">
<li>SLAM后端优化的任务是最大似然函数，也就是在已知观测的情况下通过最大化似然函数确定最有可能的机器人位姿</li>
<li>最大似然在高斯分布的情况下最终可以转换成一个二次型，具体含义是最小化观测和模型的误差（经过信息矩阵也就是协方差倒数的加权）</li>
</ol>
<p>用公式可以写为：</p>
<p><span class="math display">\[
\begin{equation}
\begin{split}
\hat{x}_{MLE}
&amp;= \underset{x}{\operatorname{argmin}} \big(z-h(x)\big)^T\Sigma^{-1}\big(z-h(x)\big)\\
&amp;= \underset{x}{\operatorname{argmin}}||z - h(x)||^2_{\Sigma^{-1}}\\
&amp;= \underset{x}{\operatorname{argmin}}||e_z||^2_{\Sigma^{-1}}
\end{split}
\end{equation}
\tag{1}
\]</span></p>
<h2 id="最小二乘的标准形式">最小二乘的标准形式</h2>
<p>在前文的公式中，向量的符号没有加粗，且推导的过程没有用正式的符号，这里先对前面的结果做更标准化的复述。</p>
<p>令机器人每一时刻的位姿为<span class="math inline">\(\boldsymbol{x}_i, i\in [0,1,2,...)\)</span>，每一时刻的观测为<span class="math inline">\(\boldsymbol{z}_i,i\in[0,1,2,...)\)</span>，记机器人历史轨迹的位姿集合为<span class="math inline">\(\boldsymbol{X},\boldsymbol{x}_i\in\boldsymbol{X}\)</span>，则公式（1）可以写为：</p>
<p><span class="math display">\[
\begin{split}
\hat{\boldsymbol{X}}_{MLE}
&amp;= \underset{\boldsymbol{x}_i}{\operatorname{argmin}}\sum_{i}\big(\boldsymbol{z}_i - \boldsymbol{h}(\boldsymbol{x}_i)\big)^T\boldsymbol{\Sigma}_i^{-1}\big(\boldsymbol{z}_i - \boldsymbol{h}(\boldsymbol{x}_i)\big)\\
&amp;=\underset{\boldsymbol{x}_i}{\operatorname{argmin}}\sum_{i}\boldsymbol{e}_i^T\boldsymbol{\Sigma}_i^{-1}\boldsymbol{e}_i
\end{split}\tag{2}
\]</span></p>
<p>上面的形式又叫加权的平方误差（Weighted Sum of Squared Error），权重系数在这里是<span class="math inline">\(\boldsymbol{\Sigma}_i^-1\)</span>，也就是协方差的倒数，直观含义就是对于不确定的观测（方差较大）赋予较低的权重。我们可以对<span class="math inline">\(\boldsymbol{e}_i\)</span>提前乘以一个系数<span class="math inline">\(L_i\)</span>，<span class="math inline">\(L_i\)</span>满足<span class="math inline">\(\boldsymbol{\Sigma}_i^{-1}=\boldsymbol{L}_i\boldsymbol{L}_i^T\)</span>，并记<span class="math inline">\(\bar{\boldsymbol{e}}_i=\boldsymbol{L}_i\boldsymbol{e}_i\)</span>，则</p>
<p><span class="math display">\[
\begin{split}
\hat{\boldsymbol{X}}_{MLE}&amp;=\underset{\boldsymbol{x}_i}{\operatorname{argmin}}\sum_{i}||\bar{\boldsymbol{e}}_i||^2
\end{split}\tag{3}
\]</span></p>
<p>公式（3）称为最小二乘的标准形式。</p>
<p>不过要注意的是，在SLAM中一些优化问题中比如BA,是直接构造最小二乘问题，同时也没有加入权重。这并不影响我们的理解。最小二乘问题从直观上就是让误差最小化。</p>
<h2 id="bundleadjustment">BundleAdjustment</h2>
<p>我觉得在这里加入BA(BundleAdjustment)问题的讲解可以加深对这部分的印象和理解。BA又叫光束法平差，或者捆绑调整。Bundle的意思是同时对相机位姿和关键点进行优化。</p>
<p><strong>PS</strong>：这部分其实《视觉SLAM十四讲》第九讲讲得很好，也可以直接参考十四讲的内容。这里主要和前文的公式建立联系，让这一部分的内容更为完整。</p>
<p>假设机器人移动经过三个点，相机的位姿分别为<span class="math inline">\(\boldsymbol{x}_1,\boldsymbol{x}_2, \boldsymbol{x}_3\)</span>，空间中有三个路标点<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2,\boldsymbol{p}_3\)</span></p>
<figure>
<img src="./imgs/01-BA.png" alt="" /><figcaption>BA问题示例图</figcaption>
</figure>
<p>定义相机投影方程<span class="math inline">\(\pi(\cdot)\)</span>，相机投影方程将世界坐标系下的点转换到相机坐标系然后投影到像素坐标系：</p>
<p><span class="math display">\[
\pi(\boldsymbol{p}) = K\big(R\boldsymbol{p}+\boldsymbol{t}\big)
\]</span></p>
<p>其中，<span class="math inline">\(K\)</span>是相机内参，<span class="math inline">\(R,\boldsymbol{t}\)</span>是相机位姿</p>
<p>关键点可以直接通过图像计算得到，也就是观测<span class="math inline">\(\boldsymbol{z}_i := [u_i,v_i]^T\)</span></p>
<p>将所有时刻的位姿以及每个位姿能够观测到的特征点都累加起来，并用标准的二次平方损失函数表达，则整体的代价函数为</p>
<p><span class="math display">\[
\sum_{i=1}^{M}\sum_{j=1}^{N}||\boldsymbol{e}_{ij}||^2=\sum_{i=1}^{M}\sum_{j=1}^{N}||\boldsymbol{z}_i-\pi(\boldsymbol{p}_j)||^2
\]</span></p>
<p>将相机位姿<span class="math inline">\(\boldsymbol{x}_i\)</span>和路标（landmark）点<span class="math inline">\(\boldsymbol{p}_j\)</span>共同当作变量进行优化，得到优化方程如下：</p>
<p><span class="math display">\[
\begin{split}
\hat{\boldsymbol{X}},\hat{\boldsymbol{P}}
&amp;= \underset{\boldsymbol{x}_i, \boldsymbol{p}_j}{\operatorname{argmin}}\sum_{i=1}^{M}\sum_{j=1}^{N}v_{ij}||\boldsymbol{z}_i-\pi(\boldsymbol{p}_j)||^2
\end{split}\tag{3}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(M\)</span>是位姿点的数量，<span class="math inline">\(N\)</span>是路标点的数量</li>
<li><span class="math inline">\(v_{ij}\)</span>是一个二元变量，当点<span class="math inline">\(\boldsymbol{p}_j\)</span>能够被位姿点<span class="math inline">\(\boldsymbol{x}_i\)</span>观察到时，<span class="math inline">\(v_{ij}=1\)</span>，否则<span class="math inline">\(v_{ij}=0\)</span></li>
</ul>
<p>至于要如何求解上面的最小二乘公式，就是非线性优化了，要讲清楚可能要单开一篇文章。但是从上一篇还有这一篇的论述，读者应该要清晰地建立从MAP问题到最小二乘问题的推演过程，这样也才能够更好地理解论文里频繁出现的MAP</p>
<h2 id="鲁棒核函数">鲁棒核函数</h2>
<p>让我们重新看一下上述公式（3），求解这样的一个二次型一般需要用非线性优化方法，优化过程中会涉及到对这个二次型求偏导。这样就会出现一个问题，如果<span class="math inline">\(\boldsymbol{z}_i\)</span>与<span class="math inline">\(\boldsymbol{p}_j\)</span>的匹配关系出现错误，或者<span class="math inline">\(\boldsymbol{z}_i\)</span>计算错误，那么二次型就会非常大。这样在优化过程中，导数会被错误项占据主要地位，这样更新的时候就往错误的方向进行更新。</p>
<p><strong>PS:在上述描述的BA问题中，<span class="math inline">\(\boldsymbol{z}_i\)</span>通常是对图像进行特征点检测得出特征点的位置和描述子，<span class="math inline">\(\boldsymbol{p}_j\)</span>是地图中点，两者的匹配关系通常可以通过特征点匹配的方式得到。</strong></p>
<p>为了解决上面的问题，我们把二次函数替换为其他函数，使得在误差较大的地方函数值不至于过大导致导数过大。这些函数就叫鲁棒核函数（Robust Kernel）。</p>
<h3 id="huber核函数">Huber核函数</h3>
<p>一种较为常见的核函数叫做Huber核函数，在很多论文中都使用该函数，其具有如下形式</p>
<p><span class="math display">\[
H(e) = 
\begin{cases}
\frac{1}{2}e^2,&amp;||e||\leq \delta\\
\delta\left(||e||-\frac{1}{2}\delta\right),&amp;else
\end{cases}\tag{4}
\]</span></p>
<p>Huber核函数与二次函数的函数曲线如下图</p>
<figure>
<img src="./imgs/02-l2_huber.png" alt="" /><figcaption>Huber函数与二次函数曲线</figcaption>
</figure>
<h3 id="核函数的特点和其他核函数">核函数的特点和其他核函数</h3>
<p>从上面的描述中我们其实不难得出鲁棒核函数应该具有的两个特点：</p>
<ol type="1">
<li>光滑。即处处可导</li>
<li>函数增长的速度要比二次函数慢</li>
</ol>
<p>从Huber函数公式（4）我们可以看出当<span class="math inline">\(||e||=\delta\)</span>的时候，上下两式结果是一样的，因此Huber函数明显是一个光滑的函数。</p>
<p>常见的其他鲁棒核函数还有Cauchy、Tukey核等，从网上找了一张各个核函数和二次函数的函数曲线对比图</p>
<figure>
<img src="./imgs/03-robust_kernels.png" alt="" /><figcaption>不同核函数的函数曲线</figcaption>
</figure>
<h3 id="一些思考">一些思考</h3>
<p>鲁棒核函数让我联想到了神经网络中的激活函数，SLAM中的图优化也让我觉得跟神经网络的梯度回传有点相似。神经网络的训练目标其实也是MAP问题（从训练集中估计出样本的分布，并使用该分布来预测测试集），而且很多的神经网络目标函数也是一个二次型。不过区别比较大的是，神经网络中大部分操作是线性操作（卷积、全连接），而SLAM中很多操作都是非线性的（旋转）。在图优化中的更新过程使用非线性优化方法（比如高斯牛顿法）也是需要在每一步更新过程中近似估计目标函数对于变量的偏导数，这点与神经网络的梯度回传是类似的。</p>
<p>既然三层全连接层的神经网络就可以拟合任意次的函数，那么是否有可能用神经网络来做SLAM的后端优化？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/29/slam-theory/MAP2LSP_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/29/slam-theory/MAP2LSP_01/" class="post-title-link" itemprop="url">SLAM基础——如何从最大后验概率到最小二乘（理论篇）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-29 10:12:01" itemprop="dateCreated datePublished" datetime="2023-05-29T10:12:01+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-14 11:37:30" itemprop="dateModified" datetime="2023-06-14T11:37:30+08:00">2023-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Theory/" itemprop="url" rel="index"><span itemprop="name">Theory</span></a>
        </span>
    </span>

  
    <span id="/2023/05/29/slam-theory/MAP2LSP_01/" class="post-meta-item leancloud_visitors" data-flag-title="SLAM基础——如何从最大后验概率到最小二乘（理论篇）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="SLAM基础——如何从最大后验概率到最小二乘（理论篇）" href="/2023/05/29/slam-theory/MAP2LSP_01/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::beb83704626c889ddf4360511dbc14eb" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="最大后验概率">最大后验概率</h2>
<h3 id="符号说明">符号说明</h3>
<p>本文的标记没有用粗体表示，但是要记住本文的变量都是任意多维变量</p>
<h3 id="定义">定义</h3>
<p>最大后验概率（MAP:Maximum a Posterior）具有以下逻辑</p>
<ol type="1">
<li>我们的最终目标是想要估计一个未知量<span class="math inline">\(x\)</span>，令其概率分布为<span class="math inline">\(p(x)\)</span>.</li>
<li>如果我们能够知道<span class="math inline">\(p(x)\)</span>的具体表达，则<span class="math inline">\(x\)</span>的估计值应该使得概率最大</li>
<li>当我们知道一些与<span class="math inline">\(x\)</span>有关的观测结果<span class="math inline">\(z\)</span>，<span class="math inline">\(p(x|z)\)</span>称做<span class="math inline">\(x\)</span>的后验概率</li>
<li>于是我们的估计可以变成使得<span class="math inline">\(p(x|z)\)</span>最大化的<span class="math inline">\(x\)</span></li>
</ol>
<p>上述问题称作最大后验概率，也就是在已知观测值的情况下如何求取未知量。 从形式上可以做如下定义：</p>
<p><span class="math display">\[
\hat{x}_{MAP}(z)=\underset{x}{\operatorname{argmax\ }}p(x|z)\tag{1}
\]</span></p>
<h3 id="将上述定义代入slam问题">将上述定义代入SLAM问题</h3>
<ol type="1">
<li><span class="math inline">\(x\)</span>对应机器人的位姿</li>
<li><span class="math inline">\(z\)</span>对应SLAM系统的观测，比如路标点、激光里程计的输出、视觉里程计的输出等</li>
<li>SLAM的后端优化最终目标就是求取在给定的观测下，机器人的位姿估计值，也就是使得后验概率<span class="math inline">\(p(x|z)\)</span>最大化的位姿<span class="math inline">\(x\)</span></li>
</ol>
<h2 id="最大似然估计">最大似然估计</h2>
<h3 id="贝叶斯定理">贝叶斯定理</h3>
<p>为了让没有基础的读者更容易理顺推理的过程，我们先简单介绍一下贝叶斯定理（Bayes's theorem）</p>
<p>贝叶斯定义描述随机事件A和B的条件概率的一个关系： <span class="math display">\[
P(A|B) = \frac{P(A)P(B|A)}{P(B)}\tag{Bayes&#39;s Theorem}
\]</span></p>
<ul>
<li><span class="math inline">\(P(A)\)</span>是<span class="math inline">\(A\)</span>的先验概率，也就是事件<span class="math inline">\(A\)</span>的概率分布。<span class="math inline">\(P(B)\)</span>同理</li>
<li><span class="math inline">\(P(A|B)\)</span>是事件<span class="math inline">\(B\)</span>发生后<span class="math inline">\(A\)</span>的条件概率，也叫<span class="math inline">\(B\)</span>发生后<span class="math inline">\(A\)</span>的后验概率</li>
<li><span class="math inline">\(P(A|B)\)</span>表示的是事件<span class="math inline">\(B\)</span>是结果，A是因，就是在知道结果的情况下求原因的概率</li>
<li><span class="math inline">\(P(B|A)\)</span>是事件<span class="math inline">\(A\)</span>发生后<span class="math inline">\(B\)</span>的条件概率。但是应该理解当<span class="math inline">\(B\)</span>固定后<span class="math inline">\(A\)</span>的<strong>似然</strong>，也就是<span class="math inline">\(P(B|A)=L(A|B)\)</span></li>
<li><span class="math inline">\(P(B|A)\)</span>或者<span class="math inline">\(L(A|B)\)</span>表示已知有事件B发生，运用似然函数<span class="math inline">\(L(A|B)\)</span>，我们估计或猜测<span class="math inline">\(A\)</span>的不同值的可能性</li>
</ul>
<p><strong>注意：在上面中<span class="math inline">\(A、B\)</span>是有区分的，虽然<span class="math inline">\(P(B|A)\)</span>的形式与条件概率函数的形式相同，但是我们关注的变量是<span class="math inline">\(A\)</span></strong></p>
<p>参考： 1. 关于贝叶斯定理的推导<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bayes%27_theorem#Statement_of_theorem">wiki</a> 2. 关于似然函数的理解<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0">wiki</a></p>
<h3 id="从最大后验概率map到最大似然估计mle">从最大后验概率（MAP）到最大似然估计（MLE）</h3>
<p><strong>回顾</strong>：（对理解很重要，所以回顾一下）在公式（1）中，<span class="math inline">\(x\)</span>代表我们要估计的机器人位姿，<span class="math inline">\(z\)</span>代表我们的观测。这里的观测是一个宽泛的定义，路标（landmark）可以是一种观测，图像特征点也可以是一种观测，激光里程计或者视觉里程计的结果也可以是一种观测。 <strong>注意</strong>：应该是现有了机器人当前的位姿，然后在当前位姿下对周围环境进行观测。也就是当前位姿是 <strong><em>因</em></strong>，观测是 <strong><em>果</em></strong></p>
<p>根据贝叶斯定理，有：</p>
<p><span class="math display">\[
\begin{split}
p(x|z) &amp;= \frac{p(z|x)p(x)}{p(z)}\\
&amp;\propto p(z|x)p(x)
\end{split}
\]</span></p>
<p>上述公式结果的第一项称为 <strong><em>似然</em></strong>（likelihood），第二项是是 <strong><em>先验</em></strong>（prior） 用文字解释一下就是，直接求位姿的最大后验概率是很困难的，但是根据贝叶斯法则，我们可以转换为求取似然和先验的乘积的最大，即下式</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MAP} &amp;= \underset{x}{\operatorname{argmax\ }}p(x|z)\\
&amp;= \underset{x}{\operatorname{argmax\ }}p(z|x)p(x)\\
&amp;\approx \underset{x}{\operatorname{argmax\ }}p(z|x)
\end{split}\tag{2}
\]</span></p>
<p>当然，我们也没有机器人位姿的先验<span class="math inline">\(p(x)\)</span>，于是，公式（2）可以近似成只求取<strong>最大似然(MLE,Maximum LIkelihood Estimation)</strong></p>
<p><span class="math display">\[
\hat{x}_{MLE} = \underset{x}{\operatorname{argmax\ }}p(z|x)\tag{3}
\]</span></p>
<h3 id="map与mle的联系">MAP与MLE的联系</h3>
<p>在上文公式（2）中我们直接忽略了先验项<span class="math inline">\(p(x)\)</span>，并在最大后验概率和最大似然两者间用了约等号，那么这两者间是否有什么其他关系呢？</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MAP}
&amp;= \underset{x}{\operatorname{argmax\ }}p(x|z)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(x|z)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x)p(x)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x) + \ln p(x)\\
\end{split}
\]</span></p>
<p>如果当先验概率<span class="math inline">\(p(x)\)</span>是一个均分分布的时候，上式就会变成：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MAP}
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x) + \ln p(x)\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x) + constant\\
&amp;= \underset{x}{\operatorname{argmax\ }} \ln p(z|x)
\end{split}
\]</span></p>
<p><strong>也就是说MLP实际上是MAP中，将先验概率做均匀分布假设的特殊情况</strong> 上面这句话就是说，在没有任何其他条件下，我们认为<span class="math inline">\(x\)</span>取任何值的概率都一样。</p>
<p>当然，其实我们也可以直接认为SLAM后端的问题就是在给定观测的情况下，求取位姿的似然</p>
<h3 id="最大似然的负对数形式">最大似然的负对数形式</h3>
<p>公式（3）中，可以对优化目标取负对数（对数函数是单调函数，最大化单调递增函数等价于最小化递减函数），于是，我们有如下形式：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MLE}
&amp;= \underset{x}{\operatorname{argmax\ }}p(z|x)\\
&amp;= \underset{x}{\operatorname{argmin\ }} - \ln p(z|x)
\end{split}\tag{4}
\]</span></p>
<p>我们后文都会采用公式（4）这种形式</p>
<h2 id="从最大似然估计到非线性最小二乘问题">从最大似然估计到非线性最小二乘问题</h2>
<h3 id="高斯分布的最大似然估计形式">高斯分布的最大似然估计形式</h3>
<p>因为高斯分布有很多优美的性质，所以我们在SLAM中大量地假设各种变量符合高斯分布，这一小节先推导高斯分布的最大似然估计的形式，方便后面直接使用。 <strong>PS:这部分的标记没有用粗体表示，但是要记住这里的变量都是多维变量</strong></p>
<p>对于一个任意高维高斯分布：<span class="math inline">\(x \sim \mathcal{N}(\mu,\Sigma)\)</span>，概率密度函数为：</p>
<p><span class="math display">\[
p(x) = \frac{1}{\sqrt{(2\pi)^N det(\Sigma)}}\exp\big(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\big)
\]</span></p>
<p>对上述取负对数，可得：</p>
<p><span class="math display">\[
-\ln(p(x)) = \frac{1}{2}\ln\big((2\pi)^N\det(\Sigma)\big) + \frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\tag{5}
\]</span></p>
<p>由于上述第一项与<span class="math inline">\(x\)</span>无关，于是在求最小化的时候第一项可以忽略。上述第二项中，<span class="math inline">\(\Sigma^{-1}\)</span>叫做 <strong><em>信息矩阵</em></strong> ,为协方差的倒数</p>
<p><span class="math display">\[
信息矩阵 := \Sigma^{-1}
\]</span></p>
<h3 id="slam优化目标的最小二乘形式">SLAM优化目标的最小二乘形式</h3>
<p>令机器人当前时刻的姿态为<span class="math inline">\(x\)</span>,观测于姿态之间的关系使用函数<span class="math inline">\(h(x)\)</span>表达。则，对于观测<span class="math inline">\(z\)</span>，有如下观测模型：</p>
<p><span class="math display">\[
z = h(x) + v
\]</span></p>
<p>其中<span class="math inline">\(v\)</span>为噪声项，我们假设噪声项服从均为为0，方差为<span class="math inline">\(Q\)</span>的高斯分布，也就是</p>
<p><span class="math display">\[
v \sim \mathcal{N}(h(x), Q)
\]</span></p>
<p>于是，而可以得到，在状态<span class="math inline">\(x\)</span>即已知道的情况下，观测<span class="math inline">\(z\)</span>的条件概率（也就是似然）也是一个高斯分布</p>
<p><span class="math display">\[
z \sim \mathcal{N}(h(x), Q)
\]</span></p>
<p>为了求得<span class="math inline">\(x\)</span>，求最大似然，根据公式（5），并忽略第一项和第二项的<span class="math inline">\(\frac{1}{2}\)</span>系数，则：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MLE}
&amp;=\underset{x}{\operatorname{argmax\ }} p(z|x)\\
&amp;=\underset{x}{\operatorname{argmin\ }} -\ln p(z|x)\\
&amp;=\underset{x}{\operatorname{argmin\ }} (z-h(x))^T\Sigma^{-1}(z-h(x))
\end{split}\tag{6}
\]</span></p>
<p>可以看出，公式（6）是一个二次型，可以看成是信息矩阵<span class="math inline">\(\Sigma^{-1}\)</span>加权后的欧式距离（二范数）。其中的<span class="math inline">\(h(x)\)</span>我们可以称为观测模型，描述机器人位姿和观测之间的关系。我们可以定义观测与模型之间的误差如下：</p>
<p><span class="math display">\[
e_{z} = z - h(x)
\]</span></p>
<p>则，公式（6）可以写成</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_{MLE}
&amp;= \underset{x}{\operatorname{argmin\ }}\big(z-h(x)\big)^T\Sigma^{-1}\big(z-h(x)\big)\\
&amp;= \underset{x}{\operatorname{argmin\ }}||e_z||^2_{\Sigma^{-1}}
\end{split}\tag{7}
\]</span></p>
<p>公式（7）的<span class="math inline">\(\Sigma_{-1}\)</span>下标指使用信息矩阵进行加权</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/05/18/orbslam/orbslam3-ORBextractor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/18/orbslam/orbslam3-ORBextractor/" class="post-title-link" itemprop="url">ORB-SLAM3保姆级教程——详解特征点提取</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-18 16:58:39" itemprop="dateCreated datePublished" datetime="2023-05-18T16:58:39+08:00">2023-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-07 10:06:50" itemprop="dateModified" datetime="2023-07-07T10:06:50+08:00">2023-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/Orbslam/" itemprop="url" rel="index"><span itemprop="name">Orbslam</span></a>
        </span>
    </span>

  
    <span id="/2023/05/18/orbslam/orbslam3-ORBextractor/" class="post-meta-item leancloud_visitors" data-flag-title="ORB-SLAM3保姆级教程——详解特征点提取" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="ORB-SLAM3保姆级教程——详解特征点提取" href="/2023/05/18/orbslam/orbslam3-ORBextractor/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::a2b00e2b2d77cb00c0a5bbc2d15a6dd4" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>ORB-SLAM系列使用<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">FAST</a>关键点提取+ORB特征描述子做跟踪、重定位、回环检测。在ORB-SLAM几篇论文中，图像特征提取部分都是一带而过，基本没有详细说明特征提取的方法。但是在实际的代码实现中，这部分内容其实还是做了不少工作的。Opencv中已经对ORB特征提取进行了实现：<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/4.7.0/modules/features2d/src/orb.cpp">OpenCV-orb.cpp</a>。在ORB的原始论文：<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ICCV.2011.6126544">ORB: an efficient alternative to SIFT or SURF</a>已经考虑到了特征点提取的多尺度问题，使用图像金字塔的方式对多个尺度的图像进行ORB特征提取。但是在ORB-SLAM系列中，为了让特征点分散更加均匀，ORB-SLAM的作者根据OpenCV的实现进行了修改，让特征点尽可能地分散到图片的整个区域而不是只有在纹理明显的区域有特征点。不仅如此，在ORB-SLAM1和ORB-SLAM2及之后的代码，对于特征点平均分布的实现还有所不同，可见ORB-SLAM是在不断的迭代改进中成熟的。</p>
<h3 id="orb-slam中图像特征点具有的性质">ORB-SLAM中图像特征点具有的性质</h3>
<ol type="1">
<li>尺度不变性（ORB本身具有的特点）</li>
<li>旋转不变性（ORB本身具有的特点）</li>
<li>分布均匀（ORB-SLAM的实现）</li>
</ol>
<h3 id="感悟">感悟</h3>
<p>看完了ORB-SLAM3中关于特征提取的实现代码，深感做科研和算法的不易。在论文中轻轻带过的几句话在实现中就需要两千多行代码（虽然大部分是基于OpenCV的实现）。另外，在ORBSLAM1中为了实现特征点的均匀分布，是将图像切割成与特征点数量成比例的小区块，每个区块提取5个特征点，点数不够的区块由其他区块补足，但是从ORBSLAM2后，这部分的实现变成用四叉树分割图像。这部分的改进应该更多是为了效率考虑，具体效率还没有进行测试。</p>
<h3 id="本文结构组织">本文结构组织</h3>
<p>本文首先对ORB特征提取做一个详细的介绍，说清楚FAST关键点和BRIEF特征以及rBRIEF特征；然后说明白ORB-SLAM中为了将特征点尽可能均匀地分布到图像中进行的两种实现。</p>
<h2 id="orb特征描述">ORB特征描述</h2>
<p>论文：<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ICCV.2011.6126544">ORB: an efficient alternative to SIFT or SURF</a></p>
<p>图像的特征描述一般有两个步骤：</p>
<ol type="1">
<li>关键点的选取。经典的有<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/dc/d0d/tutorial_py_features_harris.html">Harris Corner</a>，ORB中使用的是<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">FAST</a>角点检测</li>
<li>关键点特征描述子。经典的描述子很多，比如SIFT等。ORB中使用的是改进后的BRIEF描述子，具有角度不变形，叫做rBRIEF</li>
</ol>
<h3 id="fast关键点">FAST关键点</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">OpenCV FAST Corner Detection</a> 论文：<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1007/11744023_34">Machine learning for high-speed corner detection</a></p>
<p>FAST(Features from Accelerated Segment Test) 在论文 <em><a target="_blank" rel="noopener" href="https://sci-hub.st/10.1007/11744023_34">Machine learning for high-speed corner detection</a></em> 中被提出。 相比于其他角点检测，比如<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/dc/d0d/tutorial_py_features_harris.html">Harris Corner</a>或者SIFT的角点检测过程<em>DoG</em> 都要更快，更适合应用到实时性要求高的任务，比如SLAM中。</p>
<h4 id="fast角点提取">FAST角点提取</h4>
<p>FAST角点的核心思想是对于像素<span class="math inline">\(p\)</span>，如果<span class="math inline">\(p\)</span>与其周围的像素值差异比较大，则认为<span class="math inline">\(p\)</span>是一个角点。</p>
<figure>
<img src="./imgs/01-FAST_segment_test.jpg" alt="" /><figcaption>图1：FAST角点提取示例图</figcaption>
</figure>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>在图像中选择一个像素<span class="math inline">\(p\)</span>，令其像素值为<span class="math inline">\(I_p\)</span></li>
<li>以<span class="math inline">\(p\)</span>为中心，往上下左右扩张3个像素值，并以<span class="math inline">\(p\)</span>为中心画圆，以对称的方式选择圆上16个像素。如上图所示</li>
<li>选择一个阈值<span class="math inline">\(t\)</span>，如果第二步中的16个像素有连续<span class="math inline">\(n\)</span>（<span class="math inline">\(n\)</span>一般为12）个像素的值都大于<span class="math inline">\(I_p+t\)</span>或者小于<span class="math inline">\(I_p-t\)</span>，则认为<span class="math inline">\(p\)</span>是角点</li>
<li><strong>快速测试</strong>。执行第3步前可以执行一种快速测试的方法：先测试点1和点9，如果这两个点与<span class="math inline">\(p\)</span>的像素值差都小于<span class="math inline">\(t\)</span>, 则<span class="math inline">\(p\)</span>不可能是角点，否则继续测试点5和点13。只有当1、5、9、13这4个点中至少有3个点与<span class="math inline">\(p\)</span>的像素差大于阈值<span class="math inline">\(t\)</span>才进行第3步的检测。</li>
</ol>
<p>上面这种判断方法叫做<code>Segment Test</code></p>
<h4 id="用机器学习的方法确定16个点的检查顺序">用机器学习的方法确定16个点的检查顺序</h4>
<p>使用上面的16个点的顺序检查不一定是最好的，所以在论文中使用了机器学习的方法确定这16个点的检查顺序。具体来说，这里面用了决策树来在训练集上进行训练，得到一个训练好的决策树。这个决策树用来对其他图片的点做判断是否采纳为角点。阅读这部分内容需要决策树的基础知识，否则很难看懂这部分内容（虽然很简单）。</p>
<p><code>PS:如果不清楚决策树是什么或者不清楚决策树构建过程的读者要先阅读文末的附录A</code><a href="#appendA">附录A</a></p>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>为目标域选择一个训练集</li>
<li>为训练集中的所有图片的所有像素计算圆圈的16个点（见图1）的像素值</li>
<li>对于像素<span class="math inline">\(p\)</span>，其旁边的16个点中的每一个像素<span class="math inline">\(x\)</span>可以根据下面的关系划分为3个状态</li>
</ol>
<p><span class="math display">\[
S_x =
\begin{cases}
    d, &amp; I_x \leq I_p - t &amp;         \text{(darker)}\\
    s, &amp; I_p - t &lt; I_x &lt; I_p + t &amp;  \text{(similar)}\\
    b, &amp; I_p+t \leq I_x &amp;           \text{(brighter)}
\end{cases}    
\]</span></p>
<ol start="4" type="1">
<li>这样子，每个像素就可以得到一个长度为16的特征向量，类似<code>[ddddddssbbbbddss]</code></li>
<li>使用上文中的<code>Segment test</code>的方法确定训练集中的角点（也就是为每个像素赋予了是否是角点的标签），令标签为<span class="math inline">\(K_p\)</span></li>
<li>定义数据集<span class="math inline">\(S\)</span>的熵如下：</li>
</ol>
<p><span class="math display">\[
H(S) = (c+\bar{c})log_2(c+\bar{c}) - clog_2c - \bar{c}log_2\bar{c}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(c\)</span> 指数据集中的角点数量</li>
<li><span class="math inline">\(\bar{c}\)</span> 指非角点的数量</li>
</ul>
<p>上面这个公式其实就是用熵的公式(A-1)计算出来的，相差一个常量而已</p>
<ol start="7" type="1">
<li>构建决策树，对于16个点中的每一个点<span class="math inline">\(x\)</span>，数据集可以分成三个子集（根据第3个步骤，每个点的特征是一个长度为16的向量）<span class="math inline">\(P_d,P_s,P_b\)</span>。对于构建决策树的过程，信息增益可以定义为如下公式：</li>
</ol>
<p><span class="math display">\[
IG(x) = H(P) - H(P_d) - H(P_s) - H(P_b)
\]</span></p>
<p>上面的公式与附录A中的公式(A-2)基本相同，不过少了每个子集的概率。</p>
<p>构建完决策树后对于新的角点，则可以直接使用决策树判定是否是角点。</p>
<h4 id="最大值抑制non-maximal-suppression">最大值抑制（Non-maximal Suppression）</h4>
<p>跟很多的角点监测器一样，需要增加最大值抑制取出相邻的角点。</p>
<h3 id="brief特征描述子">BRIEF特征描述子</h3>
<p>论文：<a target="_blank" rel="noopener" href="https://www.cs.ubc.ca/~lowe/525/papers/calonder_eccv10.pdf">Binary Robust Independent Elementary Features</a> 参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/dc/d7d/tutorial_py_brief.html">OpenCV BRIEF</a></p>
<p>BRIEF(Binary Robust Independent Elementary Features)，区别于其他很多描述子，BRIEF特征描述子使用二进制向量的形式作为特征的表达。一般是256位二进制向量，也就是只需要32字节（32x8=256）。</p>
<p><img src="./imgs/02-BRIEF_blur.png" alt="BRIEF描述子示意" /> 上图来源：https://www.cnblogs.com/alexme/p/11345701.html</p>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>先对图像进行高斯模糊，去除高频噪声对特征的干扰</li>
<li>在选择的关键点附近选取一个圆形范围;圆形范围的选择一般是以关键点为中心，边长为31个像素的正方形的内接圆</li>
<li>在圆内随机挑选点对，点对里第一个点像素值如果大于第二个点的像素值，则描述子对应位的值为1,否则为0</li>
<li>重复第3步，直到描述子长度符合要求（256位需要挑选256个点对）</li>
</ol>
<p><strong>特殊之处</strong></p>
<ol type="1">
<li>点对的挑选策略其实是有很多的，比如均匀分布采样、高斯分布采样、完全随机采样等，[BRIEF的原始论文][#BRIEF]里也有对这些采样方法举例;但是在ORB的论文<a target="_blank" rel="noopener" href="https://sci-hub.st/10.1109/ICCV.2011.6126544">ORB: an efficient alternative to SIFT or SURF</a>里，采用的是一种机器学习的方法来确定点对的挑选顺序，大概意思就是用不同的点对挑选顺序构建多个特征数据集，然后计算这些数据集的方差、特征的平均值，挑选出一种采样方法使得方差较大、平均值接近0.5的挑选顺序。<strong>另外要注意的是， 在OpenCV的视线中，256个点对的挑选顺序是硬编码进<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L380">代码</a>，ORB-SLAM也采用的是OpenCV的实现方式</strong></li>
<li>正方形内接圆的计算由于是在像素层面（离散）计算，为了保证对称性，计算的方式是先算0-45度角内的圆边界，然后对称到90度，再算到整个圆。这部分也可以参看<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L860-L876">OpenCV的实现</a></li>
</ol>
<h3 id="rbrief描述子">rBRIEF描述子</h3>
<p>BRIEF描述子的缺点是对旋转敏感。在做特征点配对过程中，我们希望的是特征描述子是与旋转无关的。为了解决BRIEF描述子对旋转敏感的问题，在ORB特征提取中加入了局部旋转计算操作，将局部图像旋转到主方向之后再计算BRIEF特征，称为<code>rBRIEF</code></p>
<p>局部旋转角（计算BRIEF特征计算时图像块的旋转）采用的方法叫<code>灰度质心法（intensity centroid)</code>，实现也十分简单，就是根据像素值计算图像块的质心<span class="math inline">\((m_{10}, m_{01})\)</span>，质心与几何中心的连线的方向就作为图像块的方向。公式如下：</p>
<figure>
<img src="./imgs/03-intensity_centroid.png" alt="" /><figcaption>灰度质心法计算图像块方向</figcaption>
</figure>
<p>计算出图像的方向后，在计算BRIEF特征描述子的时候，先将区块根据主方向旋转，然后再计算BRIEF特征。但是实现起来会显得很巧妙。<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L245-L250">OpenCV-ORB-旋转操作</a></p>
<h3 id="图像金字塔">图像金字塔</h3>
<p>为了提取出的特征点能够在多个尺度进行匹配，ORB特征提取采用图像金字塔的方式，将原始图像以一定层级缩放，在缩放后的图像后进行特征点提取（角点检测+描述子）。然后将所有特征点坐标放缩回原始分辨率图像坐标。这样得出的特征点就具有了尺度信息。 <a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/features2d/src/orb.cpp#L1128">Opencv-ORB-imagePyramid</a></p>
<h2 id="orb-slam-均匀分布的orb特征点">ORB-SLAM 均匀分布的ORB特征点</h2>
<p>ORB-SLAM中对于图像的特征提取，除了应用ORB特征提取器之外，还额外增加了让特征点尽量在图像中分布均匀的举措。</p>
<p><strong>在ORB-SLAM1中的实现：</strong> 将原始图像平均分成n/5个区块，n是特征点的数量。每个区块进行FAST特征点和rBRIEF描述子计算;特征点数量不足5的区块剩下的特征点平均分到其他区块。其他区块不足以补充的继续将不足的特征点再分到其他区块中，直到所有特征点数量分完。</p>
<p><strong>在ORB-SLAM2及之后的实现：</strong> 采用四叉树的方法，上下左右分割图像块，直到图像块数量等于目标特征点数量或者块中只有一个特征点则停止分割。</p>
<p>下面详解这两种实现</p>
<h3 id="均分切割法orb-slam1中使用">均分切割法（ORB-SLAM1中使用）</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/ORB_SLAM3_ROS2/blob/f18e41de580a2dbbd9bf00a186a53e7a12fb09fe/src/ORB/ORBextractor.cpp#LL1205C6-L1205C39">代码：ORBextractor::ComputeKeyPointsOld</a></p>
<p><strong>算法步骤：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">提前计算好每一层需要的关键点数量（根据图像金字塔放缩比例等比例分配）</span><br><span class="line">同时提前放缩图片计算图像金字塔</span><br><span class="line">对于每一层的图像单独进行特征点提取</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">1. 当前层的特征点数量nDesiredFeatures</span><br><span class="line">2. 当前金字塔层的图像img</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1. 均匀分布的关键点</span><br><span class="line"></span><br><span class="line">算法：</span><br><span class="line">1. 计算图像的长宽比例:imageRatio = img.width / img.height</span><br><span class="line">2. 计算应该切成多少个块</span><br><span class="line">    patchNumCols = sqrt(nDesiredFeatures / (5*imageRatio))</span><br><span class="line">    patchNumRows = imageRatio * patchNumCols</span><br><span class="line">3. 遍历图像块</span><br><span class="line">    3.1 对当前图像块提取FAST角点</span><br><span class="line">    3.2 如果FAST角点数量小于等于3,降低FAST角点阈值，重新提取FAST角点</span><br><span class="line">4. 分配关键点：while（当分配好的关键点总数小于目标数量）</span><br><span class="line">    4.1 根据缺少的关键点数量计算剩余区块每块需要分配多少关键点</span><br><span class="line">    4.2 遍历还有剩余关键点的图像块</span><br><span class="line">        4.2.1 如果该图像块剩余关键点数量小于需要分配的数量，标记该区块不许再次遍历，累计缺少的数量</span><br><span class="line">        4.2.2 如果该图像块剩余关键点数量大于需要分配的数量，不处理</span><br><span class="line">5. 经过第4步之后，计算出了每个图像块需要保留的关键点数量</span><br><span class="line">6. 遍历图像块，对图像块中的关键点分数排序，保留需要的关键点</span><br><span class="line">7. 将关键点坐标（原本是在图像切割的区块计算）还原到图像坐标系</span><br><span class="line">8. 计算关键点的角度（使用灰度质心法）</span><br></pre></td></tr></table></figure>
<h3 id="四叉树分配法orb-slam2及之后使用">四叉树分配法（ORB-SLAM2及之后使用）</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/ORB_SLAM3_ROS2/blob/f18e41de580a2dbbd9bf00a186a53e7a12fb09fe/src/ORB/ORBextractor.cpp#L1028">代码：ORBextractor::ComputeKeyPointsOctTree</a></p>
<p><strong>算法步骤：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">提前计算好每一层需要的关键点数量（根据图像金字塔放缩比例等比例分配）</span><br><span class="line">同时提前放缩图片计算图像金字塔</span><br><span class="line">对于每一层的图像单独进行特征点提取</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">1. 当前层的特征点数量nDesiredFeatures</span><br><span class="line">2. 当前金字塔层的图像img</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1. 均匀分布的关键点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算法步骤：</span><br><span class="line">1. 将图像分割成35x35像素的图像块，并对这些图像块做FAST角点提取</span><br><span class="line">2. 将原始图像从横轴方向分成尽可能正方形的区块。比如横轴和纵轴的比例是2：1则分成两个正方</span><br><span class="line">3. 将第一步提取的FAST角点根据x坐标分到第二步的区块中</span><br><span class="line">4. 将根节点（也就是第2步分割出来的区块）放入节点列表中</span><br><span class="line">5. 遍历节点列表</span><br><span class="line">    5.1 如果这个节点只剩下一个关键点，则停止分裂</span><br><span class="line">    5.2 如果总共的区块数已经达到要求的关键点数量，则停止分裂</span><br><span class="line">    5.3 将当前节点分裂成上下左右四个区域</span><br><span class="line">    5.4 如果分裂出的区块不包含关键点，则抛弃，否则放入节点列表中</span><br><span class="line">    5.5 从节点列表中删除当前节点</span><br><span class="line">6. 遍历节点列表，保留响应值最大的一个关键点</span><br><span class="line">7. 将关键点的坐标还原到图像坐标系</span><br><span class="line">8. 计算所有关键点的方向</span><br></pre></td></tr></table></figure>
<h3 id="实现中的一些细节">实现中的一些细节</h3>
<p>在这部分的实现中，有用到一些trick，这里顺便做一下记录：</p>
<ol type="1">
<li>四叉树分裂的过程并没有使用递归的方式实现，用递归的方式实现看起来代码可能简单很多，但是用for循环可能在效率上更快</li>
<li>在分裂的过程中会判断下一次分裂后节点的数量是否可能会大于目标特征点数量，如果会的话会进入另一个循环。但是仔细看实现后，感觉这部分逻辑是可以简化的。</li>
<li>实际实现并没有上面算法过程看起来这么“干净”。为了确保算出来的特征点可以计算出特征（rBRIEF特征需要在关键点周围扩展出31像素的正方形），需要在原始图像往内收缩一定的像素，在收缩后的区域进行关键点提取。同时，FAST角点需要在像素周围扩展3个像素，所以又需要往外扩展3个像素，确保能够正确计算FAST角点。这些内容细节单纯靠论文或者讲解是很难体会到的，只有亲自看一遍代码才知道这里面的奥妙。</li>
</ol>
<h2 id="完整代码">完整代码</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/ORB_SLAM3_ROS2/blob/main/src/ORB/ORBextractor.cpp">ORB_SLAM3_ROS2-ORBextractor</a></p>
<p><strong>默认参数：</strong></p>
<ol type="1">
<li>特征点数量：1000</li>
<li>图像金字塔层数：8</li>
<li>每层的缩放系数：1.2</li>
<li>ORB特征Patch大小：31（与原始ORB一致）</li>
<li>ORB特征计算的点对选取：与OpenCV实现相同（提前选定的固定的点对序列）</li>
</ol>
<h2 id="附录a决策树">附录A——决策树</h2>
<div id="appendA">

</div>
<p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ID3_algorithm">维基百科-ID3决策树</a></p>
<figure>
<img src="./imgs/A-01-decisiontree.png" alt="" /><figcaption>决策树</figcaption>
</figure>
<p>决策树（Decision Tree）在传统机器学习中是一种常见的分类方法。决策树是一种监督学习方法，需要在数据集上训练。 决策树构建一个树状结构用来分类。决策树中包含一个根节点、若干个内部节点和若干个叶节点</p>
<ul>
<li>每个内部节点表示对某一个属性进行判断分类。每个内部节点产生的分支数量是这个属性的可能取值的数量</li>
<li>每个叶节点代表一种分类结果</li>
</ul>
<p>在训练时，用数据集决定每一个内部节点应该采用哪一个属性进行分支，直到产生的节点里面的数据都是同一种类。</p>
<p>在预测时，根据训练好的决策树，对输入的样本按照决策树的顺序，根据属性进行分类，直到叶子节点。每个叶子节点对应一种 分类结果，走到叶子节点也就意味着成功进行分类。</p>
<h3 id="特征选择">特征选择</h3>
<p>如何在每一步决定要用哪个特征进行判断是决策树算法中难点。不同的算法会使用不同的策略根据训练集选择特征。这里主要介绍<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ID3_algorithm">ID3算法</a>, 这也是<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d0c/tutorial_py_fast.html">FAST</a>中使用的决策树算法。</p>
<h3 id="熵entropy">熵（Entropy）</h3>
<p>熵表示不确定性，也是信息量的大小。熵大代表不确定性高，信息量也大。</p>
<p>对于数据集<span class="math inline">\(S\)</span>，熵的定义如下：</p>
<p><span class="math display">\[
H(S) = - \sum_{x \in X}p(x)log_2p(x)\tag{A-1}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(S\)</span>指数据集;在ID3迭代构建决策树的时候，S指的是当前的节点分配到的数据</li>
<li><span class="math inline">\(X\)</span>指总共的类别数量</li>
<li><span class="math inline">\(p(x)\)</span>指类别<span class="math inline">\(x\)</span>占<span class="math inline">\(S\)</span>总数的比例（概率）</li>
</ul>
<h3 id="信息增益information-gain">信息增益（Information gain）</h3>
<p>选择特征的时候，我们希望选择的特征能够最好地划分数据集，也就是带来最多的信息增益。 信息增益<span class="math inline">\(IG(A)\)</span>表示使用属性<span class="math inline">\(A\)</span>对数据集<span class="math inline">\(S\)</span>进行划分前后熵的减少量。也就是使用属性<span class="math inline">\(A\)</span>对数据集进行划分时，有 多少不确定性减少了。</p>
<p><span class="math display">\[
IG(S,A) = H(S) - \sum_{t\in T}p(t)H(t) = H(S) - H(S|A)\tag{A-2}
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(T\)</span> 指由属性<span class="math inline">\(A\)</span>将集合<span class="math inline">\(S\)</span>划分成多少个集合，也就是属性<span class="math inline">\(A\)</span>的可能取值数量。<span class="math inline">\(S = \cup_{t\in T}t\)</span></li>
<li><span class="math inline">\(p(t)\)</span>指子集<span class="math inline">\(t\)</span>占<span class="math inline">\(S\)</span>的比例</li>
<li><span class="math inline">\(H(t)\)</span>指子集<span class="math inline">\(t\)</span>的熵，计算方式与公式(A-1)一样</li>
</ul>
<p><strong>PS: 要区分数据集的类别<span class="math inline">\(X\)</span>和根据属性划分的集合<span class="math inline">\(T\)</span>；数据集的类别是我们要将每个样本打上的标签，无论是哪个子集，类别数都是一样的。 但是不同的属性可能有不同的可能取值数量，比如属性<span class="math inline">\(A\)</span>可能取值<span class="math inline">\(1,2,3\)</span>，那么就会划分出三个不同的子集;属性<span class="math inline">\(B\)</span>可能取值<span class="math inline">\(0,1\)</span>，那么就会 划分出两个子集</strong></p>
<h3 id="伪代码id3算法">伪代码（ID3算法）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createID3Tree</span>(<span class="params">dataSet, attributeIndices</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建决策树</span></span><br><span class="line"><span class="string">    @input dataset NxM的矩阵，N是样本的数量，每一列的最后一位是样本的类别出，属性数量共有M-1个</span></span><br><span class="line"><span class="string">    @attributeIndices (M-1,1) 保存当前的数据集中的属性在原始属性中的索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    如果dataset中所有的数据属于同一个类别，当前节点的类别就是数据中的类别，直接返回；</span><br><span class="line"></span><br><span class="line">    如果attributeIndices中已经没有属性，也就是遍历完所有属性，选择数据集中占主要的类别作为当前节点类别，返回；</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历属性列表，根据信息增益选择信息增益最大的属性 -----------------------------------</span></span><br><span class="line">    计算数据集的熵H(S)</span><br><span class="line">    bestInfoGain = <span class="number">0</span></span><br><span class="line">    bestFeatAttrIdx = -<span class="number">1</span>    <span class="comment"># 最有的属性索引</span></span><br><span class="line">    <span class="keyword">for</span> attributeIdx <span class="keyword">in</span> attributeIndices:</span><br><span class="line">        featList = [sample[attributeIdx] <span class="keyword">for</span> sample <span class="keyword">in</span> dataSet]</span><br><span class="line">        featValSet = <span class="built_in">set</span>(featList)  <span class="comment"># 获取属性的所有可能取值</span></span><br><span class="line">        newEntropy = <span class="number">0</span>  <span class="comment"># 计算在当前属性的划分下的信息熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> featValSet:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, attributeIdx, value) <span class="comment"># 获取数据集的当前属性等于value的子集</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">len</span>(dataSet)   <span class="comment"># 子集占据数据集的比例</span></span><br><span class="line">            newEntropy += prob * H(subDataSet)      <span class="comment"># 公式（A-2)</span></span><br><span class="line">        infoGain = H(S) - newEntropy</span><br><span class="line">        <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeatAttrIdx = attributeIdx</span><br><span class="line">    <span class="comment"># bestFeatAttrIdx 是选择出的用来当前节点做切分的属性索引 ---------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用最有的属性切分数据集</span></span><br><span class="line">    subTree = &#123;bestFeatAttrIdx:&#123;&#125;&#125;</span><br><span class="line">    从attributeIndices中删除掉bestFeatAttrIdx</span><br><span class="line">    featValSet = 当前属性的所有可能取值</span><br><span class="line">    <span class="comment"># 递归计算决策树</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> featValSet:</span><br><span class="line">        subTree[bestFeatAttrIdx][value] = createID3Tree(splitDataSet(dataSet, bestFeatAttrIdx, value), attributeIndices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subTree</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/19/sensors/AllanVariance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/19/sensors/AllanVariance/" class="post-title-link" itemprop="url">惯性测量单元Allan方差分析详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-19 15:37:57" itemprop="dateCreated datePublished" datetime="2023-04-19T15:37:57+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-18 16:49:48" itemprop="dateModified" datetime="2023-05-18T16:49:48+08:00">2023-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/" itemprop="url" rel="index"><span itemprop="name">传感器标定</span></a>
        </span>
    </span>

  
    <span id="/2023/04/19/sensors/AllanVariance/" class="post-meta-item leancloud_visitors" data-flag-title="惯性测量单元Allan方差分析详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="惯性测量单元Allan方差分析详解" href="/2023/04/19/sensors/AllanVariance/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::aa4c05f956521692fdd7a55fc75da757" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up?tab=repositories">Zeal's Github</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>原本以为Allan方差应该是一个简单的方差计算方法，但是经过两天的各种探索和资料学习，发现这玩意的原理远比想象中的复杂。详细的公式推导需要设计到随机信号的频谱分析、IMU各种误差模型等内容。并且，Allan方差一开始用来分析原子钟晶体振荡频率的误差分析，后续这种分析方法被用到IMU的误差分析，并且IEEE也制订了相应标准（见<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">参考资料1</a>），这一系列的发展过程其实很长，同时也有不同的定义。以上种种，让读者放弃了摸清Allan方差的详细来龙去脉和公式推导，毕竟，工程师和数学家还是有区别的……但是关于Allan方差的解释和应用网上的博文也都不够全面，单看某一篇文章很难获取对Allan方差的直观理解（没有找到一篇很好的文章能够说明Allan方差的定义和双对数曲线不同斜率段对应的噪声项是怎么来的）。</p>
<p>本文对以下内容做了梳理：</p>
<ol type="1">
<li>IMU的噪声项及其含义</li>
<li>Allan方差的定义和推导</li>
<li>对陀螺仪的数据计算Allan方差的方法</li>
<li>Allan方差双对数曲线的含义和分析</li>
<li>关键概念解读</li>
</ol>
<p><code>PS: 笔者水平有限，本文只是笔者对Allan方差学习的总结，并不是一篇严格的理论推导文章</code></p>
<h2 id="惯性测量单元imuinertial-measuremnt-unit误差项">惯性测量单元（IMU：Inertial Measuremnt Unit）误差项</h2>
<p>这部分可以参考<a target="_blank" rel="noopener" href="https://hexagondownloads.blob.core.windows.net/public/Novatel/assets/Documents/Bulletins/APN064/APN064.pdf">参考资料2</a></p>
<img src="./imgs/01-imu-axis.png" title="fig:" alt="IMU模型" />
<center>
IMU模型
</center>
<p>IMU的输出可以看上图，典型的六轴IMU输出三个轴的加速度和三个轴的角速度。对加速度做积分可以得到速度、再做一次积分可以得到位移；对角速度积分可以得到角度。</p>
<p>电子器件输出都会有误差，又叫噪声。IMU的噪声项主要有以下几种：</p>
<img src="./imgs/02-imu-errors.png" alt="IMU误差示意图" /> <cneter>IMU误差示意图
</center>
<ol type="1">
<li>零偏（Bias），单位<code>deg/hr,m/s^2</code> 零偏这个词似乎不太准确，因为在非零输出时也会有偏差。如果把IMU的输出当作一个遵循高斯分布的随机信号，在静止时该随机信号的均值应该是零，但是由于bias，该均值并不是0。见上面的<code>IMU误差示意图</code>可以较好地理解。要注意的是零偏是会随着时间改变的，因此在很多卡尔曼滤波模型中会把Bias当作一个状态量。</li>
<li>零偏可重复性（Bias Repeatability），单位<code>deg/hr,m/s^2</code> 每次上电零偏的稳定程度。</li>
<li>零偏稳定性（Bias Stability），单位<code>deg/hr/hr,m/s^2/hr</code> 有时也叫零偏不稳定性（Bias Instability）。描述零偏的稳定程度，也可以理解为零偏的噪声。（有些文章也会叫做零偏的角度随机游走）。</li>
<li>比例因子（Scale Factor） 比如比例因子是1.2,那么当真值是10m/s<sup>2的时候，IMU的输出可能是12m/s</sup>2。</li>
<li>角度随机游走（ARW:Angle Random Walk），单位：<span class="math inline">\(deg/\sqrt{hr}\)</span>,<span class="math inline">\(m/s/\sqrt{hr}\)</span> 这是一个比较难理解的量，实际上笔者也没法完全理解。简单理解就是当信号叠加上一个白噪声之后，对该信号的积分就包含了白噪声的积分，白噪声的积分不再是一个白噪声，而是一个马尔科夫模型，也就是此时的噪声是上一时刻的噪声加上一个白噪声。那么放在这里，对于陀螺仪的输出（角速度）一般是用来做积分得到角度，那么角速度的白噪声的积分就会得到角度的偏差，因此叫做角度随机游走。有时候角度随机游走的值又叫做白噪声强度，比如在<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a>中就有这样的描述： &gt; White Noise Terms: The parameters for the "white noise" processes are often specified in the datasheet of the sensor manufacturer. A bit misleading, they are commonly denoted as angular random walk in case of the gyro, and velocity random walk for the accel</li>
<li>速率随机游走（RRW:Rate Random Walk） 与角度随机游走类似，速率随机游走可以看作是角加速度的误差积分导致的角速度的误差。速率随机游走对应的是陀螺仪在长时间下才会发生改变的误差项，因此可以用来近似当作<code>Bias</code>使用。在<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a>中使用速率随机游走系数当作零偏参数。</li>
</ol>
<h3 id="角度随机游走arwangle-random-walkv.s.-角速率随机游走arrw">角度随机游走（ARW:Angle Random Walk）v.s. 角速率随机游走（ARRW）</h3>
<p>这个很容易弄混淆的一个概念。对应到加速度计上应该叫速度随机游走和加速度随机游走。因为讲解Allan方差的时候一般会以陀螺仪为示例，因此在文中可能只出现角度随机游走和角速率随机游走。角速率随机游走又会被简写成速率随机游走，比如参考资料1的IEEE标准。下面这段百度百科的描述反而清晰： &gt; 角速率传感器的性能参数中包含角度随机游走（ARW）和角速率随机游走（ARRW），前者反映了角速率信号中白噪声的特性，积分后表现为角度随机游走；后者为角速率本身的随机游走，可认为是角加速度白噪声的积分结果。</p>
<h2 id="allan方差">Allan方差</h2>
<p>Allan方差又叫阿伦方差，可以用Allan方差用来描述物理器件的不同噪声参数。Allan方差相比于普通的方差具有更好的描述长时间误差的优势（具体也不太清楚）。Allan方差现在好像基本被用来当作IMU噪声标定的标准方法了。</p>
<h3 id="数据方差">数据方差</h3>
<figure>
<img src="./imgs/03-variance.png" alt="" /><figcaption>数据方差及标准差计算方法</figcaption>
</figure>
<p>（上图引用自<a target="_blank" rel="noopener" href="http://www.i2nav.com/index/newListDetail_zw?newskind_id=13a8654e060c40c69e5f3d4c13069078&amp;newsinfo_id=c2bb31af75944e5ab665dc23b60b5fba">新手入门系列3——Allan方差分析方法的直观理解</a>）</p>
<p>系数<span class="math inline">\(\frac{1}{N-1}\)</span>使得这样计算出来的方差是数据方差的无偏估计（概率统计原理）。</p>
<h3 id="对不同时间尺度上的误差刻画">对不同时间尺度上的误差刻画</h3>
<p>上面的数据方差计算方法对数据的整个序列计算误差水平，无法细分出不同时间尺度上的误差波动情况。为了能够刻画不同时间周期下数据的波动情况，我们可以先对数据分块，对每块数据取平均作为该块数据的代表。假设原始数据的采样时间是<span class="math inline">\(\tau_0\)</span>，每3个数据分成一块，则每块的间隔时间<span class="math inline">\(\tau = 3\tau_0\)</span>。分块之后，我们再将<span class="math inline">\(M\)</span>个数据块计算方差，最后求这个方差的数学期望，作为我们最后的方差</p>
<figure>
<img src="./imgs/04-general-covariance.png" alt="" /><figcaption>通用样本方差计算方法</figcaption>
</figure>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2_{g}(M,\tau)
&amp;=&amp;
&lt;\sigma^2(M,\tau)&gt;\\
&amp;=&amp;
&lt;\frac{1}{M-1}\sum^M_{i=1}\big(\bar{y}_i-\frac{1}{M}\sum^M_{j=1}\bar{y}_j\big)^2&gt;\\
\end{array}
\end{split}\tag{1}
\]</span></p>
<p>上式中<span class="math inline">\(&lt;\cdot&gt;\)</span>表示求统计平均（期望）</p>
<h3 id="allan方差定义">Allan方差定义</h3>
<p>Allan方差是上述通用样本方差分析在<span class="math inline">\(M=2\)</span>时的一个特例，也就是在公式（1）中令<span class="math inline">\(M=2\)</span></p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2(\tau)
&amp;=&amp;
&lt;\sigma^2(2,\tau)&gt;\\
&amp;=&amp;
&lt;\sum^2_{i=1}\big(\bar{y}_i-\frac{1}{2}\sum^2_{j=1}\bar{y}_j\big)^2&gt;\\
&amp;=&amp;
&lt;\frac{1}{2}(\bar{y}_2-\bar{y}_1)^2&gt;\\
&amp;=&amp;
\frac{1}{2}&lt;(\bar{y}_2-\bar{y}_1)^2&gt;
\end{array}
\end{split}\tag{2}
\]</span></p>
<p>注意，Allan方差是<span class="math inline">\(\tau\)</span>的函数</p>
<figure>
<img src="./imgs/05-allan-covariance.png" alt="" /><figcaption>Allan方差定义</figcaption>
</figure>
<h3 id="角速度的allan方差计算">角速度的Allan方差计算</h3>
<p>这里只推导一种方式，根据<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">IEEE Standard</a></p>
<p>令陀螺仪的角度输出为<span class="math inline">\(\Omega(t^\prime)\)</span>，则角度为</p>
<p><span class="math display">\[
\theta(t)=\int^t\Omega(t^\prime)dt^\prime
\]</span></p>
<p>对于离散时间形式，时间点<span class="math inline">\(t=k\tau_0,k=1,2,3,...,N\)</span>。其中<span class="math inline">\(\tau_0\)</span>是陀螺仪的输出时间间隔，<span class="math inline">\(N\)</span>为总体样本数量。则，在时间段<span class="math inline">\(t_k\)</span>到<span class="math inline">\(t_k+\tau\)</span>之间，角速度的平均值是：</p>
<p><span class="math display">\[
\bar{\Omega}_k(\tau)=\frac{\theta_{k+m}-\theta_k}{\tau}\tag{3}
\]</span></p>
<p>其中<span class="math inline">\(\tau=m\tau_0\)</span></p>
<p>将公式（3）带入上文Allan方差的定义公式（2）中可以得到：</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2(\tau)
&amp;=&amp;
\frac{1}{2}&lt;(\bar{\Omega }_{k+m}-\bar{\Omega }_k)^2&gt;\\
&amp;=&amp;
\frac{1}{2\tau^2}&lt;(\theta_{k+2m}-2\theta_{k+m}+\theta_k)^2&gt;
\end{array}
\end{split}\tag{4}
\]</span></p>
<p>将公式（4）的期望代替为在整个数据样本（数量为N）上求平均，可以得到如下形式</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\sigma^2(\tau)
&amp;=&amp;
\frac{1}{2\tau^2(N-2m)}\sum^{N-2m}_{k=1}(\theta_{k+2m}-2\theta_{k+m}+\theta_k)^2
\end{array}
\end{split}\tag{5}
\]</span></p>
<h3 id="重叠分段法计算allan方差">重叠分段法计算Allan方差</h3>
<p>这部分主要参考：<a target="_blank" rel="noopener" href="https://telesens.co/wp-content/uploads/2017/05/AllanVariance5087-1.pdf">Allan Variance: Noise Analysis for Gyroscopes</a> 在公式（5）中，对每<span class="math inline">\(m\)</span>个原始数据作为一段。切割方式有很多种，在图<code>Allan方差定义</code>中，每段数据都不重叠。另一种分割方法是让每段数据都重叠，如下图所示</p>
<figure>
<img src="./imgs/06-overlapping-sample.png" alt="" /><figcaption>重叠采样计算Allan方差</figcaption>
</figure>
<p>上图中<span class="math inline">\(m=3\)</span>，也就是每4个原始数据作为一组，组与组之前相差<span class="math inline">\(\tau_0\)</span>长度。</p>
<p>Allan方差的计算方式与公式（5）保持一致。</p>
<h2 id="allan方差双对数曲线">Allan方差双对数曲线</h2>
<p>根据公式（5），Allan方差是时间周期<span class="math inline">\(\tau=m\tau_0\)</span>的函数，我们根据不同的<span class="math inline">\(\tau\)</span>，计算出对应的Allan方差，并将<span class="math inline">\(log_{10}(\tau)\)</span>作为x，<span class="math inline">\(log_{10}(\sigma(\tau))\)</span>作为y，画出曲线，如下图：</p>
<figure>
<img src="./imgs/07-allan-log-curve.png" alt="" /><figcaption>Allan方差双对数曲线</figcaption>
</figure>
<p>注意，y轴是Allan方差的开根，又叫Allan</p>
<p>Allan方差双对数曲线可以用不同斜率的直线拟合，不同斜率部分的直线代表不同的含义。</p>
<p>这里讲述一下如何从双对数曲线分析信号的不同误差成分（以陀螺仪为例）</p>
<h3 id="角度随机游走白噪声强度">角度随机游走/白噪声强度</h3>
<p>角度随机游走对应到双对数曲线中斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的直线，取值可以直接读取<span class="math inline">\(\tau=1\)</span>处的值。</p>
<h3 id="零偏不稳定性">零偏不稳定性</h3>
<p>零偏不稳定性对应双对数曲线中斜率为0的直线，也就是双对数曲线中最小值位置。</p>
<h3 id="速率随机游走">速率随机游走</h3>
<p>速率随机游走对应双对数曲线中斜率为<span class="math inline">\(\frac{1}{2}\)</span>的直线，取值时取该直线与<span class="math inline">\(\tau=3\)</span>的交点。</p>
<p>上面三个误差项是我们用得比较多的误差项，画成图如下：</p>
<figure>
<img src="./imgs/08-display-of-errors-in-curve.png" alt="" /><figcaption>三种误差项在双对数曲线中的示意图</figcaption>
</figure>
<h3 id="为什么不同的斜率对应不同的误差项">为什么不同的斜率对应不同的误差项？？</h3>
<p>说实话，笔者对这个部分也是一知半解，说实话，也没有必要完全弄明白，里面涉及到时域信号分析太多基础知识了。这里根据<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">IEEE Standard</a>里一些内容根据自己的理解简单讲述一下。 噪声的双边功率谱密度(PSD:Power Sepctral Density)与Allan方差有如下关系：</p>
<figure>
<img src="./imgs/09-psd-2-allan.png" alt="" /><figcaption>功率谱密度与Allan方差的关系</figcaption>
</figure>
<p>上式中可以看作Allan方差是噪声能量经过一个<span class="math inline">\(sin^4(x)/(x)^2\)</span>为转移函数的滤波器，这个函数是由Allan方差计算决定的。这个滤波器的带宽跟<span class="math inline">\(\tau\)</span>有关，因此，不同的<span class="math inline">\(\tau\)</span>对应的Allan方差来分析噪声的不同频段特性。</p>
<p>以白噪声为例，其功率谱密度为</p>
<figure>
<img src="./imgs/10-white-noise-psd.png" alt="" /><figcaption>白噪声PSD</figcaption>
</figure>
<p>将其带入<code>功率谱密度与Allan方差关系</code>的公式中，并进行公式中的积分，可以得到如下结果:</p>
<figure>
<img src="./imgs/11-white-noise-psd-integrated.png" alt="" /><figcaption>白噪声PSD转换成Allan方差</figcaption>
</figure>
<p>对上式 <span class="math inline">\(\sigma^2\big(\tau\big)=\frac{N^2}{\tau}\)</span> 开根后求对数后可以得到</p>
<p><span class="math display">\[
log(\sigma(\tau)) = N - \frac{1}{2}log(\tau)
\]</span></p>
<p>刚好可以得到一条斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的直线，且当<span class="math inline">\(\tau=1\)</span>的时候可以得到<span class="math inline">\(N\)</span>。这也对应了上文中从Allan方差双对数曲线中求角度随机游走的方式。</p>
<h2 id="应用重点">应用重点</h2>
<h3 id="不同的imu建模方式需要不同的系数">不同的IMU建模方式需要不同的系数</h3>
<p>强调这一点是因为<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a>工具标定的输出结果和<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr">kalibr</a>的模型要求是不一样的。</p>
<p><strong>在GTSAM中</strong></p>
<p>在GTSAM中使用IMUFactor时需要IMU的几个参数：</p>
<ol type="1">
<li>IMU零偏Bias的初始值。但是这个参数可以先设置为0,后续逐步更新。（Bias是IMUFactor中的一个变量，会随时间改变）。</li>
<li>IMU加速度（3轴）和陀螺仪（3轴）的噪声参数。</li>
<li>IMU加速度（3轴）和陀螺仪（3轴）的Bias噪声参数。</li>
</ol>
<p>上面2、3两点的参数可以使用<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a>的标定结果。</p>
<p>其中第2点对应的是Allan方差双对数曲线（后文详细讲解）中斜率为<code>-1/2</code>的直线与 <span class="math inline">\(\tau =1s\)</span>的交点（IEEE标准）。（可以直接取双对数曲线 <span class="math inline">\(\tau = 1s\)</span>处的值，因为"据说"惯性单元在1Hz的时候对应的噪声强度主要由白噪声强度左右。这段话出自<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a>，<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a>也是直接取这一点的值） &gt;This is only true since the noise power in most inertial sensors is dominated by "white noise" at a frequency of approximately 1Hz.</p>
<p>第3点描述的是Bias的不稳定性，有些地方也叫Bias随机游走。这个参数对应的是<code>Bias [In]Stability</code>。Bias Stability可以直接从Allan方差双对数曲线中读出来（后文详解）</p>
<p>之所以GTSAM需要这些参数是因为GTSAM中对IMU的建模方法跟大部分算法相同，都是把IMU的Bias当作状态，认为Bias会随着时间变化而缓慢改变（这也是较为正确的做法）。因此需要标定出Bias的稳定性。</p>
<p><strong>在[kalibr]中</strong> 在[kalibr]中对IMU的建模是使用下面的公式：</p>
<p><span class="math display">\[\tilde{w}(t) = w(t)+b(t)+n(t)\]</span></p>
<p>其中<span class="math inline">\(w(t)\)</span>代表真值，<span class="math inline">\(b(t)\)</span>是Bias，<span class="math inline">\(n(t)\)</span>是噪声。因此在[kalibr]中使用角度随机游走系数作为<span class="math inline">\(n(t)\)</span>。同时使用角速率随机游走作为<span class="math inline">\(b(t)\)</span>。一开始对这点很迷惑，为什么角速率随机游走可以用来作为<span class="math inline">\(b(t)\)</span>。后面我在一个issue的回答中得到答案：<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/issues/63">issues63</a>。[kalibr]对IMU的建模形式实际上是不够准确的，因为这里将<span class="math inline">\(b(t)\)</span>当作一个恒定的量求解，实际上这是一个随着时间缓慢变化的量。而角速率随机游走则可以部分用力刻画这一偏差。<code>事实上还是很难理解</code></p>
<h3 id="单位">单位</h3>
<blockquote>
<p>First, it is important to realize that Hertz (Hz) is defined as the inverse of seconds, which means that a noise density specification of X°/s/√Hz is exactly equivalent to an angle random walk specification of X°/√s with no conversion necessary. 出自：https://www.vectornav.com/resources/inertial-navigation-primer/specifications--and--error-budgets/specs-imuspecs</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<p>【1】<a target="_blank" rel="noopener" href="http://www.i2nav.com/ueditor/jsp/upload/file/20211008/1633700373874080110.pdf">IEEE Standard Specification Format Guide and Test Procedure for Single-Axis Laser Gyros, AnnexC, IEEE Std 647-1995, 1995</a></p>
<p>【2】<a target="_blank" rel="noopener" href="https://hexagondownloads.blob.core.windows.net/public/Novatel/assets/Documents/Bulletins/APN064/APN064.pdf">IMU Errors and Their Effects</a></p>
<p>【3】<a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">kalibr:IMU-Noise-Model</a></p>
<p>【4】<a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">imu_utils</a></p>
<p>【5】<a target="_blank" rel="noopener" href="http://www.i2nav.com/index/newListDetail_zw?newskind_id=13a8654e060c40c69e5f3d4c13069078&amp;newsinfo_id=c2bb31af75944e5ab665dc23b60b5fba">新手入门系列3——Allan方差分析方法的直观理解</a></p>
<p>【6】<a target="_blank" rel="noopener" href="https://telesens.co/wp-content/uploads/2017/05/AllanVariance5087-1.pdf">Allan Variance: Noise Analysis for Gyroscopes</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/lio_sam/mapOptimization-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（十）后端优化模块详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 22:00:19" itemprop="dateCreated datePublished" datetime="2023-04-11T22:00:19+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 22:08:03" itemprop="dateModified" datetime="2023-04-20T22:08:03+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/04/11/lio_sam/mapOptimization-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（十）后端优化模块详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（十）后端优化模块详解" href="/2023/04/11/lio_sam/mapOptimization-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::fddca820098456617fc64b80ba797a81" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="后端优化">后端优化</h2>
<figure>
<img src="./imgs/Design-Pipelines-mapOpt.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p>这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>四大部分（点云去畸变、特征提取、预积分、后端优化）中最复杂的一个模块了，完全弄懂这个模块也就离完全理解<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>不远了。 这个模块负责SLAM框架中的后端优化，由于<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中使用图优化作为后端优化算法，所以有时候笔者也会称这个模块为图优化模块。但是这个模块的 作用不单单是负责后端优化，还有1）、全局地图可视化；2）、回环检测等功能。</p>
<p>这个模块一共有三个主要线程执行具体功能，三个线程分别如下：</p>
<ol type="1">
<li>雷达里程计及后端优化线程</li>
</ol>
<p>这个线程主要负责执行雷达到地图的匹配，得到较为准确的雷达里程计，然后将雷达里程计、回环检测因子加入因子图进行优化，得到全局优化的关键帧位姿。</p>
<ol start="2" type="1">
<li>回环检测线程</li>
</ol>
<p>回环检测使用较为费时的ICP算法，因此作为一个单独的线程运行。当检测到合适的回环因子后，会加入全局缓存队列，在雷达里程计线程中被加入因子图优化。</p>
<ol start="3" type="1">
<li>全局地图可视化线程</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中对于地图的存储格式是通过一系列关键帧的点云和位姿存储，而不是通过一整个点云存储。为了能够以较低的频率发布全局地图，后端优化模块单独有一个线程 对历史关键帧的点云根据最新的位姿转换到地图坐标系，然后将融合后的全局点云地图发布出去。</p>
<p>废话不多说，下面分别介绍这三个线程的主要流程和方法</p>
<h2 id="雷达里程计及后端优化线程">雷达里程计及后端优化线程</h2>
<p>这个线程的流程主要如下图所示</p>
<figure>
<img src="./imgs/Design-mapOptimization-top.png" alt="" /><figcaption>雷达里程计及后端优化线程流程图</figcaption>
</figure>
<p>这个线程是点云的回调函数，点云来自<code>FeatureExtraction</code>模块输出的经过特征提取后的点云。整个函数执行过程代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特征点云回调函数，也是整个模块核心的计算函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 提取当前点云时间戳</span></span><br><span class="line">    timeLaserInfoStamp = msgIn-&gt;header.stamp;</span><br><span class="line">    timeLaserInfoCur = <span class="built_in">stamp2Sec</span>(msgIn-&gt;header.stamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取当前点云的特征角点和特征平面点</span></span><br><span class="line">    cloudInfo = *msgIn;</span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_corner,  *laserCloudCornerCur);</span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_surface, *laserCloudSurfCur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 一共三个线程使用到这把锁</span></span><br><span class="line"><span class="comment">        * 1. 雷达里程计线程，也就是当前线程</span></span><br><span class="line"><span class="comment">        * 2. 发布全局地图线程，执行关键帧点云拷贝转换操作</span></span><br><span class="line"><span class="comment">        * 3. 回环检测线程，执行关键帧姿态拷贝操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一帧的时间戳，两帧之间时间间隔大于mappingProcessInterval才会进行处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> timeLastProcessing = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)</span><br><span class="line">    &#123;</span><br><span class="line">        timeLastProcessing = timeLaserInfoCur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前帧位姿初始化</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;updateInitialGuess&quot;</span>);</span><br><span class="line">        <span class="built_in">updateInitialGuess</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建局部地图</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;extractSurroundingKeyFrames&quot;</span>);</span><br><span class="line">        <span class="built_in">extractSurroundingKeyFrames</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对当前帧点云做降采样</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;downsampleCurrentScan&quot;</span>);</span><br><span class="line">        <span class="built_in">downsampleCurrentScan</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前帧点云匹配到构建的局部地图，优化当前位姿</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;scan2MapOptimization&quot;</span>);</span><br><span class="line">        <span class="built_in">scan2MapOptimization</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算是否将当前帧采纳为关键帧，加入因子图优化</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;saveKeyFramesAndFactor&quot;</span>);</span><br><span class="line">        <span class="built_in">saveKeyFramesAndFactor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当新的回环因子或者GPS因子加入因子图时，对历史帧执行位姿更新</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;correctPoses&quot;</span>);</span><br><span class="line">        <span class="built_in">correctPoses</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布激光历程计</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;publishOdometry&quot;</span>);</span><br><span class="line">        <span class="built_in">publishOdometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布当前帧对齐到地图坐标系的点云和完整轨迹</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;publishFrames&quot;</span>);</span><br><span class="line">        <span class="built_in">publishFrames</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="雷达里程计的最高频率">雷达里程计的最高频率</h3>
<p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)</span><br></pre></td></tr></table></figure>
<p><code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1/0.15Hz</p>
<h3 id="点云匹配的初始值">点云匹配的初始值</h3>
<p>基本所有的精细点云匹配都需要一个较好的初值。<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中的点云匹配使用高斯牛顿算法优化当前帧点云到局部地图的距离（具体算法见本项目博客的相关文章），基于最小二乘法的点云匹配更需要一个优良的初值。 回顾一下我们在<code>ImageProjection</code>也就是点云去畸变模块的内容，在点云去畸变模块，除了对点云做运动畸变校正之外，还从IMU原始输出的角度和预积分模块的输出找到与当前帧点云时间最相近的数据，加入发布的消息中跟随点云一起发布。</p>
<p>在后端优化模块中，会优先判断接收的消息中是否有设置好的预积分数据，若有，则使用该数据作为该帧点云的初始值，否则，使用IMU的角度增量作为初始值。当然，特殊情况是第一帧的时候会使用IMU输出的角度作为初始值。</p>
<figure>
<img src="./imgs/Design-mapOptimization-initialGuess.png" alt="" /><figcaption>点云匹配初始值选取</figcaption>
</figure>
<p>这里比较特殊的是，初始值是通过计算当前帧的位姿和上一帧的缓存位姿计算位姿增量，然后将该增量应用到上一帧优化后的里程计结果。</p>
<p><span class="math display">\[
T_{incre} = \hat{T}_{pre}^{-1}\hat{T}_{cur}\\
\bar{T}_{cur} = T^{opt}_{pre}T_{incre}
\]</span></p>
<p>以使用预积分数据作为初始值为例，上面公式中的<span class="math inline">\(\hat{T}_{pre},\hat{T}_{cur}\)</span>分别是上一次缓存和当前的消息中包含的预积分位姿；<span class="math inline">\(T_{incre}\)</span>计算除了从上一帧到当前帧的位姿增量；<span class="math inline">\(T^{opt}_{pre}\)</span>是上一帧经过点云匹配、图优化之后的里程计结果；<span class="math inline">\(\bar{T}_{cur}\)</span>则是最终采用的当前帧点云的估计值。</p>
<h3 id="构建局部点云地图">构建局部点云地图</h3>
<figure>
<img src="./imgs/Design-mapOptimization-localMap.png" alt="" /><figcaption>构建局部点云地图</figcaption>
</figure>
<p>局部点云地图简单说就是根据最后一帧关键帧，找到其空间、时间附近的一些其他关键帧，将这些关键帧的点云都使用对应的位姿转换到地图坐标系下，融合成地图坐标系下的局部地图，后面这个局部地图就是点云匹配的目标点云。这个函数主要是一些几何计算。</p>
<h3 id="点云匹配">点云匹配</h3>
<p>这部分用的算法比较复杂，具体参考本项目的另一篇文章<a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——点云匹配算法详解</a>。 只要明白，经过这个步骤后，在第一步设置的点云位姿初始值已经被点云匹配算法更新为更准确的位姿。</p>
<figure>
<img src="./imgs/Design-mapOptimization-scan2Map.png" alt="" /><figcaption>点云匹配</figcaption>
</figure>
<h3 id="因子图构建及优化">因子图构建及优化</h3>
<p>这个步骤稍微比较复杂，我们先理一下目前手头有什么：</p>
<ol type="1">
<li>经过点云匹配校正后的当前帧的位姿</li>
<li>回环检测得到的某一帧关键帧到另一帧关键帧的相对位姿（这个部分在回环检测线程进行，这里只需要当作现有数据即可）</li>
<li>gps里程计（由于这部分需要额外的计算，暂且忽略gps的输入）</li>
</ol>
<p>PS:这部分需要<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的知识，可以参考本项目的另外一篇文章：<a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——GTSAM快速入门</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>使用上面两个位姿关系构建因子图，并使用因子图优化算法进行整体的优化，得到全局优化下的关键帧位姿</p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt01.png" alt="" /><figcaption>因子图构建流程图</figcaption>
</figure>
<p><strong>关键帧的选择</strong></p>
<p>并不是所有的雷达帧都会被当作关键帧，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>使用一种比较简单的方案判断是否将当前帧采纳为关键帧：只有与上一帧关键帧的位姿相差足够大才会采纳为关键帧。</p>
<p><strong>添加激光里程计因子</strong></p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt-odomFactor.png" alt="" /><figcaption>激光里程计因子</figcaption>
</figure>
<p><strong>回环因子</strong></p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt-loopFactor.png" alt="" /><figcaption>添加回环因子</figcaption>
</figure>
<p><strong>设置因子图初值并优化</strong></p>
<figure>
<img src="./imgs/Design-mapOptimization-graphOpt-optimization.png" alt="" /><figcaption>因子图优化</figcaption>
</figure>
<h3 id="更新历史关键帧位姿">更新历史关键帧位姿</h3>
<p>当有新的回环被检测到，该回环关系被加入因子图进行优化。由于回环关系是一种很强约束性的观测，因此，在观测到新的回环之后，因子图优化对历史关键帧的位姿变化会比较大，因此需要对历史关键帧的位姿一起做一次更新。</p>
<figure>
<img src="./imgs/Design-mapOptimization-updatePath.png" alt="" /><figcaption>更新历史位姿</figcaption>
</figure>
<h3 id="发布里程计及可视化点云">发布里程计及可视化点云</h3>
<p>在原始的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>代码中这部分还有较多处理，但实际上并没有太多作用。在本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">spl</a>中，已经去除了冗余部分。这部分就只是将计算出来的激光里程计往外发布。</p>
<h2 id="回环检测线程">回环检测线程</h2>
<p>回环检测是SLAM中很重要的一个环节。通过检查当前位置是否已经是到达过的位置，并对重复到达的位置匹配计算位姿。如下图中，<span class="math inline">\(x_5\)</span>与<span class="math inline">\(x_2\)</span>够成回环，<span class="math inline">\(f_5(x_5,x_2)\)</span>是两个位置间的相对位置关系。通过回环之间的约束，对因子图优化器提供很强的信息，使得整体的位姿估计达到全局最优的状态。</p>
<figure>
<img src="./imgs/loopClosure.png" alt="" /><figcaption>回环因子</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中回环检测使用ICP算法，计算最新的关键帧与可能形成回环的位置的点云匹配，并只有在匹配分数非常好的情况下才采纳这个回环结果。由于这部分是比较耗费计算时间的，并且，回环关系只需要以比较低的状态加入因子图即可，因此，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的<code>mapOptimization.cpp</code>中是使用一个独立线程执行回环检测：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> MO = std::<span class="built_in">make_shared</span>&lt;mapOptimization&gt;(options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回环检测独立线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">loopthread</span><span class="params">(&amp;mapOptimization::loopClosureThread, MO)</span></span>;</span><br></pre></td></tr></table></figure>
<p>同时，这个线程内部也默认被设为较低的执行频率（默认1Hz）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 回环检测独立线程</span></span><br><span class="line"><span class="comment">  * 1. 由于回环检测中用到了点云匹配，较为耗时，所以独立为单独的线程运行</span></span><br><span class="line"><span class="comment">  * 2. 新的回环关系被检测出来时被主线程加入因子图中优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loopClosureThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loopClosureEnableFlag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 1</span></span><br><span class="line">    <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(loopClosureFrequency)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        <span class="built_in">performLoopClosure</span>();</span><br><span class="line">        <span class="built_in">visualizeLoopClosure</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回环检测线程的整体流程如下：</p>
<figure>
<img src="./imgs/Design-mapOptimization-loopThread.png" alt="" /><figcaption>回环检测线程流程图</figcaption>
</figure>
<h3 id="寻找回环对应的帧">寻找回环对应的帧</h3>
<p>当开始寻找新的回环关系时，会根据最后一帧关键帧找到是否有合适的对应帧作为回环帧。主要通过两个约束：</p>
<ol type="1">
<li>空间位置最近（使用kdtree做距离检索）</li>
<li>时间距离够远（去除时间过近的帧）</li>
</ol>
<p>这个部分主要是函数<code>detectLoopClosureDistance</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 根据位置关系寻找当前帧与对应帧的索引</span></span><br><span class="line"><span class="comment">  * 1. 将最后一帧关键帧作为当前帧，如果当前帧已经在回环对应关系中，则返回（已经处理过这一帧了）。如果找到的回环对应帧相差时间过短也返回false。回环关系用一个全局map缓存</span></span><br><span class="line"><span class="comment">  * 2. 对关键帧3D位姿构建kd树，并用当前帧位置从kd树寻找距离最近的几帧，挑选时间间隔最远的那一帧作为匹配帧</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @param latestID 传出参数，找到的当前帧索引，实际就是用最后一帧关键帧</span></span><br><span class="line"><span class="comment">  * @param closestID 传出参数，找到的当前帧对应的匹配帧</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">detectLoopClosureDistance</span><span class="params">(<span class="type">int</span> *latestID, <span class="type">int</span> *closestID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> loopKeyCur = copy_cloudKeyPoses3D-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> loopKeyPre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认最后一帧关键帧没有被加入过回环关系中</span></span><br><span class="line">    <span class="keyword">auto</span> it = loopIndexContainer.<span class="built_in">find</span>(loopKeyCur);</span><br><span class="line">    <span class="keyword">if</span> (it != loopIndexContainer.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将关键帧的3D位置构建kdtree，并检索空间位置相近的关键帧</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pointSearchIndLoop;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pointSearchSqDisLoop;</span><br><span class="line">    kdtreeHistoryKeyPoses-&gt;<span class="built_in">setInputCloud</span>(copy_cloudKeyPoses3D);</span><br><span class="line">    <span class="comment">// 寻找空间距离相近的关键帧</span></span><br><span class="line">    kdtreeHistoryKeyPoses-&gt;<span class="built_in">radiusSearch</span>(copy_cloudKeyPoses3D-&gt;<span class="built_in">back</span>(), historyKeyframeSearchRadius, pointSearchIndLoop, pointSearchSqDisLoop, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保空间距离相近的帧是较久前采集的，排除是前面几个关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)pointSearchIndLoop.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = pointSearchIndLoop[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(copy_cloudKeyPoses6D-&gt;points[id].time - timeLaserInfoCur) &gt; historyKeyframeSearchTimeDiff)</span><br><span class="line">        &#123;</span><br><span class="line">            loopKeyPre = id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到位置关系、时间关系都符合要求的关键帧，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (loopKeyPre == <span class="number">-1</span> || loopKeyCur == loopKeyPre)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *latestID = loopKeyCur;</span><br><span class="line">    *closestID = loopKeyPre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="构建局部地图">构建局部地图</h3>
<p>找到匹配的关键帧id后，会在该关键帧的周围抽取其他关键帧构建局部点云地图。这个步骤跟雷达里程计线程中的局部地图构建是类似的，这里就不再赘述。</p>
<h3 id="点云匹配-1">点云匹配</h3>
<p>这里使用ICP直接对<code>curKeyframeCloud</code>(最后一帧关键帧)和<code>preKeyframeCloud</code>(回环对应帧周围构建的点云地图)做点云匹配，并得出当前帧到回环帧的转换矩阵<span class="math inline">\(T_{cur}^{pre}\)</span></p>
<h3 id="添加回环关系到队列">添加回环关系到队列</h3>
<p>由于回环关系检测跟因子图优化是两个线程，为了避免复杂的线程同步关系，在回环线程中用几个队列将回环关系缓存，在雷达里程计线程中从这几个队列提取相应的回环关系加入因子图。这里主要缓存几个内容：1）、回环索引；2）、回环关系的位姿转换矩阵（也就是ICP的结果）；3）、噪声因子（根据匹配的分数计算的噪声）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9. 将回环索引、回环间相对位姿、回环噪声模型加入全局变量</span></span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">loopIndexQueue.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(loopKeyCur, loopKeyPre));</span><br><span class="line">loopPoseQueue.<span class="built_in">push_back</span>(poseFrom.<span class="built_in">between</span>(poseTo));</span><br><span class="line">loopNoiseQueue.<span class="built_in">push_back</span>(constraintNoise);</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<h2 id="全局地图可视化线程">全局地图可视化线程</h2>
<p>这个线程主要是将所有历史关键帧，使用关键帧的位姿，全部转换到地图坐标系下，构建一个全局地图，并发布。这个线程完全是为了可视化，同时，处理所有的关键帧也需要很大计算量，因此，这个线程也被默认限制在5Hz的频率下执行。主要操作就是点云坐标系转换，这里就不赘述了。函数是<code>publishGlobalMap</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发布全局地图点云，在全局地图可视化线程中调用</span></span><br><span class="line"><span class="comment">  * 1. 对所有关键帧3D位姿构建KD树</span></span><br><span class="line"><span class="comment">  * 2. 以最后一帧关键帧为索引找出一定半径范围内的所有关键帧</span></span><br><span class="line"><span class="comment">  * 3. 对找出的关键帧数量做降采样</span></span><br><span class="line"><span class="comment">  * 4. 对所有关键帧的点云做拼接（投影到地图坐标系）</span></span><br><span class="line"><span class="comment">  * 5. 对地图点云做降采样</span></span><br><span class="line"><span class="comment">  * 6. 发布全局地图点云</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publishGlobalMap</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/06/lio_sam/pcdRegistration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（九）点云匹配算法详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-06 23:17:19" itemprop="dateCreated datePublished" datetime="2023-04-06T23:17:19+08:00">2023-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 22:01:43" itemprop="dateModified" datetime="2023-04-20T22:01:43+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/04/06/lio_sam/pcdRegistration-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（九）点云匹配算法详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（九）点云匹配算法详解" href="/2023/04/06/lio_sam/pcdRegistration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6bd455643b6442d6e43dd9a0a5cd9a7a" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中激光历程计的点云匹配方法沿用自<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>，这个基于点到线和点到面距离求解最小二乘问题的方法起始被用到很多框架，包括<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">Lego-LOAM</a>,各种LOAM的变种，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>及其变种。这段点云匹配代码可以说被重用了很多次，但是各个论文对这部分的描述实际上很少或者基本省略，<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>原始论文对这部分的描述与实际的代码实现差别比较大，导致如果想真正看懂这段代码还是挺难的。这篇文章详细地剖析这部分的原理、实现、以及与论文中不同之处。这里面唯一有一点还没有搞清楚的是对于 <a href="#Degenerate">高斯矩阵退化</a>部分的实现。</p>
<p>由于本文主要是想讲明白在上述这些SLAM框架中点云匹配的实现，因此对于最小二乘问题的求解不会详细展开，需要这部分知识可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113946848">最小二乘问题求解的四种解法</a>或者《视觉SLAM十四讲》中关于最小二乘问题求解的章节。</p>
<h2 id="点云-局部地图匹配流程scan-2-map">点云-局部地图匹配流程Scan-2-Map</h2>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，对于每一帧点云<span class="math inline">\(\mathbb{F}_i\)</span>会先进行特征点提取。特征点包括线特征点和平面特征点（具体方法参考本博客文章：<a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a>)。我们记提取后的线特征点云为<span class="math inline">\(F^e_i\)</span>，平面特征点云为<span class="math inline">\(F^p_i\)</span>。</p>
<p>经过一段时间后<span class="math inline">\(1,2,3,...,i-1\)</span>后，我们拥有一系列关键帧的线特征点云<span class="math inline">\(F^e_1,F^e_2,F^e_3,...,F^e_{i-1}\)</span>和平面特征点云<span class="math inline">\(F^p_1,F^p_2,F^p_3,...,F^p_{i-1}\)</span>，以及这些关键帧对应的位姿<span class="math inline">\(T_1,T_2,T_3,...,T_{i-1}\)</span>. 同时对于点云<span class="math inline">\(\mathbb{F}_i\)</span>，我们通过IMU里程计还可以获得该帧点云的初始位姿估计<span class="math inline">\(\hat{T}_i\)</span>，这个位姿估计<span class="math inline">\(\hat{T}_i\)</span>其实就是我们要优化的量。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，激光里程计匹配的是当前帧点云和局部地图。局部地图是通过当前帧空间以及时间近邻的其他关键帧构建的。 <img src="./imgs/Design-mapOptimization-scan2MapOpt.png" alt="scan2MapOptimization" /></p>
<p>对于任何一帧点云以及对应的位姿，我们可以将点云转换到地图坐标系： <span class="math display">\[\mathbb{F}^m_i = R_i\mathbb{F}_i+t_i\]</span> 其中<span class="math inline">\(m\)</span>上标指的是地图坐标系，<span class="math inline">\(R_i\)</span>和<span class="math inline">\(t_i\)</span>是位姿<span class="math inline">\(T_i\)</span>中的旋转矩阵和平移向量。</p>
<p>对选择为构建局部地图的关键帧分别应用上式并累加起来（实际累加后会进行体素降采样）后就构成局部地图<span class="math inline">\(M^e_i\)</span>和<span class="math inline">\(M^p_i\)</span>，<span class="math inline">\(e\)</span>和<span class="math inline">\(p\)</span>下标表示edge和planner。</p>
<p>同时，我们对当前帧的特征点云<span class="math inline">\(F^e_i\)</span>和<span class="math inline">\(F^p_i\)</span>应用位姿的初始估计<span class="math inline">\(\hat{T}_i\)</span>可以得到在近似地图坐标系下的点云。为了方便后面叙述，这里省略坐标系和关键帧索引的上下标。重申一下我们的输入：</p>
<ol type="1">
<li>地图坐标系下的局部点云地图<span class="math inline">\(M^e\)</span>和<span class="math inline">\(M^p\)</span></li>
<li>雷达坐标系下的当前帧特征点云<span class="math inline">\(F^e\)</span>和<span class="math inline">\(F^p\)</span></li>
<li>当前帧的初始位姿估计<span class="math inline">\(\hat{T}_i=[\hat{R}_i,\hat{t}_i]\)</span></li>
</ol>
<p>我们的目标就是优化位姿<span class="math inline">\(T_i\)</span>使得用这个位姿将<span class="math inline">\(F^e\)</span>和<span class="math inline">\(F^p\)</span>转换到地图坐标系后与地图点云的匹配程度最好。</p>
<h2 id="几何相关知识">几何相关知识</h2>
<h3 id="点到线距离">点到线距离</h3>
<h4 id="论文中计算方法">论文中计算方法</h4>
<figure>
<img src="./imgs/LOAM-fig7.png" alt="" /><figcaption>LOAM论文图7：展示如何根据当前帧的边缘点和平面点在局部地图中找到对应的线和平面</figcaption>
</figure>
<p>上图的子图（a）展示如何对当前帧边缘点点集<span class="math inline">\(F^e\)</span>中的每一个点从局部地图<span class="math inline">\(M^e\)</span>中找到对应的直线。对于每一个边缘点<span class="math inline">\(P^{F^e}_i \in F^e\)</span>，从局部地图的边缘点集合<span class="math inline">\(M^e\)</span>中找到最近点<span class="math inline">\(P^{M^e}_j\)</span>，橘色线是点<span class="math inline">\(j\)</span>所在的激光线束，蓝色线是前后相近的另外两条激光线束。从前后两条激光线束（蓝色线）找出与<span class="math inline">\(e_i\)</span>距离最近的点，并选择两者中距离更小的点作为点<span class="math inline">\(P^{M^e}_l\)</span>，则经过点<span class="math inline">\(P^{M^e}_j\)</span>、<span class="math inline">\(P^{M^e}_l\)</span>组成的线为点<span class="math inline">\(P^{F^e}_i\)</span>对应的直线。那么问题就转化为点<span class="math inline">\(P^{F^e}_i\)</span>到经过点<span class="math inline">\(P^{M^e}_j\)</span>、<span class="math inline">\(P^{M^e}_l\)</span>的直线的距离。</p>
<p>该距离计算公式如下：</p>
<p><span class="math display">\[
d_{e}=\frac{|(P^{F^e}_i - P^{M^e}_j)\times (P^{F^e}_i - P^{M^e}_l)|}{|(P^{M^e}_j - P^{M^e}_l)|}\tag{1}
\]</span></p>
<p>公式（1）中分子部分计算的是向量<span class="math inline">\((P^{F^e}_i - P^{M^e}_j)\)</span>和<span class="math inline">\((P^{F^e}_i - P^{M^e}_l)\)</span>的叉积的模长。两个向量的叉积是一个向量，方向于两个向量构成的平面垂直，模长等于两个向量组成的平行四边形面积。公式（1）的分母代表的是该平行四边形对角线的长度。因此分子除以分母就等于直线外一点到直线的距离。</p>
<h4 id="代码中计算方法">代码中计算方法</h4>
<p>在论文中对<span class="math inline">\(F^e\)</span>的点找到<span class="math inline">\(M^e\)</span>对应的直线是通过找到两个距离最近的点，但是在代码中是找到距离最近的5个点，然后计算这5个点的协方差，对协方差做特征值分解，最大的特征值对应的特征向量为主方向，并判断这5个点的分布是否接近直线的要求。 代码中寻找点到局部地图的对应直线，然后计算距离和法向量主要是在<code>mapOptimization</code>中的函数<code>cornerOptimization</code>中完成。</p>
<ol type="1">
<li>对点集<span class="math inline">\(F^e\)</span>中的点从局部地图<span class="math inline">\(M^e\)</span>中找到最近5个点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从局部地图（已经提前设置好kdtree）中找到最近的5个点</span></span><br><span class="line"><span class="comment">// pointSel为检索点</span></span><br><span class="line"><span class="comment">// pointSearchInd存储检索结果的5个点在原始点云中的索引</span></span><br><span class="line"><span class="comment">// pointSearchSqDis存储检索出的5个点与检索点的距离的平方</span></span><br><span class="line">kdtreeCornerFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>计算这5个点的协方差矩阵</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cx,cy,cz是检索出的5个点的中心坐标</span></span><br><span class="line"><span class="type">float</span> cx = <span class="number">0</span>, cy = <span class="number">0</span>, cz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    cx += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">    cy += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">    cz += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">&#125;</span><br><span class="line">cx /= <span class="number">5</span>; cy /= <span class="number">5</span>;  cz /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协方差矩阵是对称矩阵</span></span><br><span class="line"><span class="type">float</span> a11 = <span class="number">0</span>, a12 = <span class="number">0</span>, a13 = <span class="number">0</span>, a22 = <span class="number">0</span>, a23 = <span class="number">0</span>, a33 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="type">float</span> ax = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].x - cx;</span><br><span class="line">    <span class="type">float</span> ay = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].y - cy;</span><br><span class="line">    <span class="type">float</span> az = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].z - cz;</span><br><span class="line"></span><br><span class="line">    a11 += ax * ax; a12 += ax * ay; a13 += ax * az;</span><br><span class="line">    a22 += ay * ay; a23 += ay * az;</span><br><span class="line">    a33 += az * az;</span><br><span class="line">&#125;</span><br><span class="line">a11 /= <span class="number">5</span>; a12 /= <span class="number">5</span>; a13 /= <span class="number">5</span>; a22 /= <span class="number">5</span>; a23 /= <span class="number">5</span>; a33 /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储协方差的值到matA1</span></span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = a11; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>) = a12; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) = a13;</span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>) = a12; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>) = a22; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) = a23;</span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>) = a13; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">1</span>) = a23; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) = a33;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>计算直线方向，也就是特征值分解，最大特征值对应的特征向量为数据主方向</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对协方差矩阵做特征值分解，最大特征值对应的特征向量是这5个点的主方向</span></span><br><span class="line">cv::<span class="built_in">eigen</span>(matA1, matD1, matV1);</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>计算点到直线距离</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下部分是在计算当前点pointSel到检索出的直线的距离和方向，如果距离够近，则认为匹配成功，否则认为匹配失败</span></span><br><span class="line"><span class="comment">// x0,y0,z0是直线外一点</span></span><br><span class="line"><span class="type">float</span> x0 = pointSel.x;</span><br><span class="line"><span class="type">float</span> y0 = pointSel.y;</span><br><span class="line"><span class="type">float</span> z0 = pointSel.z;</span><br><span class="line"><span class="comment">// matV1的第一行就是5个点形成的直线的方向，cx,cy,cz是5个点的中心点</span></span><br><span class="line"><span class="comment">// 因此，x1,y1,z1和x2,y2,z2是经过中心点的直线上的另外两个点，两点之间的距离是0.2米</span></span><br><span class="line"><span class="type">float</span> x1 = cx + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> y1 = cy + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">float</span> z1 = cz + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">float</span> x2 = cx - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> y2 = cy - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">float</span> z2 = cz - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这边是在求[(x0-x1),(y0-y1),(z0-z1)]与[(x0-x2),(y0-y2),(z0-z2)]叉乘得到的向量的模长</span></span><br><span class="line"><span class="comment">// 这个模长是由0.2*V1[0]和点[x0,y0,z0]构成的平行四边形的面积</span></span><br><span class="line"><span class="comment">// 垂直于0,1,2三点构成的平面的向量[XXX,YYY,ZZZ] = [(y0-y1)(z0-z2)-(y0-y2)(z0-z1),-(x0-x1)(z0-z2)+(x0-x2)(z0-z1),(x0-x1)(y0-y2)-(x0-x2)(y0-y1)]</span></span><br><span class="line"><span class="type">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) * ((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                + ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) * ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                + ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)) * ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// l12表示的是0.2*(||V1[0]||)</span></span><br><span class="line"><span class="comment">// 点x1,y1,z1到点x2,y2,z2的距离</span></span><br><span class="line"><span class="type">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求叉乘结果[la&#x27;,lb&#x27;,lc&#x27;]=[(x1-x2),(y1-y2),(z1-z2)]x[XXX,YYY,ZZZ]</span></span><br><span class="line"><span class="comment">// [la,lb,lc]=[la&#x27;,lb&#x27;,lc&#x27;]/a012/l12</span></span><br><span class="line"><span class="comment">// LLL=[la,lb,lc]是0.2*V1[0]这条高上的单位法向量。||LLL||=1；</span></span><br><span class="line"><span class="type">float</span> la = ((y1 - y2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">          + (z1 - z2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lb = -((x1 - x2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">            - (z1 - z2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lc = -((x1 - x2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">            + (y1 - y2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ld2就是点pointSel(x0,y0,z0)到直线的距离</span></span><br><span class="line"><span class="type">float</span> ld2 = a012 / l12;</span><br></pre></td></tr></table></figure>
<h3 id="点到面距离">点到面距离</h3>
<h4 id="论文中计算方法-1">论文中计算方法</h4>
<p>再次贴出论文中的图</p>
<figure>
<img src="./imgs/LOAM-fig7.png" alt="" /><figcaption>LOAM论文图7：展示如何根据当前帧的边缘点和平面点在局部地图中找到对应的线和平面</figcaption>
</figure>
<p>与计算点到直线的距离类似，对于一个平面点<span class="math inline">\(P^{F^p}_i \in F^p\)</span>，从局部地图平面点集<span class="math inline">\(M^p\)</span>中找到最近点<span class="math inline">\(P^{M^p}_j\)</span>，再从该点所在的激光线束找到另一个点<span class="math inline">\(P^{M^p}_l\)</span>以及前后两条激光线束中找到另外一个最近点<span class="math inline">\(P^{M^p}_m\)</span>，这样就确保了三个点不会共线。 那么问题就转化为已知经过三个点<span class="math inline">\(P^{M^p}_{jlm}\)</span>的平面，求平面外一点<span class="math inline">\(P^{F^p}_i\)</span>到该平面的距离 首先，根据三个点，我们可以计算该平面的法向量，并归一化为单位法向量</p>
<p><span class="math display">\[
n_{jlm}=(P^{M^p}_j - P^{M^p}_l)\times (P^{M^p}_j - P^{M^p}_m)
\]</span></p>
<p><span class="math display">\[
n_{jlm} = \frac{n_{jlm}}{|n_{jlm}|}
\]</span></p>
<p>于是，点到平面的距离为 <span class="math display">\[
d_p = |(P^{F^p}_i - P^{M^p}_j)n_{jlm}|\tag{2}
\]</span></p>
<h4 id="代码中计算方法-1">代码中计算方法</h4>
<p>在代码中，也是先根据点<span class="math inline">\(P^{F^p}_i\)</span>从局部地图平面点集中找到最近的5个点，然后对这5个点用最小二乘法（求解超定方程）得到拟合平面的法向量。得到平面方程后就可以直接计算点到平面的距离了。这部分代码在<code>mapOptimization.cpp</code>中<code>surfOptimization</code>函数</p>
<ol type="1">
<li>从局部地图找到距离最近的5个点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与边缘点找直线一样，从局部地图的平面点集中找到与pointSel距离最近的5个点</span></span><br><span class="line">kdtreeSurfFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>求解方程Ax+By+Cz+1=0方程</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的过程要求解Ax+By+Cz+1=0的平面方程</span></span><br><span class="line"><span class="comment">// 由于有5个点，因此是求解超定方程</span></span><br><span class="line"><span class="comment">// 假设5个点都在平面上，则matA0是系数矩阵，matB0是等号右边的值（都是-1）；matX0是求出来的A，B，C</span></span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">5</span>, <span class="number">3</span>&gt; matA0;</span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">5</span>, <span class="number">1</span>&gt; matB0;</span><br><span class="line">Eigen::Vector3f matX0;</span><br><span class="line"></span><br><span class="line">matA0.<span class="built_in">setZero</span>();</span><br><span class="line">matB0.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">matX0.<span class="built_in">setZero</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">0</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">1</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">2</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是求解matA0XmatX0 = matB0方程</span></span><br><span class="line">matX0 = matA0.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(matB0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>求点到平面距离</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pa = <span class="built_in">matX0</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pb = <span class="built_in">matX0</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pc = <span class="built_in">matX0</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （pa,pb,pc)是平面的法向量，这里是对法向量规一化，变成单位法向量</span></span><br><span class="line"><span class="type">float</span> ps = <span class="built_in">sqrt</span>(pa * pa + pb * pb + pc * pc);</span><br><span class="line">pa /= ps; pb /= ps; pc /= ps; pd /= ps;</span><br></pre></td></tr></table></figure>
<h2 id="最小二乘问题求解">最小二乘问题求解</h2>
<p>从前面两步，我们得到了一些边缘点和平面点到局部地图的距离和距离向量，我们的目标就是优化这些距离。由于我们现在有6个未知数，也就是位姿的6个自由度<span class="math inline">\(T_i=[t_x,t_y,t_z,roll,pitch,yaw]\)</span>，但是我们的点超过6个，因此是求解最小二乘问题。</p>
<p>最小二乘问题是最优化里的基础问题，这里就不展开公式推导了，具体可以参考这篇文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113946848">最小二乘问题求解的四种解法</a>。</p>
<p>常见的求解最小二乘问题有高斯牛顿法（Gauss-Newton Method）和列温伯格马夸克法（Levernberg-Marquate），后者是前者的改进。<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>论文里面虽然用的是LM算法，但是在代码中实际用的是GN算法。这里只强调GN算法的核心思路。</p>
<p><code>GN</code>算法也是迭代更新的算法，每一步重点在与求出未知量的更新方向和步长，每一步将更行向量叠加到未知量上，让目标函数逐渐收敛。 在这里，未知量是位姿<span class="math inline">\(T_i\)</span>，目标函数是点到直线点到平面距离<span class="math inline">\(\mathbb{d}\)</span>，因此，我们在每一步迭代中要找到一个<span class="math inline">\(\Delta{T}_i\)</span>，更新未知量<span class="math inline">\(T_i = T_i + \Delta{T}_i\)</span>，并使得距离<span class="math inline">\(\mathbb{b}\)</span>逐渐下降。</p>
<p>在高斯牛顿法中，更新向量的是通过求解增量方程得到</p>
<p><span class="math display">\[
J(x)J(x)^T\Delta{x}=-J(x)f(x)\tag{3}
\]</span></p>
<p>公式（3）就是高斯牛顿法的增量方程，<span class="math inline">\(J(x)\)</span>是雅克比矩阵，也就是目标函数相对于未知量的偏导；<span class="math inline">\(f(x)\)</span>是目标函数；<span class="math inline">\(\Delta{x}\)</span>就是我们要求的增量。</p>
<h2 id="代码中点云匹配算法基于gn算法">代码中点云匹配算法（基于GN算法）</h2>
<p>这部分内容对于数学公式推导部分主要参考<a target="_blank" rel="noopener" href="https://wykxwyc.github.io/2019/08/01/The-Math-Formula-in-LeGO-LOAM/#lmoptimization%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97">wykxwyc.github.io</a>，但是原文中对于旋转矩阵对欧拉角的求导似乎有点问题，与代码对不上。</p>
<h3 id="欧拉角转旋转矩阵">欧拉角转旋转矩阵</h3>
<p>代码中对角度的表达使用欧拉角表达，因此我们需要先将欧拉角转换为旋转矩阵形式。记<span class="math inline">\(x,y,z\)</span>轴的角度为<span class="math inline">\(\alpha,\beta,\gamma\)</span></p>
<p><span class="math display">\[
\begin{split}
R_{\alpha}=
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;\cos\alpha&amp;-\sin\alpha\\
0&amp;\sin\alpha&amp;\cos\alpha
\end{bmatrix}
\end{split}
\]</span></p>
<p><span class="math display">\[
\begin{split}
R_{\beta}=
\begin{bmatrix}
\cos\beta&amp;0&amp;\sin\beta\\
0&amp;1&amp;0\\
-\sin\beta&amp;0&amp;\cos\beta
\end{bmatrix}
\end{split}
\]</span></p>
<p><span class="math display">\[
\begin{split}
R_{\gamma}=
\begin{bmatrix}
\cos\gamma&amp;-\sin\gamma&amp;0\\
\sin\gamma&amp;\cos\gamma&amp;0\\
0&amp;0&amp;1\\
\end{bmatrix}
\end{split}
\]</span></p>
<p><strong>PS:</strong> 为了简便起见，我们在后面的推导中使用<span class="math inline">\(c_1,c_2,c_3\)</span>表示<span class="math inline">\(\cos\alpha,\cos\beta,\cos\gamma\)</span>，用<span class="math inline">\(s_1,s_2,s_3\)</span>表示<span class="math inline">\(\sin\alpha,\sin\beta,\sin\gamma\)</span></p>
<p>根据上面转换关系，使用<span class="math inline">\(Z-X-Y\)</span>顺序，将欧拉角转换为旋转矩阵如下</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
R
&amp;=&amp;R_yR_xR_z\\
&amp;=&amp;
\begin{bmatrix}
c_2&amp;0&amp;s_2\\
0&amp;1&amp;0\\
-s_2&amp;0&amp;c_2
\end{bmatrix}
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;c_1&amp;-s_1\\
0&amp;s_1&amp;c_1
\end{bmatrix}
\begin{bmatrix}
c_3&amp;-s_3&amp;0\\
s_3&amp;c_3&amp;0\\
0&amp;0&amp;1
\end{bmatrix}\\
&amp;=&amp;
\begin{bmatrix}
c_2c_3+s_1s_2s_3&amp;-c_2s_3+s_1s_2c_3&amp;c_1s_2\\
c_1s_3&amp;c_1c_3&amp;-s_1\\
-s_2c_3+s_1c_2s_3&amp;s_2s_3+s_1c_2c_3&amp;c_1c_2
\end{bmatrix}
\end{array}
\end{split}
\]</span></p>
<hr />
<h3 id="旋转矩阵对欧拉角求偏导">旋转矩阵对欧拉角求偏导</h3>
<p>有了上面欧拉角转旋转矩阵的公式之后，求旋转矩阵相对于欧拉角的偏导就容易多了，先求<span class="math inline">\(R\)</span>相对于角<span class="math inline">\(\alpha\)</span>的偏导</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial R}{\partial \alpha} = 
\begin{bmatrix}
c_1s_2s_3&amp;c_1s_2c_3&amp;-s_1s_2\\
-s_1s_3&amp;-s_1c_3&amp;-c_1\\
c_1c_2s_3&amp;c_1c_2c_3&amp;-s_1c_2
\end{bmatrix}
\end{split}
\]</span></p>
<p>再求<span class="math inline">\(R\)</span>相对于<span class="math inline">\(\beta\)</span>的偏导</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial R}{\partial \beta} = 
\begin{bmatrix}
-s_2c_3+s_1c_2s_3&amp;s_2s_3+s_1c_2c_3&amp;c_1c_2\\
0&amp;0&amp;0\\
-c_2c_3-s_1s_2s_3&amp;c_2s_3-s_1s_2c_3&amp;-c_1s_2
\end{bmatrix}
\end{split}
\]</span></p>
<p>最后求<span class="math inline">\(R\)</span>相对于<span class="math inline">\(\gamma\)</span>的偏导</p>
<p><span class="math display">\[
\begin{split}
\frac{\partial R}{\partial \gamma} = 
\begin{bmatrix}
-c_2s_3+s_1s_2c_3&amp;-c_2c_3-s_1s_2s_3&amp;0\\
c_1c_3&amp;-c_1s_3&amp;0\\
s_2s_3+s_1c_2c_3&amp;s_2c_3-s_1c_2s_3&amp;0
\end{bmatrix}
\end{split}
\]</span></p>
<hr />
<h3 id="目标函数对位姿求雅克比矩阵">目标函数对位姿求雅克比矩阵</h3>
<p><strong>时刻牢记：位姿<span class="math inline">\(T_i=[t_x,t_y,t_z,\alpha,\beta,\gamma]=[R,t]\)</span>是我们要求的量</strong></p>
<p>对于当前帧特征点<span class="math inline">\(F^e,F^p\)</span>中的一个点<span class="math inline">\(P_i=[p_x,p_y,p_z]\)</span>（这里没有区分边缘点和平面点，因为两者的偏导公式一样），我们使用函数<span class="math inline">\(G(\cdot)\)</span>将其从雷达坐标系转换到局部坐标系(m上标表示地图坐标系)</p>
<p><span class="math display">\[
P^m_i=G(P_i,T_i)=R\cdot P_i+t
\]</span></p>
<p>我们使用函数<span class="math inline">\(D(\cdot)\)</span>表示该点到局部地图的距离，也就是目标函数</p>
<p><span class="math display">\[
loss=D(G(P_i,T_i),Map) = d
\]</span></p>
<p>上式中<span class="math inline">\(d\)</span>对于边缘点代表点到直线距离，对于平面点表示点到平面距离</p>
<p><strong>误差对旋转求偏导</strong></p>
<p>这里以<span class="math inline">\(x\)</span>轴的旋转<span class="math inline">\(\alpha\)</span>为例</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\frac{\partial loss}{\partial \alpha}
&amp;=&amp;
\frac{\partial D\left(G(P_i,T_i),Map\right)}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial G}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i+t}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R}{\partial \alpha}\cdot P_i
\end{array}
\end{split}\tag{4}
\]</span></p>
<p><strong>误差对平移求偏导</strong></p>
<p>这里以<span class="math inline">\(x\)</span>轴的平移<span class="math inline">\(t_x\)</span>为例</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\frac{\partial loss}{\partial t_x}
&amp;=&amp;
\frac{\partial D\left(G(P_i,T_i),Map\right)}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial G}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i+t}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i}{\partial \alpha} + \frac{\partial D}{\partial G}\cdot\frac{\partial t}{\partial t_x}\\
&amp;=&amp;
0+\frac{\partial D}{\partial G}\cdot\frac{\partial t}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}
\end{array}
\end{split}\tag{5}
\]</span></p>
<p><strong>求解<span class="math inline">\(\frac{\partial D}{\partial G}\)</span></strong></p>
<p>在上面误差对旋转求偏导中旋转矩阵对欧拉角求偏导<span class="math inline">\(\frac{\partial R}{\partial \alpha}\)</span>已经在前面的章节推导过了。公式(4)(5)还有一个未知量就是<span class="math inline">\(\frac{\partial D}{\partial G}\)</span></p>
<p><span class="math display">\[
\frac{\partial D}{\partial G} = \frac{\partial d}{\partial P^m_i}
\]</span></p>
<p>也就是说<span class="math inline">\(\frac{\partial D}{\partial G}\)</span>求的是损失函数也就是点到线和点到面的距离相对于点（地图坐标系下）的偏导数。这点可以理解成求一个移动方向，使得让点<span class="math inline">\(P^m_i\)</span>沿着这个方向移动，损失函数上升得最快。很容易想到这个方向就是法线方向（对于点到直线的情况则是直线的垂线方向） 因此</p>
<p><span class="math display">\[
\frac{\partial D}{\partial G} = \frac{\partial d}{\partial P^m_i}=\big(\frac{\partial d}{\partial x}, \frac{\partial d}{\partial y}, \frac{\partial d}{\partial z}\big)=(n_x,n_y,n_z)
\]</span></p>
<h3 id="代码中雅克比矩阵的计算">代码中雅克比矩阵的计算</h3>
<p>这部分计算主要在<code>mapOptimization.cpp</code>中的<code>LMOptimization</code>函数。这里要注意的是，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>这部分代码计算中还加了坐标系的转换，实际上是没有必要的，这部分代码可以看<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的代码，是完全一样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算三轴欧拉角的sin、cos，后面使用旋转矩阵对欧拉角求导中会使用到</span></span><br><span class="line"><span class="comment">// lidar -&gt; camera</span></span><br><span class="line"><span class="type">float</span> srx = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">1</span>]);</span><br><span class="line"><span class="type">float</span> crx = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">1</span>]);</span><br><span class="line"><span class="type">float</span> sry = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"><span class="type">float</span> cry = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"><span class="type">float</span> srz = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">0</span>]);</span><br><span class="line"><span class="type">float</span> crz = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// laserCloudOri是在cornerOptimization、surfOptimization两个函数中找到的有匹配关系的</span></span><br><span class="line"><span class="comment">// 角点和平面点，如果找到的可供优化的点数太少，则跳过此次优化</span></span><br><span class="line"><span class="type">int</span> laserCloudSelNum = laserCloudOri-&gt;<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (laserCloudSelNum &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matA是Jacobians矩阵J</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matA</span><span class="params">(laserCloudSelNum, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAt</span><span class="params">(<span class="number">6</span>, laserCloudSelNum, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtA</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// matB是目标函数，也就是距离</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matB</span><span class="params">(laserCloudSelNum, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtB</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// matX是高斯-牛顿法计算出的更新向量</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matX</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matP</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">PointType pointOri, coeff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudSelNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 坐标系转换这部分可以不用看，没有什么作用</span></span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    pointOri.x = laserCloudOri-&gt;points[i].y;</span><br><span class="line">    pointOri.y = laserCloudOri-&gt;points[i].z;</span><br><span class="line">    pointOri.z = laserCloudOri-&gt;points[i].x;</span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    coeff.x = coeffSel-&gt;points[i].y;</span><br><span class="line">    coeff.y = coeffSel-&gt;points[i].z;</span><br><span class="line">    coeff.z = coeffSel-&gt;points[i].x;</span><br><span class="line">    coeff.intensity = coeffSel-&gt;points[i].intensity;</span><br><span class="line">    <span class="comment">// in camera</span></span><br><span class="line">    <span class="comment">// 求雅克比矩阵的值，也就是求目标函数（点到线、平面的距离）相对于tx,ty,tz,rx,ry,rz的导数</span></span><br><span class="line">    <span class="comment">// 具体的公式推导看仓库README中本项目博客，高斯牛顿法方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)，\Delta&#123;x&#125;就是要求解的更新向量matX</span></span><br><span class="line">    <span class="comment">// arx是目标函数相对于roll的导数</span></span><br><span class="line">    <span class="type">float</span> arx = (crx*sry*srz*pointOri.x + crx*crz*sry*pointOri.y - srx*sry*pointOri.z) * coeff.x</span><br><span class="line">              + (-srx*srz*pointOri.x - crz*srx*pointOri.y - crx*pointOri.z) * coeff.y</span><br><span class="line">              + (crx*cry*srz*pointOri.x + crx*cry*crz*pointOri.y - cry*srx*pointOri.z) * coeff.z;</span><br><span class="line">    <span class="comment">// ary是目标函数相对于pitch的导数</span></span><br><span class="line">    <span class="type">float</span> ary = ((cry*srx*srz - crz*sry)*pointOri.x </span><br><span class="line">              + (sry*srz + cry*crz*srx)*pointOri.y + crx*cry*pointOri.z) * coeff.x</span><br><span class="line">              + ((-cry*crz - srx*sry*srz)*pointOri.x </span><br><span class="line">              + (cry*srz - crz*srx*sry)*pointOri.y - crx*sry*pointOri.z) * coeff.z;</span><br><span class="line">    <span class="comment">// arz是目标函数相对于yaw的导数</span></span><br><span class="line">    <span class="type">float</span> arz = ((crz*srx*sry - cry*srz)*pointOri.x + (-cry*crz-srx*sry*srz)*pointOri.y)*coeff.x</span><br><span class="line">              + (crx*crz*pointOri.x - crx*srz*pointOri.y) * coeff.y</span><br><span class="line">              + ((sry*srz + cry*crz*srx)*pointOri.x + (crz*sry-cry*srx*srz)*pointOri.y)*coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在求点到直线的距离时，coeff表示的是如下内容</span></span><br><span class="line"><span class="comment">    [la,lb,lc]表示的是点到直线的垂直连线方向，s是长度</span></span><br><span class="line"><span class="comment">    coeff.x = s * la;</span></span><br><span class="line"><span class="comment">    coeff.y = s * lb;</span></span><br><span class="line"><span class="comment">    coeff.z = s * lc;</span></span><br><span class="line"><span class="comment">    coeff.intensity = s * ld2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在求点到平面的距离时，coeff表示的是</span></span><br><span class="line"><span class="comment">    [pa,pb,pc]表示过外点的平面的法向量，s是线的长度</span></span><br><span class="line"><span class="comment">    coeff.x = s * pa;</span></span><br><span class="line"><span class="comment">    coeff.y = s * pb;</span></span><br><span class="line"><span class="comment">    coeff.z = s * pc;</span></span><br><span class="line"><span class="comment">    coeff.intensity = s * pd2;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">0</span>) = arz;</span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">1</span>) = arx;</span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">2</span>) = ary;</span><br><span class="line">    <span class="comment">// 目标函数相对于tx的导数等于法向量的x</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">3</span>) = coeff.z;</span><br><span class="line">    <span class="comment">// 目标函数相对于ty的导数等于法向量的y</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">4</span>) = coeff.x;</span><br><span class="line">    <span class="comment">// 目标函数相对于tz的导数等于法向量的z</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">5</span>) = coeff.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matB存储的是目标函数（距离）的负值，因为：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)</span></span><br><span class="line">    matB.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">0</span>) = -coeff.intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新">更新</h3>
<p>得到雅克比矩阵后就可以直接求解高斯-牛顿法里的增量方程</p>
<p><span class="math display">\[
J(x)J(x)^T\Delta{x}=-J(x)f(x)\tag{3}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">transpose</span>(matA, matAt);</span><br><span class="line">matAtA = matAt * matA;</span><br><span class="line">matAtB = matAt * matB;</span><br><span class="line"><span class="comment">// 求解高斯-牛顿法中的增量方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)，这里解出来的matX就是更新向量</span></span><br><span class="line"><span class="comment">// matA是雅克比矩阵J</span></span><br><span class="line"><span class="comment">// matAtB是上面等式中等号的右边，负号在matB赋值的时候已经加入</span></span><br><span class="line">cv::<span class="built_in">solve</span>(matAtA, matAtB, matX, cv::DECOMP_QR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将增量matX叠加到变量（位姿）transformTobeMapped中</span></span><br><span class="line">transformTobeMapped[<span class="number">0</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">1</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">2</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">3</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">4</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">5</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高斯矩阵退化">高斯矩阵退化</h3>
<div id="Degenerate">

</div>
<p>这部分代码其实有一小段没办法完全理解，就是在进行第一次迭代时会对近似Hessian矩阵做是否退化的的判断，然后对退化的方向进行处理，最后对增量进行重新加权。但是实在没有找到这种用法的出处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是第一次迭代，判断求解出来的近似Hessian矩阵，也就是J^&#123;T&#125;J:=matAtA是否退化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这部分的计算说实话没有找到很好的理论出处，这里只能大概说一下这段代码想要做的事情</span></span><br><span class="line"><span class="comment">    * 这里用matAtA也就是高斯-牛顿中的近似海瑟（Hessian）矩阵H。求解增量方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)</span></span><br><span class="line"><span class="comment">    * 要求H:=J^&#123;T&#125;J可逆，但H不一定可逆。下面的代码通过H的特征值判断H是否退化，并将退化的方向清零matV2。而后又根据</span></span><br><span class="line"><span class="comment">    * matV.inv()*matV2作为更新向量的权重系数，matV是H的特征向量矩阵。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (iterCount == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matE</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV2</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对近似Hessian矩阵做特征值分解，matE是特征值，matV是特征向量。opencv的matV中每一行是一个特征向量</span></span><br><span class="line">    cv::<span class="built_in">eigen</span>(matAtA, matE, matV);</span><br><span class="line">    matV.<span class="built_in">copyTo</span>(matV2);</span><br><span class="line"></span><br><span class="line">    isDegenerate = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> eignThre[<span class="number">6</span>] = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matE.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, i) &lt; eignThre[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                matV2.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isDegenerate = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matP = matV.<span class="built_in">inv</span>() * matV2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当第一次迭代判断到海瑟矩阵退化，后面会使用计算出来的权重matP对增量matX做加权组合</span></span><br><span class="line"><span class="keyword">if</span> (isDegenerate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matX2</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    matX.<span class="built_in">copyTo</span>(matX2);</span><br><span class="line">    matX = matP * matX2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="收敛条件判断">收敛条件判断</h3>
<p>当增量步长达到一定阈值后，认为优化已经收敛，因此可以跳出后续迭代。这里用增量中的角度增量和平移增量的幅度做判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算roll、pitch、yaw的迭代步长</span></span><br><span class="line"><span class="type">float</span> deltaR = <span class="built_in">sqrt</span>(</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)), <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 计算tx，ty，tz的迭代步长</span></span><br><span class="line"><span class="type">float</span> deltaT = <span class="built_in">sqrt</span>(</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果迭代的步长达到设定阈值，则认为已经收敛</span></span><br><span class="line"><span class="keyword">if</span> (deltaR &lt; <span class="number">0.05</span> &amp;&amp; deltaT &lt; <span class="number">0.05</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// converged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（八）IMU预积分模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-30 20:55:54" itemprop="dateCreated datePublished" datetime="2023-03-30T20:55:54+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 21:47:44" itemprop="dateModified" datetime="2023-04-20T21:47:44+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（八）IMU预积分模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（八）IMU预积分模块" href="/2023/03/30/lio_sam/imuPreintegration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::447e7d053e8cf00fca42d617e062a049" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="imu预积分">IMU预积分</h2>
<figure>
<img src="./imgs/Design-Pipelines-IMU.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p><code>IMU预积分模块</code>无论在VIO或者LIO中都是一个非常重要的模块。VIO或者LIO中的<code>I</code>，也就是<code>Inertial</code>指的是惯性单元，基本上在这类SLAM框架里指的就是IMU里程计。 IMU可以输出车辆坐标系下的三轴加速度、三轴角速度、三轴地磁计（九轴IMU）。我们都知道，加速度的积分是速度、速度的积分是距离，角速度的积分是角度，地磁计可以计算与地磁北极的偏角，因此，如果IMU的输出是准确的话，使用IMU原始数据并进行积分就可以得到车辆的位姿。然而，目前无论多么高精度的IMU，都很难在较长时间下保持较高的准确度，而且积分会对误差也进行积分，导致IMU里程计只能用来做短时间内的位姿校正。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>是IMU里程计和激光雷达里程计紧耦合的SLAM框架。“紧耦合”三个字在IMU预积分模块得到明显的表达。如果用一句话说明IMU预积分模块的作用，那就是：利用IMU数据，为车辆位姿提供一个较好的位姿初始估计。由于目前的激光雷达大部分是10Hz，部分可以达到20Hz以上，因此，在两帧雷达点云期间，车辆会发生旋转和位移，如果旋转和位移很小，那么点云匹配就能够单独算出一个较准确的里程计（在运动缓慢的情况下，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>即使去除了IMU预积分也可以工作，只需要不启动<code>ImuPreintegration</code>节点即可）。但是如果旋转和位移较大，点云匹配就很可能失败。IMU一般拥有较高频率（200Hz以上），因此可以为两帧雷达点云的匹配提供较好的初始位姿值。</p>
<p>前面提到单纯利用IMU数据做积分，时间一长累积误差会很大，无法提供良好的初始位姿估计，因此需要融合其他传感器校正IMU积分算法。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，通过不断从激光里程计获取最新的里程计信息，作为IMU积分算法的观测来达到校正IMU积分算法的目的。</p>
<p><em>PS：此部分代码很大程度利用了<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>，因此，需要提前阅读本项目<a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></em></p>
<h2 id="imu预积分模块的整体框架流程图">IMU预积分模块的整体框架流程图</h2>
<figure>
<img src="./imgs/Design-imuPreintegration-top01.png" title="预积分模块流程图" alt="" /><figcaption>Simple-LIO-SAM预积分模块整体框架流程图</figcaption>
</figure>
<h2 id="零偏估计和imu里程计">零偏估计和IMU里程计</h2>
<p>这个模块容易让人看晕的地方在于模块里有两个队列缓存IMU原始数据，同时有两个IMU预积分器。之所以需要有两个预积分器的原因在于，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中对于IMU的预积分，在预测时（predict）需要指明上一时刻的<code>bias</code>，也就是IMU的零偏。通常这个<code>bias</code>会随着时间慢慢改变，因此不能用离线标定的数据直接使用。于是，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，有一个线程（LaserHandler）会利用激光里程计当作额外的观测量，不断估计最新的<code>bias</code>值。而另一个线程（ImuHandler）则可以一直利用最新的<code>bias</code>值对实时接收到的IMU数据做积分，并发布为IMU里程计。</p>
<p>为了简单起见，我们将用来做零偏估计的队列和预积分器叫做<strong>优化队列</strong>和<strong>优化预积分器</strong>；将用来实时对IMU数据积分并发布IMU里程计的队列和预积分器叫做<strong>IMU队列</strong>和<strong>IMU预积分器</strong>。</p>
<p>一图胜千言，下面这幅图描述了两个队列是如何被耦合起来输出更为准确的IMU预积分结果。其中<code>imuQueOpt</code>是优化队列，<code>imuQueImu</code>是IMU队列，两者命令与代码中一致。</p>
<figure>
<img src="./imgs/TwoImuQues.png" alt="" /><figcaption>两个IMU队列及线程交互图</figcaption>
</figure>
<h2 id="零偏估计线程即odometryhandler">零偏估计线程——即odometryHandler</h2>
<p>这个回调函数占据了预积分模块大部分内容，而且有较多的重置条件和与<code>imuHandler</code>线程同步的操作，比较容易弄混。</p>
<p>这个回调函数会在接收到新的一帧雷达里程计（发自<code>MapOptimization</code>模块），主要操作上图中的<code>imuQueOpt</code>和<code>优化预积分器</code>。每当节点新收到一帧雷达里程计时，就会执行<code>预积分模块流程图</code>中左侧的一系列操作。主要目的就是利用雷达里程计做观测数据，实时更新IMU的偏差<code>bias</code>。同时，更新过的<code>bias</code>会传递到<code>IMU预积分器</code>。</p>
<h3 id="系统初始化">系统初始化</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-sysinit.png" alt="" /><figcaption>系统初始化流程</figcaption>
</figure>
<p>当接收到第一帧雷达里程计时，需要对系统做初始化操作。主要包括因子图、因子图优化器、两个预积分器的初始化。由于初始化操作需要将第一帧雷达里程计的位姿作为先验因子，因此不能在构造函数中初始化。</p>
<h3 id="判断是否应该重置因子图">判断是否应该重置因子图</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-reset.png" alt="" /><figcaption>重置系统</figcaption>
</figure>
<p>为了保证拥有足够的实时性（预积分模块需要与IMU频率保持一致），<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的预积分模块在因子图中里程计因子数量大于100时会重置因子图与优化器。操作主要是从当前的因子图优化器拿出最新结果，并当作先验因子构造新的因子图。</p>
<h3 id="对优化队列中imu原始数据进行积分">对优化队列中IMU原始数据进行积分</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-integraOpt.png" alt="" /><figcaption>积分优化队列</figcaption>
</figure>
<p>这里要重新回顾上文的<code>线程交互图</code>。零偏估计线程的主要目的就是为IMU里程计线程提供最新的<code>bias</code>估计，因此每当到达新的一帧雷达里程计，意味着有新的观测到达，<code>bias</code>就可以进行更新。于是需要对优化队列中在当前雷达里程计时间之前的IMU原始数据用IMU预积分器进行积分，然后构造IMU因子。将IMU因子和雷达里程计加入因子图优化，得出最新的<code>bias</code>估计。</p>
<h3 id="因子图优化">因子图优化</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-factorgraph.png" alt="" /><figcaption>因子图优化部分</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>可以使用IMU预积分器构造IMU因子。利用<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>可以用因子图优化出<code>速度</code>,<code>IMU bias</code>,<code>位姿</code>的估计。其中<code>IMU bias</code>是我们要重点关注的内容。</p>
<h3 id="传递优化结果">传递优化结果</h3>
<figure>
<img src="./imgs/Design-imuPreintegration-setBias.png" alt="" /><figcaption>传递优化结果</figcaption>
</figure>
<p>使用因子图优化出最新的IMU bias 之后，实际上还有优化后的位姿，这个位姿和IMU偏差会用来重置另外一个预积分器——<code>IMU预积分器</code>。IMU预积分器是在另一个回调函数中被主要使用，回顾<code>线程交互图</code>的下半部分和<code>模块流程图</code>的右侧流程。同时，设置完<code>IMU预积分器</code>之后，会将<code>imuQueImu</code>中剩余的其他IMU原始数据放入<code>IMU预积分器</code>做积分，这样<code>IMU预积分器</code>就一直保持最新状态，在<code>imuHandler</code>中可以实时积分并发布IMU里程计。</p>
<h2 id="imu里程计线程即imuhandler">IMU里程计线程——即imuHandler</h2>
<p>这个回调函数比起odometryHandler就要简单很多。这个回调函数的主要功能就只有两个：</p>
<p>1、不断地将新收到的IMU数据塞入两个放置IMU原始数据的队列——<code>线程交互图</code>中的imuQueOpt和imuQueImu； 2、使用<code>IMU预积分器</code>对收到的IMU数据做积分，并将结果作为IMU里程计发布。</p>
<p>主要流程如下图：</p>
<figure>
<img src="./imgs/Design-imuPreintegration-imuHandler.png" alt="" /><figcaption>IMU里程计线程</figcaption>
</figure>
<p>这个回调函数比较简单，就不再赘述。</p>
<h2 id="代码要点">代码要点</h2>
<h3 id="坐标系转换">坐标系转换</h3>
<p>IMU预积分模块中代码涉及到多次坐标系转换。主要是要明白IMU积分的原理和<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中坐标系的转换关系。关于坐标系有几个注意要点：</p>
<p><strong>1. 所有IMU原始数据都会先旋转到与雷达的坐标系朝向一致后再进行处理</strong></p>
<p>在<code>imuHandler</code>中每收到一个IMU数据就先旋转再存放。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L555-L556">code</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU数据旋转到lidar的旋转朝向</span></span><br><span class="line">sensor_msgs::msg::Imu thisImu = <span class="built_in">imuConverter</span>(*imu_raw);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存IMU数据</span></span><br><span class="line">imuQueOpt.<span class="built_in">push_back</span>(thisImu);</span><br><span class="line">imuQueImu.<span class="built_in">push_back</span>(thisImu);</span><br></pre></td></tr></table></figure>
<p><strong>2. 里程计都是对齐到雷达坐标系</strong></p>
<p>所有在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架中发布出来的里程计，无论是IMU里程计或者是雷达里程计，度量的都是雷达在地图坐标系下的位姿。但是在IMU预积分模块的零偏估计线程中，使用IMU数据做积分，又需要使用雷达里程计作为观测，两者要同时加入因子图中，所以必须统一两者的坐标系。IMU原始数据在上面提到的第一个注意要点已经旋转到对齐雷达的方向，两者之间还差一个平移。因此，在接收到雷达里程计时，会先平移到旋转后的IMU坐标系，最后再平移回来。 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L298-L300">雷达里程计平移到旋转后的IMU坐标系代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化因子图的prior状态</span></span><br><span class="line"><span class="comment">// 将雷达里程计位姿平移到IMU坐标系，只是做了平移</span></span><br><span class="line">prevPose_ = lidarPose.<span class="built_in">compose</span>(lidar2Imu);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L585-L587">将IMU里程计对齐到雷达坐标系代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU里程计完全对齐到雷达（剩下一个平移关系）</span></span><br><span class="line">gtsam::Pose3 imuPose = gtsam::<span class="built_in">Pose3</span>(currentState.<span class="built_in">quaternion</span>(), currentState.<span class="built_in">position</span>());</span><br><span class="line">gtsam::Pose3 lidarPose = imuPose.<span class="built_in">compose</span>(imu2Lidar);</span><br></pre></td></tr></table></figure>
<h3 id="时间同步">时间同步</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>框架中各个模块都是进行异步通信（ros topic），因此在每个模块里面都有几个队列保存数据，处理的时候再根据时间戳做同步。IMU预积分模块中有多个地方对数据做了时间戳同步。 比如在更新完<code>bias</code>之后，对IMU队列做积分时，会先抛弃早于最新的雷达里程计时间之前的数据。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L480-L486">code link</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样先做IMU数据队列和雷达里程计的时间同步</span></span><br><span class="line"><span class="type">double</span> lastImuQT = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!imuQueImu.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp) &lt; currentLidarOdomTime - <span class="type">sync_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lastImuQT = <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp);</span><br><span class="line">    imuQueImu.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（七）GTSAM快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-27 21:28:48" itemprop="dateCreated datePublished" datetime="2023-03-27T21:28:48+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 21:33:14" itemprop="dateModified" datetime="2023-04-20T21:33:14+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（七）GTSAM快速入门" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（七）GTSAM快速入门" href="/2023/03/27/lio_sam/gtsam-quickstart/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::0d35c30bd7aedf439c2d1184605769ac" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>其中的两大模块<code>ImuPreintegration</code>和<code>MapOptimization</code>都依赖了因子图优化框架——<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>。 为了确保本项目的自洽性以及后面章节讲解的展开，不介绍一下因子图后端优化算法似乎说不过去。但是笔者目前对因子图的原理还没有进行非常详细的推导，因此这部分 内容会偏向如何对<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>快速入门。当然，最快速的入门方式就是完整地阅读一遍<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的官方教程。这部分章节只是拙劣地进行知识的搬迁，当然不是直接将 <a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的教程直接翻译过来。本章节会介绍<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>快速入门的知识，同时讲解<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>提供的<code>examples</code>中跟<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>联系较为紧密的一两个，同时指明<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中的用法出处。 至少阅读完本章节后应该能够对因子图有基本的认识，并且能够看懂<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中对<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的使用</p>
<h2 id="slam后端图优化">SLAM后端——图优化</h2>
<h3 id="问题描述">问题描述</h3>
<p>让我们先回归问题本身。在SLAM中，我们可以拥有多个输入，我们的最终目的是获取一条最准确的轨迹，然后使用这条准确的轨迹实时构建地图。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中，我们有以下输入：</p>
<ol type="1">
<li>IMU数据；</li>
<li>点云数据；</li>
<li>GPS数据（可选）；</li>
<li>回环检测；</li>
</ol>
<p>我们的问题是如何使用这些数据计算出一条最准确的历史轨迹，使用该轨迹就可以将对应的点云投影到地图坐标系，以此来建立一个点云格式地图。 （PS：这只是SLAM的一个形式，就是优化出一条光滑准确的轨迹，这也是在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中使用的方法，因此本文以这种类型作为讲解）</p>
<h3 id="非线性优化">非线性优化</h3>
<p>在SLAM领域后端优化的一个分支是<code>滤波器方法</code>，主要以扩展卡尔曼滤波方法为主，采用隐马尔科夫假设，只保存上一次状态，并通过当前输入预测当前状态，偶尔通过观测修正状态。具体可见本博客的<a href="https://zeal-up.github.io/2023/03/13/kalman_filter/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%88%B0%E4%BA%92%E8%A1%A5%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/">卡尔曼滤波相关文章</a></p>
<p>目前的后端优化主要以各种非线性优化方法为主，把批量的位姿加入目标方程（projective function）一起优化，得到具有更好的全局性质的解。</p>
<p><span class="math display">\[
\mathbf{x}^* = \argmin_{\mathbf{x}}\mathbb{F}(\mathbf{x})
\]</span></p>
<p>其中，<span class="math inline">\(\mathbb{F}\)</span>是历史轨迹引入的各个误差之和</p>
<p><span class="math display">\[
\mathbb{F}(\mathbf{x}) = \sum\mathbf{e}(x_i,c_{ij},x_j)
\]</span></p>
<p><span class="math inline">\(x_i,x_j\)</span>是历史时刻的位姿，<span class="math inline">\(c_{ij}\)</span>是两者之间的约束（可以认为是观测或者输入）</p>
<p><strong>PS：再重申一句，SLAM后端体系很庞大，不是一篇文章能说清楚的，笔者目前也还没有这个能力。目前只求能够稍微讲清楚<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中是怎么被使用的即可。</strong></p>
<p>为了求解非线性方程在不同的SLAM任务中的特点，又发展出各种不同的优化方式，比如VIO中有Bundle Adjustment，有其他叫PoseGraph的，还有<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中使用的FactorGraph。 简单理解就是这些都是非线性方程和求解在不同的任务场景中的细分。后面有机会再单独列一篇文章讲解这些后端优化方法把。</p>
<figure>
<img src="./imgs/introToBA.png" alt="" /><figcaption>一图说明BA</figcaption>
</figure>
<h3 id="图优化">图优化</h3>
<p><strong>以下内容大量引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-repo/doc/gtsam.pdf</a></strong></p>
<p>为了批量优化历史位姿<span class="math inline">\(\mathbf{x} = \{x_0, x_1, x_2, ... x_i\}\)</span>，研究者将图论引入SLAM后端优化。每一个机器的位姿<span class="math inline">\(x_i\)</span>是图中的顶点；通过各种里程计计算，比如连续位姿间的IMU积分结果或者点云匹配结果，成为两个位姿<span class="math inline">\(x_i,x_j\)</span>之间的边；对于一些额外的观测，比如GPS数据，成为连接顶点的一元边（只有一端连接到顶点）。比如下图(引用自：<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>)</p>
<figure>
<img src="./imgs/egForFactorGraph.png" alt="" /><figcaption>FactorGraph</figcaption>
</figure>
<h2 id="gtsam">GTSAM</h2>
<p>GTSAM使用因子图（FactorGraph）作为通用的图问题描述框架，并为各种机器人任务提供实现好的优化算法API，使得研究者快速开发后端优化框架。</p>
<p><strong>图优化（GraphOptimization）vs. <a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中使用的因子图优化（FactorGraph Optimization）区别 vs. BA</strong></p>
<ol type="1">
<li><strong>图优化</strong>似乎一般指位姿图（PoseGraph）的优化，图中的顶点都是机器人的位姿</li>
<li><strong>BA</strong>(Bundle Adjustment)似乎一般指在视觉SLAM中对地标（Landmarks）和位姿同时优化的方法</li>
<li><strong>GTSAM</strong>的因子图除了能够构建位姿图之外，还可以将速度、偏差、IMU预积分等当作顶点和边加入图中。另外，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>框架实现了iSAM和iSAM2两个递增式优化器</li>
</ol>
<h3 id="重要概念">重要概念</h3>
<p><strong>变量（variables）</strong>：因子图中的每一个顶点是一个代求的变量。假设我们只需要求解每一个时刻的机器人姿态，那么每个顶点就是该时刻的机器人位姿，如上图中的<span class="math inline">\({X_1,X_2,X_3}\)</span></p>
<p><strong>值（values）</strong>：值是每个变量数值。在调用优化器对因子图做优化时，我们要先为每个变量设置初始值，优化结束后再从优化器中拿出每个变量优化后的值。</p>
<p><strong>因子（factors）</strong>：因子是因子图中的边，每条边都可以视为一个因子，每个因子又可以认为是一个约束。比如连续两个位姿之间可以由IMU计算出两个位姿的变换，该变换作为一条边加入因子图连接两个变量（<code>二元因子：binary factor</code>）；又或者在某个时刻有GPS数据输入，GPS数据是一个观测，也可以作为一个因子加入因子图，这时候GPS的边只有一端连接到变量（<code>一元因子：unary factor</code>）。</p>
<p><strong>因子图（factor graph）</strong>：因子图由顶点（变量）和因子（边）构成。</p>
<p><strong>优化器（Optimizer）</strong>：因子图只是建模了SLAM的历史位姿和输入与观测间的关系，如何求解这个因子图也就是如何设置变量使得整个图最符合所有的约束（误差最小）则需要用到优化器。除了最常见的求解非线性问题的<code>Gaussian-Newton</code>和<code>Levenberg-Marquardt</code>优化器之外，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>还实现了两个增量式优化器<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>,<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a></p>
<p><strong>键（Keys）</strong>：往因子图添加因子需要指定该因子连接到哪些变量。GTSAM中使用键来指明。一元因子需要指明其连接到第几个变量；二元因子需要指明其连接到哪两个变量。因子图中每个变量的键都应该是唯一的。为了方便在多种变量类型的情况下指明键，GTSAM提供<code>Symbols</code>来让用户方便生成不同变量类型的键值。（键不一定是连续的，但必须是唯一的）</p>
<h3 id="gtsam例子最小例子">GTSAM例子——最小例子</h3>
<p>本小节引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>—第2章 以构建并求解下面因子图为例</p>
<figure>
<img src="./imgs/gtsam-minExample.png" alt="" /><figcaption>GTSAM最小例子因子图示意</figcaption>
</figure>
<p>上图中<span class="math inline">\(x_1,x_2,x_3\)</span>为机器人三个时刻的位姿；<span class="math inline">\(f_0\)</span>为第一个时刻机器人位姿的观测；<span class="math inline">\(f_1,f_2\)</span>为时刻1-2和时刻2-3之间的里程计估计。<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/OdometryExample.cpp">代码</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个空的非线性因子图</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建先验因子，也就是图中的f_0</span></span><br><span class="line"><span class="comment">// 这里使用二维姿态（x,y,theta）简化问题</span></span><br><span class="line"><span class="function">Pose2 <span class="title">priorMean</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 高斯噪声，代表我们对该因子的不确定性</span></span><br><span class="line"><span class="keyword">auto</span> priorNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将先验因子加入因子图</span></span><br><span class="line"><span class="comment">// 其中的1表示该因子连接到第1个变量</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, priorMean, priorNoise));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建里程计因子，也就是图中的f_1,f_2</span></span><br><span class="line"><span class="comment">// 往前移动2米，y轴不便，theta不变</span></span><br><span class="line"><span class="function">Pose2 <span class="title">odometry</span><span class="params">(<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> odometryNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将里程计因子加入因子图</span></span><br><span class="line"><span class="comment">// 1,2代表该里程计约束是从变量1到变量2</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, <span class="number">2</span>, odometry, odometryNoise));</span><br><span class="line"><span class="comment">// 添加相同的因子到变量2和变量3之间</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">2</span>, <span class="number">3</span>, odometry, odometryNoise));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置各个变量的初始值</span></span><br><span class="line">Values initial;</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="built_in">Pose2</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="built_in">Pose2</span>(<span class="number">2.3</span>, <span class="number">0.1</span>, <span class="number">-0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="built_in">Pose2</span>(<span class="number">4.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用优化器并使用设定好的初始值对因子图优化</span></span><br><span class="line">Values result = <span class="built_in">LevenberMarquardtOptimizer</span>(graph, initial).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure>
<h3 id="gtsam例子imu预积分及imufactor">GTSAM例子——IMU预积分及ImuFactor</h3>
<p>在目前的SLAM，无论是VIO还是LIO，前端都需要IMU做积分得到一个位姿的初始估计。<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中实现了一个IMU预积分算法，并可以将其直接加入因子图中做优化。这在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>中也被使用到。 本例子引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/ImuFactorsExample2.cpp">GTSAM-repo/examples/ImuFactorExample2.cpp</a>，为了说明<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>中IMU预积分器及<code>ImuFactor</code>的用法，对该例子进行简化。最后构建出的因子图如下（为了可视化，人工调整了布局）：</p>
<figure>
<img src="./imgs/ImuFactorGraph.png" alt="" /><figcaption>使用ImuFactor构建的因子图</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，完整代码见下文</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IMU 预积分器</span></span><br><span class="line"><span class="comment">// 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span></span><br><span class="line"><span class="keyword">auto</span> params = PreintegrationParams::<span class="built_in">MakeSharedU</span>(kGravity);</span><br><span class="line">params-&gt;<span class="built_in">setAccelerometerCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setGyroscopeCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setIntegrationCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setUse2ndOrderCoriolis</span>(<span class="literal">false</span>);</span><br><span class="line">params-&gt;<span class="built_in">setOmegaCoriolis</span>(<span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 设置IMU预积分器</span></span><br><span class="line"><span class="function">PreintegratedImuMeasurements <span class="title">accum</span><span class="params">(params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个非线性因子图</span></span><br><span class="line">NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明因子图的初始值和优化结果</span></span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置位姿的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量x0的一元因子</span></span><br><span class="line"><span class="comment">// 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span></span><br><span class="line"><span class="keyword">auto</span> noise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(</span><br><span class="line">    (<span class="built_in">Vector</span>(<span class="number">6</span>) &lt;&lt; Vector3::<span class="built_in">Constant</span>(<span class="number">0.1</span>), Vector3::<span class="built_in">Constant</span>(<span class="number">0.3</span>)).<span class="built_in">finished</span>());</span><br><span class="line"><span class="comment">// 将位姿的先验因子加入因子图中</span></span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0, noise);</span><br><span class="line"><span class="comment">// 将位姿0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置IMU偏差的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量b0的一元因子</span></span><br><span class="line">Key biasKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> biasnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(Vector6::<span class="built_in">Constant</span>(<span class="number">0.1</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>(), biasnoise);</span><br><span class="line"><span class="comment">// 将IMU偏差b0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置速度的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量v0的一元因子</span></span><br><span class="line"><span class="comment">// 这里设置初始速度为0：Vector3(0,0,0)</span></span><br><span class="line"><span class="keyword">auto</span> velnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), velnoise);</span><br><span class="line"><span class="comment">// 将速度v0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于机器人的所有位姿时刻（关键帧）</span></span><br><span class="line"><span class="keyword">for</span> (i in N_steps)</span><br><span class="line">&#123;</span><br><span class="line">  biasKey++;</span><br><span class="line">  Symbol b1 = biasKey - <span class="number">1</span>;</span><br><span class="line">  Symbol b2 = biasKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置i时刻的位姿初始值</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(i), pose_i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于两个时刻之间的所有IMU数据进行积分</span></span><br><span class="line">  <span class="keyword">for</span> (j in N_imu_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    accum.<span class="built_in">integrateMeasurement</span>(measuredAcc, measuredOmega, <span class="type">delta_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用预积分器构建IMU因子，并加入因子图中</span></span><br><span class="line">  <span class="comment">// IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span></span><br><span class="line">  <span class="function">ImuFactor <span class="title">imufac</span><span class="params">(X(i - <span class="number">1</span>), V(i - <span class="number">1</span>), X(i), V(i), biasKey, accum)</span></span>;</span><br><span class="line">  newgraph.<span class="built_in">add</span>(imufac);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加两个时刻之间IMU偏差因子</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::<span class="built_in">ConstantBias</span>(), cov);</span><br><span class="line">  newgraph.<span class="built_in">add</span>(f);</span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(i), linear_velocity_vector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重值IMU预积分器</span></span><br><span class="line">  accum.<span class="built_in">resetIntegration</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用LM优化器对因子图进行优化并获取优化结果</span></span><br><span class="line">result = <span class="built_in">LevenbergMarquardtOptimizer</span>(newgraph, initialEstimate).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure>
<details class="note info no-icon"><summary><p>IMU预积分及IMU因子完整代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre>
</td>
<td class="code">
<pre><span class="line">/**</span><br><span class="line"> * @file ImuFactorExample2</span><br><span class="line"> * @brief Test example for using GTSAM ImuFactor and ImuCombinedFactor with ISAM2. Simplify and add graphviz by Zeal</span><br><span class="line"> * @author Robert Truax</span><br><span class="line"> * @author Zeal</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;gtsam/geometry/PinholeCamera.h&gt;</span><br><span class="line">#include &lt;gtsam/geometry/Cal3_S2.h&gt;</span><br><span class="line">#include &lt;gtsam/inference/Symbol.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuBias.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuFactor.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/Scenario.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/ISAM2.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span><br><span class="line">#include &lt;gtsam/slam/BetweenFactor.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace gtsam;</span><br><span class="line"></span><br><span class="line">// Shorthand for velocity and pose variables</span><br><span class="line">using symbol_shorthand::V;</span><br><span class="line">using symbol_shorthand::X;</span><br><span class="line"></span><br><span class="line">const double kGravity = 9.81;</span><br><span class="line"></span><br><span class="line">/* ************************************************************************* */</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // 起点</span><br><span class="line">  Pose3 pose_0(Rot3::Rodrigues(0, 0, 0), Point3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // 设置一个姿态仿真器，姿态沿着y轴以5m/s的速度前进，没有角度变化</span><br><span class="line">  Vector3 angular_velocity_vector(0, 0, 0);</span><br><span class="line">  Vector3 linear_velocity_vector(0, 5, 0);</span><br><span class="line">  auto scenario = ConstantTwistScenario(angular_velocity_vector,</span><br><span class="line">                                        linear_velocity_vector, pose_0);</span><br><span class="line">  // 设置仿真步长为1s</span><br><span class="line">  double delta_t = 1.0;</span><br><span class="line"></span><br><span class="line">  // 设置一个非线性因子图</span><br><span class="line">  NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line">  // 声明因子图的初始值和优化结果</span><br><span class="line">  Values initialEstimate, result;</span><br><span class="line"></span><br><span class="line">  // 设置位姿的先验因子</span><br><span class="line">  // 对应到上图中连接到变量x0的一元因子</span><br><span class="line">  // 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span><br><span class="line">  auto noise = noiseModel::Diagonal::Sigmas(</span><br><span class="line">      (Vector(6) &lt;&lt; Vector3::Constant(0.1), Vector3::Constant(0.3)).finished());</span><br><span class="line">  // 将位姿的先验因子加入因子图中</span><br><span class="line">  newgraph.addPrior(X(0), pose_0, noise);</span><br><span class="line">  // 将位姿0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(X(0), pose_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 设置IMU偏差的先验因子</span><br><span class="line">  // 对应到上图中连接到变量b0的一元因子</span><br><span class="line">  Key biasKey = Symbol(&#x27;b&#x27;, 0);</span><br><span class="line">  auto biasnoise = noiseModel::Diagonal::Sigmas(Vector6::Constant(0.1));</span><br><span class="line">  newgraph.addPrior(biasKey, imuBias::ConstantBias(), biasnoise);</span><br><span class="line">  // 将IMU偏差b0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">  </span><br><span class="line">  // 设置速度的先验因子</span><br><span class="line">  // 对应到上图中连接到变量v0的一元因子</span><br><span class="line">  // 这里设置初始速度为0：Vector3(0,0,0)</span><br><span class="line">  auto velnoise = noiseModel::Diagonal::Sigmas(Vector3(0.01, 0.01, 0.01));</span><br><span class="line">  newgraph.addPrior(V(0), Vector3(0,0,0), velnoise);</span><br><span class="line">  // 将速度v0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(V(0), Vector3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // IMU 预积分器</span><br><span class="line">  // 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span><br><span class="line">  auto params = PreintegrationParams::MakeSharedU(kGravity);</span><br><span class="line">  params-&gt;setAccelerometerCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setGyroscopeCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setIntegrationCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setUse2ndOrderCoriolis(false);</span><br><span class="line">  params-&gt;setOmegaCoriolis(Vector3(0, 0, 0));</span><br><span class="line">  // 设置IMU预积分器</span><br><span class="line">  PreintegratedImuMeasurements accum(params);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 模仿机器人在运动，这里一共有3个位姿节点0,1,2</span><br><span class="line">  // 在运动过程中模拟IMU预积分，并将IMU因子、IMU偏差因子加入因子图中</span><br><span class="line">  for (size_t i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">    double t = i * delta_t;</span><br><span class="line">    if (i &gt; 0) &#123;  // 设置位姿的初始值，这里是错误示范，使用真值作为初始值设置</span><br><span class="line">      auto pose_i = scenario.pose(t);</span><br><span class="line">      initialEstimate.insert(X(i), pose_i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加IMU因子和IMU偏差因子</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">      // 周期性添加IMU的偏差因子；IMU的偏差需要用其他方式计算，也可以使用离线标定的参数（一般不会）</span><br><span class="line">      if (i % 2 == 0) &#123;</span><br><span class="line">        // b1是上一次的IMU偏差变量的键值；b2是本次IMU偏差的键值</span><br><span class="line">        biasKey++;</span><br><span class="line">        Symbol b1 = biasKey - 1;</span><br><span class="line">        Symbol b2 = biasKey;</span><br><span class="line">        // 添加两个IMU偏差变量之间的二元因子</span><br><span class="line">        Vector6 covvec;</span><br><span class="line">        covvec &lt;&lt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1;</span><br><span class="line">        auto cov = noiseModel::Diagonal::Variances(covvec);</span><br><span class="line">        auto f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::ConstantBias(), cov);</span><br><span class="line">        newgraph.add(f);</span><br><span class="line">        // 将当前的IMU偏差变量的初始估计加入初始值集合</span><br><span class="line">        initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 这部分才是预积分器进行积分的地方</span><br><span class="line">      // 每次积分接收加速度、角速度以及间隔时间delta_t</span><br><span class="line">      Vector3 measuredAcc = scenario.acceleration_b(t);</span><br><span class="line">      Vector3 measuredOmega = scenario.omega_b(t);</span><br><span class="line">      accum.integrateMeasurement(measuredAcc, measuredOmega, delta_t);</span><br><span class="line"></span><br><span class="line">      // 使用预积分器构建IMU因子，并加入因子图中</span><br><span class="line">      // IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span><br><span class="line">      ImuFactor imufac(X(i - 1), V(i - 1), X(i), V(i), biasKey, accum);</span><br><span class="line">      newgraph.add(imufac);</span><br><span class="line"></span><br><span class="line">      // 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span><br><span class="line">      initialEstimate.insert(V(i), linear_velocity_vector);</span><br><span class="line">      // 重值IMU预积分器</span><br><span class="line">      accum.resetIntegration();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 使用初始值保存因子图</span><br><span class="line">  newgraph.saveGraph(&quot;ImuFactorsExample2_graphviz.dot&quot;, initialEstimate);</span><br><span class="line">  // 打印到命令行</span><br><span class="line">  newgraph.dot(cout, result);</span><br><span class="line"></span><br><span class="line">  // 调用LM优化器对因子图进行优化并获取优化结果</span><br><span class="line">  result = LevenbergMarquardtOptimizer(newgraph, initialEstimate).optimize();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* ************************************************************************* */</span><br><span class="line"></span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<h3 id="gtsam例子递增式优化">GTSAM例子——递增式优化</h3>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>不仅内置了<code>Gaussian-Newton</code>和<code>Leverberg-Marquat</code>两个常见的非线性优化器，还实现了<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>和<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a>两个递增式的优化器。 递增式优化器更符合SLAM中常见的使用方式，也就是持续加入新的位姿和约束，并持续进行优化。</p>
<p>这部分内容可以参考<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>——第7章</p>
<p><a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/VisualISAM2Example.cpp">example/VisualISAM2Example.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置iSAM2优化器</span></span><br><span class="line"><span class="function">ISAM2 <span class="title">isam</span><span class="params">(parameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置因子图和初始值</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; poses.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; relations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose3&gt;(i, j))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加初始值到初始估计集合</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>,i), initial_x[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将因子图加入优化器</span></span><br><span class="line">  isam.<span class="built_in">update</span>(graph, initialEstimate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空当前因子图和初始值</span></span><br><span class="line">  <span class="comment">// 因子图已经加入优化器，因此需要清空为下一次因子图做准备</span></span><br><span class="line">  graph.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">  initialEstimate.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gtsam学习路径">GTSAM学习路径</h2>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>对整个SLAM后端问题都封装得很好，因此可以让我们在不了解优化细节的情况下也可以构建自己的优化算法。除了对后端优化和图优化这些知识掌握外，<a target="_blank" rel="noopener" href="https://gtsam.org/">GTSAM</a>的学习主要还是要<code>学以致用</code>， 这里只是简单列出笔者觉得比较合适的资料阅读和学习顺序。</p>
<ol type="1">
<li>本文</li>
<li>GTSAM仓库下<code>doc</code>文件夹中的<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">gtsam.pdf</a></li>
<li>GTSAM仓库下<code>examples</code>文件夹中的一些例子，主要是对照上面的文档以及本文出现的例子进行阅读运行</li>
<li>本项目博客中关于<code>ImuPreintegration</code>和<code>MapOptimization</code>的讲解</li>
<li>本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">spl</a>中<code>src/mapOptimization.cpp</code>和<code>src/imuPreintegration.cpp</code>代码</li>
</ol>
<h2 id="资料参考">资料参考</h2>
<ol type="1">
<li>对目前各个图优化框架（g2o,GTSAM,ceres,SE-Sync）等做统一分析的综述性论文（强烈建议）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://lamor.fer.hr/images/50036607/2021-ajuric-comparison-mipro.pdf">A Comparison of Graph OptimizationApproaches for Pose Estimation in SLAM</a></p>
<ol start="2" type="1">
<li>Introduction to Bundle Adjustment, ppt</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://vincentqin.gitee.io/blogresource-3/slam-summer-courses-CADCG-Lab/BA-haominLiu.pdf">Bundle Adjustment</a></p>
<ol start="3" type="1">
<li>对基于图的SLAM后端优化算法的讲解，对SLAM的后端问题做比较正式的描述，接近2000引用</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf">A Tutorial on Graph-Based SLAM</a></p>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（六）特征提取模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 20:03:12" itemprop="dateCreated datePublished" datetime="2023-03-22T20:03:12+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 21:17:55" itemprop="dateModified" datetime="2023-04-20T21:17:55+08:00">2023-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（六）特征提取模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（六）特征提取模块" href="/2023/03/22/lio_sam/featureExtraction-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::e84bd67344741c4da21c259e3e444c5d" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="点云特征提取">点云特征提取</h2>
<figure>
<img src="./imgs/Design-Pipelines-feature.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>、<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的做法，从原始点云中提取出边缘点和平面点。边缘点和平面点被下游模块用来做点云匹配和构建地图。 特征提取模块是比较简单的模块，只监听来自<code>ImageProjection</code>发布出来的去畸变后点云，同时将提取出的特征点云发布出去。这里有几点需要注意：</p>
<ol type="1">
<li>特征点的提取根据点的平滑度，而平滑度则通过每个点与周围点距离的平均值做近似</li>
<li>实际上在提取完边缘点和平面点之后，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>在代码里又把所有非边缘点的点都加入了平面点集合。这是比较奇怪的地方。从这里看出也许特征提取也不是必要的， 因为平面点已经包含了大部分的点云。事实上，在Github的一个仓库<a target="_blank" rel="noopener" href="https://github.com/YJZLuckyBoy/liorf">liorf</a>中，就将特征提取模块去掉。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该段中除了角点之外的点加入平面点集合</span></span><br><span class="line"><span class="comment">// ！！！ 这点让步骤2感觉是多余的，最终的结果可能只是原始点云降采样，可能特征点提取也是没有必要的！！！</span></span><br><span class="line"><span class="comment">// cloudLabel标识该点的性质，-1为平面点，0为非特征点，1为边缘点。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        surfaceCloudScan-&gt;<span class="built_in">push_back</span>(extractedCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特征点提取原理">特征点提取原理</h2>
<p>关于特征点提取部分<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>的论文基本略过，因为跟<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>和<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的做法基本相同。本文对算法中点云特征点提取做详细介绍。</p>
<h3 id="转换到rangemat">转换到RangeMat</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>的做法，先把三维点全部投影到二维图片，图像像素保存每个点距离原点的距离，称做<code>RangeMat</code>，<code>RangeMat</code>是规则的，每一行代表一条激光线束扫射360度所产生的点，因此后面用这个<code>RangeMat</code>做特征提取更快速更简单。 PS：这部分是在<code>ImageProjection</code>就已经处理好，并且<code>RangeMat</code>也被展开成一维向量存储。</p>
<p>有一点要注意，在一些激光雷达中，<code>RangeMat</code>是可以直接从雷达驱动提供的接口拿到，但并不是所有雷达都提供这样的API。据笔者的了解，ouster的雷达驱动API就提供直接获取<code>RangeMat</code>的功能。</p>
<h3 id="平滑度估计">平滑度估计</h3>
<p>特征点提取通过每个点的平滑度来提取，平滑度高于某个阈值的认为是边缘点；平滑度小于某个阈值的认为是平面点。 而平滑度的估计则通过每一个点在该激光线成像的前后几个点的平均距离代替。 我们令时间<span class="math inline">\(t\)</span>的点云为<span class="math inline">\(P_t = \{p_i, i \in |P_t|\}\)</span>，同时我们可以根据每个点的坐标算出每个点距离原点的距离<span class="math inline">\(r_i\)</span>，对于每个点，我们取其同一条激光线上前后5个点构成集合<span class="math inline">\(S\)</span>，则，点<span class="math inline">\(p_i\)</span>的平滑度可以这样计算：</p>
<p><span class="math display">\[
c = \frac{1}{|S|\cdot||r_i||}\left|\left|\sum_{j\in S,j\neq i}(r_j-r_i)\right|\right|
\]</span></p>
<h3 id="分段提取及特征点数量数量限制">分段提取及特征点数量数量限制</h3>
<p>为了让特征点分布更均匀，采用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>，将整个360的图像在水平方向分成6个子图像，在每个子图像中进行特征点提取。并且，对于每一个子图像中的每一条激光线束，会限制边缘点数量不超过20个，平面点的数量则没有限制。</p>
<h3 id="特殊情况">特殊情况</h3>
<p><strong>有3种特殊情况不能将该点设置为边缘点：</strong></p>
<ol type="1">
<li>当一个点被选择为特征点，则把该点左右5个点都排除在特征点选取范围</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对该角点左右各5个点，如果两点之间的列索引差距小于10，则抛弃周围的点，避免重复对同一块区域提取角点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>当该点可能是由于遮挡导致被选择为边缘点</li>
</ol>
<figure>
<img src="./imgs/illegal_feature_point.png" alt="" /><figcaption>不合格的特征点(from LOAM)</figcaption>
</figure>
<p>如上图（b）所示，点A是由于被平面遮挡而产生的边缘点，当视角变化后，点A就不再是边缘点。 这个逻辑的判断也是通过点与其周围点的range差距判断。如果是由于遮挡产生的边缘点，则其与左边或者右边会存在距离的突变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// featureExtraction.cpp&gt;markOccludedPoints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markOccludedPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cloudSize = extractedCloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 标记被遮挡的点和与激光束平行的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记被遮挡的点</span></span><br><span class="line">        <span class="type">float</span> depth1 = cloudInfo.point_range[i];</span><br><span class="line">        <span class="type">float</span> depth2 = cloudInfo.point_range[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[i+<span class="number">1</span>] - cloudInfo.point_col_ind[i]));</span><br><span class="line">        <span class="comment">// 两个点的列索引相差10个像素之内，认为是同一块区域</span></span><br><span class="line">        <span class="keyword">if</span> (columnDiff &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前点距离大于右点距离0.3米，认为当前点及左边6个点无效</span></span><br><span class="line">            <span class="keyword">if</span> (depth1 - depth2 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前点距离小于右边点距离0.3米，认为右边6个点无效</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (depth2 - depth1 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记平行与激光束的点</span></span><br><span class="line">        <span class="type">float</span> diff1 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i<span class="number">-1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="type">float</span> diff2 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i+<span class="number">1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="comment">// 当前点与左右两点的距离均大于阈值，认为当前点是处于平行面的点</span></span><br><span class="line">        <span class="keyword">if</span> (diff1 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i] &amp;&amp; diff2 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i])</span><br><span class="line">            cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>当点处于跟激光线平行的平面上时，也可能被认为时边缘点，也需要排除 如上图中的(a)所示，点B位于一个跟激光线较为平行的面上，激光线扫过去，前后几个点的距离差距会很大，因此在处理时可能会被认为是边缘点。这些点也需要做标记，不要设置为边缘点。</li>
</ol>
<h2 id="特征点提取流程">特征点提取流程</h2>
<p>由于这部分代码和原理都比较简单，这里只说一下特征提取的流程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief</span></span><br><span class="line"><span class="comment">* cloudInfo话题的回调函数，这个模块的功能都是顺序进行</span></span><br><span class="line"><span class="comment">* 1. 接收到从imageProjection中发布出的一个去畸变点云信息cloudInfo(自定义格式)</span></span><br><span class="line"><span class="comment">* 2. 对每个点计算曲率。计算时是计算周围点的平均距离用来作为曲率的替代</span></span><br><span class="line"><span class="comment">* 3. 标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="comment">* 4. 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="comment">* 5. 整合信息，发布完整数据包</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param msgIn 从去畸变模块接受的数据包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 缓存全局变量，后面的函数可以直接读取cloudInfo和cloudHeader进行处理</span></span><br><span class="line">cloudInfo = *msgIn;</span><br><span class="line">cloudHeader = msgIn-&gt;header;</span><br><span class="line"><span class="comment">// 把ros2 PointCloud2转成PCL格式，方便后面处理</span></span><br><span class="line">pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_deskewed, *extractedCloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点云每一个点曲率</span></span><br><span class="line"><span class="built_in">calculateSmoothness</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="built_in">markOccludedPoints</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="built_in">extractFeatures</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合信息，发布完整数据包</span></span><br><span class="line"><span class="built_in">publishFeatureCloud</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/imageProjection-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——（五）点云去畸变模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 15:55:36" itemprop="dateCreated datePublished" datetime="2023-03-22T15:55:36+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-05 15:19:27" itemprop="dateModified" datetime="2023-07-05T15:19:27+08:00">2023-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/imageProjection-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——（五）点云去畸变模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——（五）点云去畸变模块" href="/2023/03/22/lio_sam/imageProjection-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::92a09cadad63fefbcbc8404aeb27c1f1" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<figure>
<img src="./imgs/Design-Pipelines-image.png" alt="" /><figcaption>Simple-LIO-SAM总体流程图</figcaption>
</figure>
<p>点云去畸变模块（imageProjection.cpp文件，文件命名应该是继承了<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM</a>，其实我觉得应该叫做数据预处理模块更合适）主要有以下几个作用</p>
<ol type="1">
<li>去除激光雷达点云的运动畸变</li>
<li>检索每一帧点云对应的IMU输出角度、IMU里程计位姿（发布自ImuPreintegration），以便MapOptimization模块用这些信息作为该帧点云的初始位姿</li>
<li>转换点云格式，计算<code>Range</code>字段，方便特征提取模块进行边缘点、平面点提取</li>
</ol>
<p>从<code>总体流程图</code>不难看出，点云去畸变模块是整个算法框架的入口。点云去畸变模块的总体流程如下图：</p>
<figure>
<img src="./imgs/Design-imageProjection-pipeline.png" alt="" /><figcaption>点云去畸变模块流程图</figcaption>
</figure>
<h2 id="消息订阅及发布">消息订阅及发布</h2>
<figure>
<img src="./imgs/Design-Node%26%26Topics-imageProjection.png" alt="" /><figcaption>去畸变模块的消息订阅及发布</figcaption>
</figure>
<p>从上图可以看到，这个模块订阅点云和IMU的原始数据，输出一个以<code>CloudInfo</code>格式的topic。下面详细讲解<code>CloudInfo</code>这个数据格式。</p>
<h2 id="cloudinfo数据类型">CloudInfo数据类型</h2>
<p>经过去畸变的点云通过算法自定义的数据格式<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/main/msg/CloudInfo.msg">Simple-LIO-SAM/msg/CloudInfo.msg</a>发布；特征提取模块也是将特征点放入这个自定义数据格式发布。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cloud Info</span></span><br><span class="line"><span class="string">std_msgs/Header</span> <span class="string">header</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在进行点云去畸变时，把range数据展开成一维向量</span></span><br><span class="line"><span class="comment"># ring代表第几条激光线数，比如16线的激光雷达有16个ring</span></span><br><span class="line"><span class="comment"># start_ring_index记录第一个ring在一维向量中的起始索引</span></span><br><span class="line"><span class="comment"># end_ring_index记录第一个ring在一维向量中的结束索引</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">start_ring_index</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">end_ring_index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录一维的Range数据中每一个点在原始range图片中属于那一个列</span></span><br><span class="line"><span class="string">int32[]</span>  <span class="string">point_col_ind</span> <span class="comment"># point column index in range image</span></span><br><span class="line"><span class="comment"># 所有点的range数值，展开为一维数组</span></span><br><span class="line"><span class="string">float32[]</span> <span class="string">point_range</span> <span class="comment"># point range </span></span><br><span class="line"></span><br><span class="line"><span class="string">int64</span> <span class="string">imu_available</span></span><br><span class="line"><span class="string">int64</span> <span class="string">odom_available</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attitude for LOAM initialization</span></span><br><span class="line"><span class="comment"># 从IMU原始数据获取的roll、pitch、yaw角初值</span></span><br><span class="line"><span class="comment"># 当上面的imu_avaliable为true，odom_available为false的时候，会被用来</span></span><br><span class="line"><span class="comment"># 当作这一帧点云的初值</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_roll_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_pitch_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_yaw_init</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial guess from imu pre-integration</span></span><br><span class="line"><span class="comment"># 从imuPreintegration，IMU预积分模块获取的与这一帧雷达最接近的初始位姿</span></span><br><span class="line"><span class="comment"># 当上面的odom_available标签被置为true的时候会被使用</span></span><br><span class="line"><span class="comment"># 优先级比imu_xxx_init高</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_x</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_y</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_z</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_roll</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_pitch</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_yaw</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Point cloud messages</span></span><br><span class="line"><span class="comment"># 去畸变后的原始点云</span></span><br><span class="line"><span class="comment"># 在经过imageProjection模块后，这个数据字段被填充。在经过特征提取之后这个字段被清空</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_deskewed</span> </span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云边缘点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_corner</span></span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云平面点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_surface</span></span><br></pre></td></tr></table></figure>
<p>这里主要是前面几个数组类型会比较难理解，主要是要知道在去畸变模块中，将所有点的<code>range</code>信息（也就是点距离雷达的距离）拉成一个一维的数组，即<code>float32[] point_range</code>。 同时，<code>cloud_deskewed</code>里存储的是去完畸变后的点云，里面点的顺序与<code>point_range</code>的顺序是一样的。</p>
<p><code>cloud_corner</code>和<code>cloud_surface</code>两个字段在<code>imageProjection</code>模块中没有被放置数据。特征提取模块会将边缘点、平面点放置在这两个字段中，同时将<code>cloud_deskewed</code>字段清空。</p>
<h2 id="功能解读">功能解读</h2>
<h3 id="imu及imu里程计处理">IMU及IMU里程计处理</h3>
<p>ImageProjection监听IMU原始数据与从<code>ImuPreintegration</code>（后面会详细讲解这个模块）发布出来的IMU里程计数据，分别由两个回调函数处理，对于IMU原始数据，只是简单地将其旋转到雷达坐标系后塞入缓存队列。 对于IMU历程计，则是直接塞入缓存队列。</p>
<h3 id="角度插值">角度插值</h3>
<p>由于雷达点的时间戳与IMU的时间戳不可能是一一对齐，因此在使用雷达点的时间戳检索IMU的积分结果的时候，还需要进行一下插值，获取该雷达点对应的位姿</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/89dafd75519a5c8c1e88187f40f3378352e0c7c5/src/imageProjection.cpp#L683-L699">代码位置</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imuPointerFront为找到的IMU去畸变信息的索引</span></span><br><span class="line"><span class="comment">// 引起if条件主要是因为可能最后一个IMU的时间戳依然是小于雷达点的时间戳，</span></span><br><span class="line"><span class="comment">// 这个时候就直接使用最后一个IMU对应的角度</span></span><br><span class="line"><span class="keyword">if</span> (pointTime &gt; imuTime[imuPointerFront] || imuPointerFront == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    *rotXCur = imuRotX[imuPointerFront];</span><br><span class="line">    *rotYCur = imuRotY[imuPointerFront];</span><br><span class="line">    *rotZCur = imuRotZ[imuPointerFront];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else 部分根据时间戳比例进行角度插值，计算出更准确的旋转</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> imuPointerBack = imuPointerFront - <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> ratioFront = (pointTime - imuTime[imuPointerBack]) / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);</span><br><span class="line">    <span class="type">double</span> ratioBack = (imuTime[imuPointerFront] - pointTime) / (imuTime[imuPointerFront] - imuTime[imuPointerBack]);</span><br><span class="line">    *rotXCur = imuRotX[imuPointerFront] * ratioFront + imuRotX[imuPointerBack] * ratioBack;</span><br><span class="line">    *rotYCur = imuRotY[imuPointerFront] * ratioFront + imuRotY[imuPointerBack] * ratioBack;</span><br><span class="line">    *rotZCur = imuRotZ[imuPointerFront] * ratioFront + imuRotZ[imuPointerBack] * ratioBack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="去畸变流程">去畸变流程</h3>
<p>一句话说明点云运动畸变校正：根据每一帧点云中每一个点的时间戳，计算该点到该帧点云起始点的旋转平移变换，将每一个点变换到起始点的坐标系。</p>
<p>要注意的是，算法中对运动畸变校正只做了旋转校正，没有做平移校正。</p>
<p>去畸变流程发生在点云的回调函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection::cloudHandler</span></span><br><span class="line"><span class="comment">/** 原始雷达点云话题的回调函数，实际上真正做点云处理的函数</span></span><br><span class="line"><span class="comment">    * 实际处理流程是单线程流水线式处理，这个函数后面的所有函数都是为这个函数服务，因此需要了解</span></span><br><span class="line"><span class="comment">    * 点云去畸变的流程。</span></span><br><span class="line"><span class="comment">    * 订阅原始lidar数据</span></span><br><span class="line"><span class="comment">    * 1、转换点云为统一格式，提取点云信息</span></span><br><span class="line"><span class="comment">    *   1）添加一帧激光点云到队列，取出最早一帧作为当前帧</span></span><br><span class="line"><span class="comment">    *   2) 计算起止时间戳，检查数据有效性</span></span><br><span class="line"><span class="comment">    * 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line"><span class="comment">    *   imu数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu数据，初始时刻对应imu的姿态角RPY设为当前帧的初始姿态角</span></span><br><span class="line"><span class="comment">    *   2) 用角速度、时间积分，计算每一时刻相对于初始时刻的旋转量，初始时刻旋转设为0</span></span><br><span class="line"><span class="comment">    *   imu里程计数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu里程计数据，初始时刻对应imu里程计设为当前帧的初始位姿</span></span><br><span class="line"><span class="comment">    *   2) 用起始、终止时刻对应imu里程计，计算相对位姿变换，保存平移增量</span></span><br><span class="line"><span class="comment">    * 3、当前帧激光点云运动畸变校正</span></span><br><span class="line"><span class="comment">    *   1) 检查激光点距离、扫描线是否合规</span></span><br><span class="line"><span class="comment">    *   2) 激光运动畸变校正，保存激光点</span></span><br><span class="line"><span class="comment">    * 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line"><span class="comment">    * 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line"><span class="comment">    * 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cloudHandler</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::PointCloud2::SharedPtr laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、提取、转换点云为统一格式</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cachePointCloud</span>(laserCloudMsg))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">deskewInfo</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、当前帧激光点云运动畸变校正</span></span><br><span class="line">    <span class="built_in">projectPointCloud</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line">    <span class="built_in">cloudExtraction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line">    <span class="built_in">publishClouds</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line">    <span class="built_in">resetParameters</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提取、转换点云为统一格式</li>
</ul>
<figure>
<img src="./imgs/Design-imageProjection-cachePointCloud.png" alt="" /><figcaption>提取、转换点云为统一格式</figcaption>
</figure>
<ul>
<li>提取去畸变信息</li>
</ul>
<figure>
<img src="./imgs/Design-imageProjection-deskewInfo.png" alt="" /><figcaption>提取去畸变信息</figcaption>
</figure>
<p>这里有几点要注意</p>
<ol type="1">
<li><p>从IMU原始数据计算每一时刻的位姿变换用的是近似算法（因为一帧点云成像时间很短，一般小于100ms） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对角度做积分</span></span><br><span class="line"><span class="comment">// 再次强调，对角速度的积分不是简单的角速度乘以间隔时间</span></span><br><span class="line"><span class="comment">// 关于角速度的积分公式可以查阅：https://zhuanlan.zhihu.com/p/591613108</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> timeDiff;</span><br><span class="line">timeDiff = currentImuTime - imuTime[imuPointerCur<span class="number">-1</span>];</span><br><span class="line">imuRotX[imuPointerCur] = imuRotX[imuPointerCur<span class="number">-1</span>] + angular_x * timeDiff;</span><br><span class="line">imuRotY[imuPointerCur] = imuRotY[imuPointerCur<span class="number">-1</span>] + angular_y * timeDiff;</span><br><span class="line">imuRotZ[imuPointerCur] = imuRotZ[imuPointerCur<span class="number">-1</span>] + angular_z * timeDiff;</span><br><span class="line">imuTime[imuPointerCur] = currentImuTime;</span><br><span class="line">++imuPointerCur;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对于速度较低，角度变化不那么剧烈的行驶系统，即使不做点云畸变校正也没有问题</p></li>
</ol>
<ul>
<li>对点云做去畸变处理</li>
</ul>
<figure>
<img src="./imgs/Design-imageProjection-projectPointCloud.png" alt="" /><figcaption>对点云做去畸变处理</figcaption>
</figure>
<ul>
<li>提取有效点云并集合其他信息</li>
</ul>
<p>这里主要是将经过去畸变处理后记录下来的有效点进行数据转换，并把各种信息填入准备发布的<code>cloud_info</code>消息中。</p>
<ul>
<li>发布点云</li>
</ul>
<h2 id="本项目所有章节">本项目所有章节</h2>
<ol type="1">
<li><a href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">Simple-LIO-SAM——（一）项目简介</a></li>
<li><a href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">Simple-LIO-SAM——（二）环境搭建与运行</a></li>
<li><a href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">Simple-LIO-SAM——（三）总体流程认识</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">Simple-LIO-SAM——（四）utility文件解读</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">Simple-LIO-SAM——（五）点云去畸变模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">Simple-LIO-SAM——（六）特征提取模块</a></li>
<li><a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——（七）GTSAM快速入门</a></li>
<li><a href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">Simple-LIO-SAM——（八）IMU预积分模块</a></li>
<li><a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——（九）点云匹配算法详解</a></li>
<li><a href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">Simple-LIO-SAM——（十）后端优化模块详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/archives/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"covS4Q3Q0SaMRjqI2VomagVm-gzGzoHsz","app_key":"iK7kdlu4InjORoPr3oksi1IM","server_url":"https://covs4q3q.lc-cn-n1-shared.com","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywzGuJ0w","appkey":"7c4a236bb42c7db38424a76bf68ccf99","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
