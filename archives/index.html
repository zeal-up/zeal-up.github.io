<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeal-up.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录及分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeal&#39;s Blog">
<meta property="og:url" content="https://zeal-up.github.io/archives/index.html">
<meta property="og:site_name" content="Zeal&#39;s Blog">
<meta property="og:description" content="学习记录及分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeal">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeal-up.github.io/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeal's Blog</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeal's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习～天天向上～</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zeal</p>
  <div class="site-description" itemprop="description">学习记录及分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——IMU预积分模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-30 20:55:54" itemprop="dateCreated datePublished" datetime="2023-03-30T20:55:54+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-31 22:32:13" itemprop="dateModified" datetime="2023-03-31T22:32:13+08:00">2023-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——IMU预积分模块" href="/2023/03/30/lio_sam/imuPreintegration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::447e7d053e8cf00fca42d617e062a049" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><img src="./imgs/Design-Pipelines-IMU.png" alt="Pipelines-ImuPreintegration" /> IMU预积分模块无论在VIO或者LIO中都是一个非常重要的模块。VIO或者LIO中的<code>I</code>，也就是<code>Inertial</code>指的是惯性，基本上在这类SLAM框架里指的就是IMU里程计。 IMU可以输出车辆坐标系下的三轴加速度、三轴角速度、三轴地磁计（九轴IMU）。我们都知道，加速度的积分是速度、速度的积分是距离，角速度的积分是角度，地磁计可以计算与地磁北极的偏角，因此，如果IMU的输出是准确的话，使用IMU原始数据并进行积分就可以得到车辆的位姿。然而，目前无论多么高精度的IMU，都很难在较长时间下保持较高的准确度，而且积分会对误差也进行积分，导致IMU里程计只能用来做短时间内的位姿校正。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>是IMU里程计和激光雷达里程计紧耦合的SLAM框架。“紧耦合”三个字在IMU预积分模块得到明显的表达。如果用一句话说明IMU预积分模块的作用，那就是：利用IMU数据，为车辆位姿提供一个较好的位姿初始估计。由于目前的激光雷达大部分是10Hz，部分可以达到20Hz以上，因此，在两帧雷达点云期间，车辆会发生旋转和位移，如果旋转和位移很小，那么点云匹配就能够单独算出一个较准确的里程计（在运动缓慢的情况下，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>即使去除了IMU预积分也可以工作，只需要不启动imuPreintegration节点即可）；但是如果旋转和位移较大，点云匹配就可以失败；IMU一般拥有较高频率（200Hz以上），因此可以为两帧雷达点云的匹配提供较好的初始位姿值。</p>
<p>前面提到单纯利用IMU数据做积分，时间一场误差累积会很大，无法提供良好的初始位姿估计，因此需要融合其他传感器校正IMU积分算法。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，通过不断从激光里程计获取最新的里程计信息，作为IMU积分算法的观测来达到校正IMU积分算法的目的。</p>
<p><em>PS：此部分代码很大程度利用了<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>，因此，需要提前阅读本项目《Simple-LIO-SAM——GTSAM快速入门》一章</em></p>
<h2 id="imu预积分模块的整体框架流程图">IMU预积分模块的整体框架流程图</h2>
<img src="./imgs/Design-imuPreintegration-top01.png" title="fig:预积分模块流程图" alt="整体框架流程图" />
<center>
预积分模块流程图
</center>
<h2 id="偏差估计和imu里程计">偏差估计和IMU里程计</h2>
<p>这个模块容易让人看晕的地方在与模块里有两个队列缓存IMU原始数据，同时有两个IMU预积分器。只所以需要有两个预积分器的原因在于，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中对于IMU的预积分，在预测时（predict）需要指明上一时刻的<code>bias</code>，也就是IMU的积分误差。通常这个<code>bias</code>会随着时间慢慢改变，因此不能用离线标定的数据直接使用。于是，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，有一个线程（LaserHandler）会利用激光里程计当作额外的观测量，不断估计最新的<code>bias</code>值。而另一个线程（ImuHandler）则可以一直利用最新的<code>bias</code>值对实时接收到的IMU数据做积分，并发布为IMU里程计。</p>
<p>为了简单起见，我们将用来做偏差估计的队列和预积分器叫做<strong>优化队列</strong>和<strong>优化预积分器</strong>；将用来实时对IMU数据积分并发布IMU里程计的队列和预积分器叫做<strong>IMU队列</strong>和<strong>IMU预积分器</strong>。</p>
一图胜千言，下面这幅图描述了两个队列是如何被耦合起来输出更为准确的IMU预积分结果。其中<code>imuQueOpt</code>是优化队列，<code>imuQueImu</code>是IMU队列，两者命令与代码中一致。 <img src="./imgs/TwoImuQues.png" alt="两个IMU队列" />
<center>
线程交互图
</center>
<h2 id="偏差估计线程即odometryhandler">偏差估计线程——即odometryHandler</h2>
<p>这个回调函数占据了预积分模块大部分内容，而且有较多的重置条件和与<code>imuHandler</code>线程同步的操作，比较容易弄混。</p>
<p>这个回调函数会在接收到新的一帧雷达里程计（发自<code>MapOptimization</code>模块），主要操作上图中的<code>imuQueOpt</code>和<code>优化预积分器</code>。每当节点新收到一帧雷达里程计时，就会执行<code>预积分模块流程图</code>中左侧的一系列操作。主要目的就是利用雷达里程计做观测数据，实时更新IMU的偏差<code>bias</code>。同时，更新过的<code>bias</code>会传递到<code>IMU预积分器</code>。</p>
<h3 id="系统初始化">系统初始化</h3>
<img src="./imgs/Design-imuPreintegration-sysinit.png" title="fig:" alt="SystemInitialization" />
<center>
系统初始化流程
</center>
<p>当接收到第一帧雷达里程计时，需要对系统做初始化操作。主要包括因子图、因子图优化器、两个预积分器的初始化。由于初始化操作需要将第一帧雷达里程计的位姿作为先验因子，因此不能在构造函数中初始化。</p>
<h3 id="判断是否应该重置因子图">判断是否应该重置因子图</h3>
<img src="./imgs/Design-imuPreintegration-reset.png" title="fig:" alt="ResetSystem" />
<center>
重置系统
</center>
<p>为了保证拥有足够的实时性（预积分模块需要与IMU频率保持一致），<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的预积分模块在因子图中里程计因子数量大于100时会重置因子图与优化器。操作主要是从当前的因子图优化器拿出最新结果，并当作先验因子构造新的因子图。</p>
<h3 id="对优化队列中imu原始数据进行积分">对优化队列中IMU原始数据进行积分</h3>
<img src="./imgs/Design-imuPreintegration-integraOpt.png" title="fig:" alt="IntegrateOpt" />
<center>
积分优化队列
</center>
<p>这里要重新回顾上文的<code>线程交互图</code>。偏差估计线程的主要目的就是为IMU里程计线程提供最新的<code>bias</code>估计，因此每当到达新的一帧雷达里程计，意味着有新的观测到达，<code>bias</code>就可以进行更新。于是需要对优化队列中在当前雷达里程计时间之前的IMU原始数据用IMU预积分器进行积分，然后构造IMU因子。将IMU因子和雷达里程计加入因子图优化，得出最新的<code>bias</code>估计。</p>
<h3 id="因子图优化">因子图优化</h3>
<img src="./imgs/Design-imuPreintegration-factorgraph.png" title="fig:" alt="FactorGraphOptimization" />
<center>
因子图优化
</center>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>可以使用IMU预积分器构造IMU因子。利用<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>可以用因子图优化出<code>速度</code>,<code>IMU bias</code>,<code>位姿</code>的估计。</p>
<h3 id="传递优化结果">传递优化结果</h3>
<p><img src="./imgs/Design-imuPreintegration-setBias.png" alt="TransferOptimizationResults" /> 使用因子图优化出最新的IMU偏差估计之后，实际上还有优化后的位姿，这个位姿和IMU偏差会用来重置另外一个预积分器——IMU预积分器。IMU预积分器是在另一个回调函数中被主要使用，回顾<code>线程交互图</code>的下半部分和<code>模块流程图</code>的右侧流程。同时，设置完<code>IMU预积分器</code>之后，会将<code>imuQueImu</code>中剩余的其他IMU原始数据放入<code>IMU预积分器</code>做积分，这样<code>IMU预积分器</code>就一直保持最新状态，在<code>imuHandler</code>中可以实时积分并发布IMU里程计。</p>
<h2 id="imu里程计线程即imuhandler">IMU里程计线程——即imuHandler</h2>
这个回调函数比起odometryHandler就要简单很多。这个回调函数的主要功能就只有两个：1）不断地将新收到的IMU数据塞入两个放置IMU原始数据的队列——<code>线程交互图</code>中的imuQueOpt和imuQueImu；2）使用<code>IMU预积分器</code>对收到的IMU数据做积分，并将结果作为IMU里程计发布。 主要流程如下图： <img src="./imgs/Design-imuPreintegration-imuHandler.png" alt="imuHandler" />
<center>
imuHandler
</center>
<p>这个回调函数比较简单，就不再赘述。</p>
<h2 id="代码要点">代码要点</h2>
<h3 id="坐标系转换">坐标系转换</h3>
<p>IMU预积分模块中代码涉及到多次坐标系转换。主要是要明白IMU积分的原理和<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中坐标系的转换关系。关于坐标系有几个注意要点：</p>
<p><strong>1. 所有IMU原始数据都会先旋转到与雷达的坐标系朝向一致后再进行处理</strong></p>
<p>在<code>imuHandler</code>中每收到一个IMU数据就先旋转再存放。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L555-L556">code</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU数据旋转到lidar的旋转朝向</span></span><br><span class="line">sensor_msgs::msg::Imu thisImu = <span class="built_in">imuConverter</span>(*imu_raw);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存IMU数据</span></span><br><span class="line">imuQueOpt.<span class="built_in">push_back</span>(thisImu);</span><br><span class="line">imuQueImu.<span class="built_in">push_back</span>(thisImu);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 里程计都是对齐到雷达坐标系</strong></p>
<p>所有在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中发布出来的里程计，无论是IMU里程计或者是雷达里程计，度量的都是雷达在地图坐标系下的位姿。但是在IMU预积分模块的偏差估计线程中，使用IMU数据做积分，又需要使用雷达里程计作为观测，两者要同时加入因子图中，所以必须统一两者的坐标系。IMU原始数据在上面提到的第一个注意要点已经旋转到对齐雷达的方向，两者之间还差一个平移。因此，在接收到雷达里程计时，会先平移到旋转后的IMU坐标系，最后再平移回来。 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L298-L300">雷达里程计平移到旋转后的IMU坐标系代码</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化因子图的prior状态</span></span><br><span class="line"><span class="comment">// 将雷达里程计位姿平移到IMU坐标系，只是做了平移</span></span><br><span class="line">prevPose_ = lidarPose.<span class="built_in">compose</span>(lidar2Imu);</span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L585-L587">将IMU里程计对齐到雷达坐标系代码</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU里程计完全对齐到雷达（剩下一个平移关系）</span></span><br><span class="line">gtsam::Pose3 imuPose = gtsam::<span class="built_in">Pose3</span>(currentState.<span class="built_in">quaternion</span>(), currentState.<span class="built_in">position</span>());</span><br><span class="line">gtsam::Pose3 lidarPose = imuPose.<span class="built_in">compose</span>(imu2Lidar);</span><br></pre></td></tr></table></figure></p>
<h3 id="时间同步">时间同步</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中各个模块都是进行异步通信（ros topic），因此在每个模块里面都有几个队列保存数据，处理的时候再根据时间戳做同步。IMU预积分模块中有多个地方对数据做了时间戳同步。 比如在更新完<code>bias</code>之后，对IMU队列做积分时，会先抛弃早于最新的雷达里程计时间之前的数据。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L480-L486">code link</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样先做IMU数据队列和雷达里程计的时间同步</span></span><br><span class="line"><span class="type">double</span> lastImuQT = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!imuQueImu.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp) &lt; currentLidarOdomTime - <span class="type">sync_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lastImuQT = <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp);</span><br><span class="line">    imuQueImu.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-title-link" itemprop="url">Simple-LIO-SAM——GTSAM快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-27 21:28:48" itemprop="dateCreated datePublished" datetime="2023-03-27T21:28:48+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-29 19:16:46" itemprop="dateModified" datetime="2023-03-29T19:16:46+08:00">2023-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——GTSAM快速入门" href="/2023/03/27/lio_sam/gtsam-quickstart/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::0d35c30bd7aedf439c2d1184605769ac" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>其中的两大模块<code>imuPreintegration</code>和<code>mapOptimization</code>都依赖了因子图优化框架——<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>。 为了确保本项目的自洽性以及后面章节讲解的展开，不介绍一下因子图后端优化算法似乎说不过去。但是笔者目前对因子图的原理还没有进行非常详细的推导，因此这部分 内容会偏向如何对<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>快速入门。当然，最快速的入门方式就是完整地阅读一遍<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的官方教程。这部分章节只是拙劣地进行知识的搬迁，当然不是直接将 <a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的教程直接翻译过来。本章节会介绍<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>快速入门的知识，同时讲解<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>提供的<code>examples</code>中跟<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>联系较为紧密的一两个，同时指明<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中的用法出处。 至少阅读完本章节后应该能够对因子图有基本的认识，并且能够看懂<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中对<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的使用</p>
<h2 id="slam后端图优化">SLAM后端——图优化</h2>
<h3 id="问题描述">问题描述</h3>
<p>让我们先回归问题本身。在SLAM中，我们可以拥有多个输入，我们的最终目的是获取一条最准确的轨迹，然后使用这条准确的轨迹实时构建地图。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，我们有以下输入： 1. IMU数据； 2. 点云数据； 3. GPS数据（可选）； 4. 回环检测；</p>
<p>我们的问题是如何使用这些数据计算出一条最准确的历史轨迹，使用该轨迹就可以将对应的点云投影到地图坐标系，以此来建立一个点云格式地图。 PS：这只是SLAM的一个形式，就是优化出一条光滑准确的轨迹，这也是在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中使用的方法，因此本文以这种类型作为讲解。</p>
<h3 id="非线性优化">非线性优化</h3>
<p>在SLAM领域后端优化的一个分支是<code>滤波器方法</code>，主要以扩展卡尔曼滤波方法为主，采用隐马尔科夫假设，只保存上一次状态，并通过当前输入预测当前状态，偶尔通过观测修正状态。具体可见本博客的卡尔曼滤波相关文章。</p>
<p>目前的后端优化主要以各种非线性优化方法为主，把批量的位姿加入目标方程（projective function）一起优化，得到具有更好的全局性质的解。 <span class="math display">\[
\mathbf{x}^* = \argmin_{\mathbf{x}}\mathbb{F}(\mathbf{x})
\]</span> 其中，<span class="math inline">\(\mathbb{F}\)</span>是历史轨迹引入的各个误差之和 <span class="math display">\[
\mathbb{F}(\mathbf{x}) = \sum\mathbf{e}(x_i,c_{ij},x_j)
\]</span> <span class="math inline">\(x_i,x_j\)</span>是历史时刻的位姿，<span class="math inline">\(c_{ij}\)</span>是两者之间的约束（可以认为是观测或者输入）</p>
<p><strong>PS：再重申一句，SLAM后端体系很庞大，不是一篇文章能说清楚的，笔者目前也还没有这个能力。目前只求能够稍微讲清楚<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中是怎么被使用的即可。</strong></p>
<p>为了求解非线性方程在不同的SLAM任务中的特点，又发展出各种不同的优化方式，比如VIO中有Bundle Adjustment，有其他叫PoseGraph的，还有<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中使用的FactorGraph。 简单理解就是这些都是非线性方程和求解在不同的任务场景中的细分。后面有机会再单独列一篇文章讲解这些后端优化方法把。 <img src="./imgs/introToBA.png" alt="一图说明BA" /></p>
<h3 id="图优化">图优化</h3>
<p><strong>以下内容大量引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-repo/doc/gtsam.pdf</a></strong></p>
<p>为了批量优化历史位姿<span class="math inline">\(\mathbf{x} = \{x_0, x_1, x_2, ... x_i\}\)</span>，研究者将图论引入SLAM后端优化。每一个机器的位姿<span class="math inline">\(x_i\)</span>是图中的顶点；通过各种里程计计算，比如连续位姿间的IMU积分结果或者点云匹配结果，成为两个位姿<span class="math inline">\(x_i,x_j\)</span>之间的边；对于一些额外的观测，比如GPS数据，成为连接顶点的一元边（只有一端连接到顶点）。比如下图(引用自：<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>) <img src="./imgs/egForFactorGraph.png" alt="FactorGraph" /></p>
<h2 id="gtsam">GTSAM</h2>
<p>GTSAM使用因子图（FactorGraph）作为通用的图问题描述框架，并为各种机器人任务提供实现好的优化算法API，使得研究者快速开发后端优化框架。</p>
<p><strong>图优化（GraphOptimization）vs. <a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中使用的因子图优化（FactorGraph Optimization）区别 vs. BA</strong></p>
<ol type="1">
<li><strong>图优化</strong>似乎一般指位姿图（PoseGraph）的优化，图中的顶点都是机器人的位姿</li>
<li><strong>BA</strong>(Bundle Adjustment)似乎一般指在视觉SLAM中对地标（Landmarks）和位姿同时优化的方法</li>
<li><strong>GTSAM</strong>的因子图除了能够构建位姿图之外，还可以将速度、偏差、IMU预积分等当作顶点和边加入图中。另外，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>框架实现了iSAM和iSAM2两个递增式优化器</li>
</ol>
<h3 id="重要概念">重要概念</h3>
<p><strong>变量（variables）</strong>：因子图中的每一个顶点是一个代求的变量。假设我们只需要求解每一个时刻的机器人姿态，那么每个顶点就是该时刻的机器人位姿，如上图中的<span class="math inline">\({X_1,X_2,X_3}\)</span></p>
<p><strong>值（values）</strong>：值是每个变量数值。在调用优化器对因子图做优化时，我们要先为每个变量设置初始值，优化结束后再从优化器中拿出每个变量优化后的值。</p>
<p><strong>因子（factors）</strong>：因子是因子图中的边，每条边都可以视为一个因子，每个因子又可以认为是一个约束。比如连续两个位姿之间可以由IMU计算出两个位姿的变换，该变换作为一条边加入因子图连接两个变量（<code>二元因子：binary factor</code>）；又或者在某个时刻有GPS数据输入，GPS数据是一个观测，也可以作为一个因子加入因子图，这时候GPS的边只有一端连接到变量（<code>一元因子：unary factor</code>）。</p>
<p><strong>因子图（factor graph）</strong>：因子图由顶点（变量）和因子（边）构成。</p>
<p><strong>优化器（Optimizer）</strong>：因子图只是建模了SLAM的历史位姿和输入与观测间的关系，如何求解这个因子图也就是如何设置变量使得整个图最符合所有的约束（误差最小）则需要用到优化器。除了最常见的求解非线性问题的<code>Gaussian-Newton</code>和<code>Levenberg-Marquardt</code>优化器之外，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>还实现了两个增量式优化器<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>,<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a></p>
<p><strong>键（Keys）</strong>：往因子图添加因子需要指定该因子连接到哪些变量。GTSAM中使用键来指明。一元因子需要指明其连接到第几个变量；二元因子需要指明其连接到哪两个变量。因子图中每个变量的键都应该是唯一的。为了方便在多种变量类型的情况下指明键，GTSAM提供<code>Symbols</code>来让用户方便生成不同变量类型的键值。（键不一定是连续的，但必须是唯一的）</p>
<h3 id="gtsam例子最小例子">GTSAM例子——最小例子</h3>
<p>本小节引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>—第2章 以构建并求解下面因子图为例 <img src="./imgs/gtsam-minExample.png" alt="GTSAM最小例子" /> 图中<span class="math inline">\(x_1,x_2,x_3\)</span>为机器人三个时刻的位姿；<span class="math inline">\(f_0\)</span>为第一个时刻机器人位姿的观测；<span class="math inline">\(f_1,f_2\)</span>为时刻1-2和时刻2-3之间的里程计估计。<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/OdometryExample.cpp">代码</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个空的非线性因子图</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建先验因子，也就是图中的f_0</span></span><br><span class="line"><span class="comment">// 这里使用二维姿态（x,y,theta）简化问题</span></span><br><span class="line"><span class="function">Pose2 <span class="title">priorMean</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 高斯噪声，代表我们对该因子的不确定性</span></span><br><span class="line"><span class="keyword">auto</span> priorNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将先验因子加入因子图</span></span><br><span class="line"><span class="comment">// 其中的1表示该因子连接到第1个变量</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, priorMean, priorNoise));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建里程计因子，也就是图中的f_1,f_2</span></span><br><span class="line"><span class="comment">// 往前移动2米，y轴不便，theta不变</span></span><br><span class="line"><span class="function">Pose2 <span class="title">odometry</span><span class="params">(<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> odometryNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将里程计因子加入因子图</span></span><br><span class="line"><span class="comment">// 1,2代表该里程计约束是从变量1到变量2</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, <span class="number">2</span>, odometry, odometryNoise));</span><br><span class="line"><span class="comment">// 添加相同的因子到变量2和变量3之间</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">2</span>, <span class="number">3</span>, odometry, odometryNoise));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置各个变量的初始值</span></span><br><span class="line">Values initial;</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="built_in">Pose2</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="built_in">Pose2</span>(<span class="number">2.3</span>, <span class="number">0.1</span>, <span class="number">-0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="built_in">Pose2</span>(<span class="number">4.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用优化器并使用设定好的初始值对因子图优化</span></span><br><span class="line">Values result = <span class="built_in">LevenberMarquardtOptimizer</span>(graph, initial).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure></p>
<h3 id="gtsam例子imu预积分及imufactor">GTSAM例子——IMU预积分及ImuFactor</h3>
<p>在目前的SLAM，无论是VIO还是LIO，前端都需要IMU做积分得到一个位姿的初始估计。<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中实现了一个IMU预积分算法，并可以将其直接加入因子图中做优化。这在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中也被使用到。 本例子引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/ImuFactorsExample2.cpp">GTSAM-repo/examples/ImuFactorExample2.cpp</a>，为了说明<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中IMU预积分器及<code>ImuFactor</code>的用法，对该例子进行简化。最后构建出的因子图如下（为了可视化，人工调整了布局）： <img src="./imgs/ImuFactorGraph.png" alt="ImuFactorGraph" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，完整代码见下文</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IMU 预积分器</span></span><br><span class="line"><span class="comment">// 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span></span><br><span class="line"><span class="keyword">auto</span> params = PreintegrationParams::<span class="built_in">MakeSharedU</span>(kGravity);</span><br><span class="line">params-&gt;<span class="built_in">setAccelerometerCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setGyroscopeCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setIntegrationCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setUse2ndOrderCoriolis</span>(<span class="literal">false</span>);</span><br><span class="line">params-&gt;<span class="built_in">setOmegaCoriolis</span>(<span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 设置IMU预积分器</span></span><br><span class="line"><span class="function">PreintegratedImuMeasurements <span class="title">accum</span><span class="params">(params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个非线性因子图</span></span><br><span class="line">NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明因子图的初始值和优化结果</span></span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置位姿的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量x0的一元因子</span></span><br><span class="line"><span class="comment">// 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span></span><br><span class="line"><span class="keyword">auto</span> noise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(</span><br><span class="line">    (<span class="built_in">Vector</span>(<span class="number">6</span>) &lt;&lt; Vector3::<span class="built_in">Constant</span>(<span class="number">0.1</span>), Vector3::<span class="built_in">Constant</span>(<span class="number">0.3</span>)).<span class="built_in">finished</span>());</span><br><span class="line"><span class="comment">// 将位姿的先验因子加入因子图中</span></span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0, noise);</span><br><span class="line"><span class="comment">// 将位姿0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置IMU偏差的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量b0的一元因子</span></span><br><span class="line">Key biasKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> biasnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(Vector6::<span class="built_in">Constant</span>(<span class="number">0.1</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>(), biasnoise);</span><br><span class="line"><span class="comment">// 将IMU偏差b0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置速度的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量v0的一元因子</span></span><br><span class="line"><span class="comment">// 这里设置初始速度为0：Vector3(0,0,0)</span></span><br><span class="line"><span class="keyword">auto</span> velnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), velnoise);</span><br><span class="line"><span class="comment">// 将速度v0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于机器人的所有位姿时刻（关键帧）</span></span><br><span class="line"><span class="keyword">for</span> (i in N_steps)</span><br><span class="line">&#123;</span><br><span class="line">  biasKey++;</span><br><span class="line">  Symbol b1 = biasKey - <span class="number">1</span>;</span><br><span class="line">  Symbol b2 = biasKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置i时刻的位姿初始值</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(i), pose_i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于两个时刻之间的所有IMU数据进行积分</span></span><br><span class="line">  <span class="keyword">for</span> (j in N_imu_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    accum.<span class="built_in">integrateMeasurement</span>(measuredAcc, measuredOmega, <span class="type">delta_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用预积分器构建IMU因子，并加入因子图中</span></span><br><span class="line">  <span class="comment">// IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span></span><br><span class="line">  <span class="function">ImuFactor <span class="title">imufac</span><span class="params">(X(i - <span class="number">1</span>), V(i - <span class="number">1</span>), X(i), V(i), biasKey, accum)</span></span>;</span><br><span class="line">  newgraph.<span class="built_in">add</span>(imufac);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加两个时刻之间IMU偏差因子</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::<span class="built_in">ConstantBias</span>(), cov);</span><br><span class="line">  newgraph.<span class="built_in">add</span>(f);</span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(i), linear_velocity_vector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重值IMU预积分器</span></span><br><span class="line">  accum.<span class="built_in">resetIntegration</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用LM优化器对因子图进行优化并获取优化结果</span></span><br><span class="line">result = <span class="built_in">LevenbergMarquardtOptimizer</span>(newgraph, initialEstimate).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure></p>
<details class="note info no-icon"><summary><p>IMU预积分及IMU因子完整代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre>
</td>
<td class="code">
<pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @file ImuFactorExample2</span><br><span class="line"> * @brief Test example for using GTSAM ImuFactor and ImuCombinedFactor with ISAM2. Simplify and add graphviz by Zeal</span><br><span class="line"> * @author Robert Truax</span><br><span class="line"> * @author Zeal</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;gtsam/geometry/PinholeCamera.h&gt;</span><br><span class="line">#include &lt;gtsam/geometry/Cal3_S2.h&gt;</span><br><span class="line">#include &lt;gtsam/inference/Symbol.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuBias.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuFactor.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/Scenario.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/ISAM2.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span><br><span class="line">#include &lt;gtsam/slam/BetweenFactor.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace gtsam;</span><br><span class="line"></span><br><span class="line">// Shorthand for velocity and pose variables</span><br><span class="line">using symbol_shorthand::V;</span><br><span class="line">using symbol_shorthand::X;</span><br><span class="line"></span><br><span class="line">const double kGravity = 9.81;</span><br><span class="line"></span><br><span class="line">/* ************************************************************************* */</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // 起点</span><br><span class="line">  Pose3 pose_0(Rot3::Rodrigues(0, 0, 0), Point3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // 设置一个姿态仿真器，姿态沿着y轴以5m/s的速度前进，没有角度变化</span><br><span class="line">  Vector3 angular_velocity_vector(0, 0, 0);</span><br><span class="line">  Vector3 linear_velocity_vector(0, 5, 0);</span><br><span class="line">  auto scenario = ConstantTwistScenario(angular_velocity_vector,</span><br><span class="line">                                        linear_velocity_vector, pose_0);</span><br><span class="line">  // 设置仿真步长为1s</span><br><span class="line">  double delta_t = 1.0;</span><br><span class="line"></span><br><span class="line">  // 设置一个非线性因子图</span><br><span class="line">  NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line">  // 声明因子图的初始值和优化结果</span><br><span class="line">  Values initialEstimate, result;</span><br><span class="line"></span><br><span class="line">  // 设置位姿的先验因子</span><br><span class="line">  // 对应到上图中连接到变量x0的一元因子</span><br><span class="line">  // 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span><br><span class="line">  auto noise = noiseModel::Diagonal::Sigmas(</span><br><span class="line">      (Vector(6) &lt;&lt; Vector3::Constant(0.1), Vector3::Constant(0.3)).finished());</span><br><span class="line">  // 将位姿的先验因子加入因子图中</span><br><span class="line">  newgraph.addPrior(X(0), pose_0, noise);</span><br><span class="line">  // 将位姿0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(X(0), pose_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 设置IMU偏差的先验因子</span><br><span class="line">  // 对应到上图中连接到变量b0的一元因子</span><br><span class="line">  Key biasKey = Symbol(&#x27;b&#x27;, 0);</span><br><span class="line">  auto biasnoise = noiseModel::Diagonal::Sigmas(Vector6::Constant(0.1));</span><br><span class="line">  newgraph.addPrior(biasKey, imuBias::ConstantBias(), biasnoise);</span><br><span class="line">  // 将IMU偏差b0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">  </span><br><span class="line">  // 设置速度的先验因子</span><br><span class="line">  // 对应到上图中连接到变量v0的一元因子</span><br><span class="line">  // 这里设置初始速度为0：Vector3(0,0,0)</span><br><span class="line">  auto velnoise = noiseModel::Diagonal::Sigmas(Vector3(0.01, 0.01, 0.01));</span><br><span class="line">  newgraph.addPrior(V(0), Vector3(0,0,0), velnoise);</span><br><span class="line">  // 将速度v0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(V(0), Vector3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // IMU 预积分器</span><br><span class="line">  // 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span><br><span class="line">  auto params = PreintegrationParams::MakeSharedU(kGravity);</span><br><span class="line">  params-&gt;setAccelerometerCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setGyroscopeCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setIntegrationCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setUse2ndOrderCoriolis(false);</span><br><span class="line">  params-&gt;setOmegaCoriolis(Vector3(0, 0, 0));</span><br><span class="line">  // 设置IMU预积分器</span><br><span class="line">  PreintegratedImuMeasurements accum(params);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 模仿机器人在运动，这里一共有3个位姿节点0,1,2</span><br><span class="line">  // 在运动过程中模拟IMU预积分，并将IMU因子、IMU偏差因子加入因子图中</span><br><span class="line">  for (size_t i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">    double t = i * delta_t;</span><br><span class="line">    if (i &gt; 0) &#123;  // 设置位姿的初始值，这里是错误示范，使用真值作为初始值设置</span><br><span class="line">      auto pose_i = scenario.pose(t);</span><br><span class="line">      initialEstimate.insert(X(i), pose_i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加IMU因子和IMU偏差因子</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">      // 周期性添加IMU的偏差因子；IMU的偏差需要用其他方式计算，也可以使用离线标定的参数（一般不会）</span><br><span class="line">      if (i % 2 == 0) &#123;</span><br><span class="line">        // b1是上一次的IMU偏差变量的键值；b2是本次IMU偏差的键值</span><br><span class="line">        biasKey++;</span><br><span class="line">        Symbol b1 = biasKey - 1;</span><br><span class="line">        Symbol b2 = biasKey;</span><br><span class="line">        // 添加两个IMU偏差变量之间的二元因子</span><br><span class="line">        Vector6 covvec;</span><br><span class="line">        covvec &lt;&lt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1;</span><br><span class="line">        auto cov = noiseModel::Diagonal::Variances(covvec);</span><br><span class="line">        auto f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::ConstantBias(), cov);</span><br><span class="line">        newgraph.add(f);</span><br><span class="line">        // 将当前的IMU偏差变量的初始估计加入初始值集合</span><br><span class="line">        initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 这部分才是预积分器进行积分的地方</span><br><span class="line">      // 每次积分接收加速度、角速度以及间隔时间delta_t</span><br><span class="line">      Vector3 measuredAcc = scenario.acceleration_b(t);</span><br><span class="line">      Vector3 measuredOmega = scenario.omega_b(t);</span><br><span class="line">      accum.integrateMeasurement(measuredAcc, measuredOmega, delta_t);</span><br><span class="line"></span><br><span class="line">      // 使用预积分器构建IMU因子，并加入因子图中</span><br><span class="line">      // IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span><br><span class="line">      ImuFactor imufac(X(i - 1), V(i - 1), X(i), V(i), biasKey, accum);</span><br><span class="line">      newgraph.add(imufac);</span><br><span class="line"></span><br><span class="line">      // 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span><br><span class="line">      initialEstimate.insert(V(i), linear_velocity_vector);</span><br><span class="line">      // 重值IMU预积分器</span><br><span class="line">      accum.resetIntegration();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 使用初始值保存因子图</span><br><span class="line">  newgraph.saveGraph(&quot;ImuFactorsExample2_graphviz.dot&quot;, initialEstimate);</span><br><span class="line">  // 打印到命令行</span><br><span class="line">  newgraph.dot(cout, result);</span><br><span class="line"></span><br><span class="line">  // 调用LM优化器对因子图进行优化并获取优化结果</span><br><span class="line">  result = LevenbergMarquardtOptimizer(newgraph, initialEstimate).optimize();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* ************************************************************************* */</span><br><span class="line"></span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<h3 id="gtsam例子递增式优化">GTSAM例子——递增式优化</h3>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>不仅内置了<code>Gaussian-Newton</code>和<code>Leverberg-Marquat</code>两个常见的非线性优化器，还是实现了<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>和<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a>两个递增式的优化器。 递增式优化器更符合SLAM中常见的使用方式，也就是持续加入新的位姿和约束，并持续进行优化。</p>
<p>这部分内容可以参考<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>——第7章</p>
<p><a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/VisualISAM2Example.cpp">example/VisualISAM2Example.cpp</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置iSAM2优化器</span></span><br><span class="line"><span class="function">ISAM2 <span class="title">isam</span><span class="params">(parameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置因子图和初始值</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; poses.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; relations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose3&gt;(i, j))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加初始值到初始估计集合</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>,i), initial_x[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将因子图加入优化器</span></span><br><span class="line">  isam.<span class="built_in">update</span>(graph, initialEstimate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空当前因子图和初始值</span></span><br><span class="line">  <span class="comment">// 因子图已经加入优化器，因此需要清空为下一次因子图做准备</span></span><br><span class="line">  graph.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">  initialEstimate.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="gtsam学习路径">GTSAM学习路径</h2>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>对整个SLAM后端问题都封装得很好，因此可以让我们在不了解优化细节的情况下也可以构建自己的优化算法。除了对后端优化和图优化这些知识掌握外，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的学习主要还是要<code>学以致用</code>， 这里只是简单列出笔者觉得比较合适的资料阅读和学习顺序。</p>
<ol type="1">
<li>本文</li>
<li>GTSAM仓库下<code>doc</code>文件夹中的<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">gtsam.pdf</a></li>
<li>GTSAM仓库下<code>examples</code>文件夹中的一些例子，主要是对照上面的文档以及本文出现的例子进行阅读运行</li>
<li>本项目博客中关于<code>ImuPreintegration</code>和<code>MapOptimization</code>的讲解</li>
<li>本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM" title="Simple LIO-SAM">spl</a>中<code>src/mapOptimization.cpp</code>和<code>src/imuPreintegration.cpp</code>代码</li>
</ol>
<h2 id="资料参考">资料参考</h2>
<ol type="1">
<li>对目前各个图优化框架（g2o,GTSAM,ceres,SE-Sync）等做统一分析的综述性论文（强烈建议）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://lamor.fer.hr/images/50036607/2021-ajuric-comparison-mipro.pdf">A Comparison of Graph OptimizationApproaches for Pose Estimation in SLAM</a></p>
<ol start="2" type="1">
<li>Introduction to Bundle Adjustment, ppt</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://vincentqin.gitee.io/blogresource-3/slam-summer-courses-CADCG-Lab/BA-haominLiu.pdf">Bundle Adjustment</a></p>
<ol start="3" type="1">
<li>对基于图的SLAM后端优化算法的讲解，对SLAM的后端问题做比较正式的描述，接近2000引用</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf">A Tutorial on Graph-Based SLAM</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——特征提取模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 20:03:12" itemprop="dateCreated datePublished" datetime="2023-03-22T20:03:12+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-30 21:29:49" itemprop="dateModified" datetime="2023-03-30T21:29:49+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——特征提取模块" href="/2023/03/22/lio_sam/featureExtraction-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::e84bd67344741c4da21c259e3e444c5d" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><img src="./imgs/Design-Pipelines-feature.png" alt="Pipeline-featureExtraction" /> <a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>、<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法，从原始点云中提取出边缘点和平面点。边缘点和平面点被下游模块用来做点云匹配和构建地图。 特征提取模块是比较简单的模块，只监听来自<code>imageProjection</code>发布出来的去畸变后点云，同时将提取特征后的点云发布出去。这里有几点需要注意：</p>
<ol type="1">
<li>特征点的提取根据点的平滑度，而平滑度则通过每个点与周围点距离的平均值做近似</li>
<li>实际上在提取完边缘点和平面点之后，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>在代码里又把所有非边缘点的点都加入了平面点集合。这是比较奇怪的地方。从这里看出也许特征提取也不是必要的， 因为平面点已经包含了大部分的点云。事实上，在Github的一个仓库<a target="_blank" rel="noopener" href="https://github.com/YJZLuckyBoy/liorf" title="Based LIO-SAM, remove featureExtraction">liorf</a>中，就将特征提取模块去掉。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该段中除了角点之外的点加入平面点集合</span></span><br><span class="line"><span class="comment">// ！！！ 这点让步骤2感觉是多余的，最终的结果可能只是原始点云降采样，可能特征点提取也是没有必要的！！！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        surfaceCloudScan-&gt;<span class="built_in">push_back</span>(extractedCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>cloudLabel</code>标识该点的性质，-1为平面点，0为非特征点，1为边缘点。</li>
</ol>
<h2 id="特征点提取原理">特征点提取原理</h2>
<p>关于特征点提取部分<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的论文基本略过，因为跟<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>和<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法基本相同，这里建议这部分可以阅读<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>论文。</p>
<h3 id="转换到rangemat">转换到RangeMat</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法，先把三维点全部投影到二维图片，图像像素保存每个点距离原点的距离，称做<code>RangeMat</code>，<code>RangeMat</code>是规则的，每一行代表一条激光线束扫射360度所产生的点，因此后面用这个<code>RangeMat</code>做特征提取更快速更简单。 PS：这部分是在<code>ImageProjection</code>就已经处理好，并且<code>RangeMat</code>也被展开成一维向量存储。</p>
<h3 id="平滑度估计">平滑度估计</h3>
<p>特征点提取通过每个点的平滑度来提取，平滑度高于某个阈值的认为是边缘点；平滑度小于某个阈值的认为是平面点。 而平滑度的估计则通过每一个点在该激光线成像的前后几个点的平均距离代替。 我们另时间<span class="math inline">\(t\)</span>的点云为<span class="math inline">\(P_t = \{p_i, i \in |P_t|\}\)</span>，同时我们可以根据每个点的坐标算出每个点距离原点的距离<span class="math inline">\(r_i\)</span>，对于每个点，我们取其同一条激光线上前后5个点构成集合<span class="math inline">\(S\)</span>，则，点<span class="math inline">\(p_i\)</span>的平滑度可以这样计算： <span class="math display">\[
c = \frac{1}{|S|\cdot||r_i||}\left|\left|\sum_{j\in S,j\neq i}(r_j-r_i)\right|\right|
\]</span></p>
<h3 id="分段提取及特征点数量数量限制">分段提取及特征点数量数量限制</h3>
<p>为了让特征点分布更均匀，采用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>，将整个360的图像在水平方向分成6个子图像，在每个子图像中进行特征点提取。并且，对于每一个子图像中的每一条激光线束，会限制边缘点数量不超过20个，平面点的数量则没有限制。</p>
<h3 id="特殊情况">特殊情况</h3>
<p>有3种特殊情况不能将该点设置为边缘点。 1. 当一个点被选择为特征点，则把该点左右5个点都排除在特征点选取范围 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对该角点左右各5个点，如果两点之间的列索引差距小于10，则抛弃周围的点，避免重复对同一块区域提取角点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>当该点可能是由于遮挡导致被选择为边缘点</li>
</ol>
<figure>
<img src="./imgs/illegal_feature_point.png" alt="" /><figcaption>不合格的特征点(from LOAM)</figcaption>
</figure>
<p>如上图（b）所示，点A是由于被平面遮挡而产生的边缘点，当视角变化后，点A就不再是边缘点。 这个逻辑的判断也是通过点与其周围点的range差距判断。如果是由于遮挡产生的边缘点，则其与左边或者右边会存在距离的图片。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// featureExtraction.cpp&gt;markOccludedPoints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markOccludedPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cloudSize = extractedCloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 标记被遮挡的点和与激光束平行的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记被遮挡的点</span></span><br><span class="line">        <span class="type">float</span> depth1 = cloudInfo.point_range[i];</span><br><span class="line">        <span class="type">float</span> depth2 = cloudInfo.point_range[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[i+<span class="number">1</span>] - cloudInfo.point_col_ind[i]));</span><br><span class="line">        <span class="comment">// 两个点的列索引相差10个像素之内，认为是同一块区域</span></span><br><span class="line">        <span class="keyword">if</span> (columnDiff &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前点距离大于右点距离0.3米，认为当前点及左边6个点无效</span></span><br><span class="line">            <span class="keyword">if</span> (depth1 - depth2 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前点距离小于右边点距离0.3米，认为右边6个点无效</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (depth2 - depth1 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记平行与激光束的点</span></span><br><span class="line">        <span class="type">float</span> diff1 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i<span class="number">-1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="type">float</span> diff2 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i+<span class="number">1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="comment">// 当前点与左右两点的距离均大于阈值，认为当前点是处于平行面的点</span></span><br><span class="line">        <span class="keyword">if</span> (diff1 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i] &amp;&amp; diff2 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i])</span><br><span class="line">            cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>当点处于跟激光线平行的平面上时，也可能被认为时边缘点，也需要排除 如上图中的(a)所示，点B位于一个跟激光线较为平行的面上，激光线扫过去，前后几个点的距离差距会很大，因此在处理时可能会被认为是边缘点。这些点也需要做标记，不要设置为边缘点。</li>
</ol>
<h2 id="特征点提取流程">特征点提取流程</h2>
<p>由于这部分代码和原理都比较简单，这里只说一下特征提取的流程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief</span></span><br><span class="line"><span class="comment">* cloudInfo话题的回调函数，这个模块的功能都是顺序进行</span></span><br><span class="line"><span class="comment">* 1. 接收到从imageProjection中发布出的一个去畸变点云信息cloudInfo(自定义格式)</span></span><br><span class="line"><span class="comment">* 2. 对每个点计算曲率。计算时是计算周围点的平均距离用来作为曲率的替代</span></span><br><span class="line"><span class="comment">* 3. 标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="comment">* 4. 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="comment">* 5. 整合信息，发布完整数据包</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param msgIn 从去畸变模块接受的数据包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 缓存全局变量，后面的函数可以直接读取cloudInfo和cloudHeader进行处理</span></span><br><span class="line">cloudInfo = *msgIn;</span><br><span class="line">cloudHeader = msgIn-&gt;header;</span><br><span class="line"><span class="comment">// 把ros2 PointCloud2转成PCL格式，方便后面处理</span></span><br><span class="line">pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_deskewed, *extractedCloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点云每一个点曲率</span></span><br><span class="line"><span class="built_in">calculateSmoothness</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="built_in">markOccludedPoints</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="built_in">extractFeatures</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合信息，发布完整数据包</span></span><br><span class="line"><span class="built_in">publishFeatureCloud</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/imageProjection-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——点云去畸变模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 15:55:36" itemprop="dateCreated datePublished" datetime="2023-03-22T15:55:36+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-30 21:30:17" itemprop="dateModified" datetime="2023-03-30T21:30:17+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——点云去畸变模块" href="/2023/03/22/lio_sam/imageProjection-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::92a09cadad63fefbcbc8404aeb27c1f1" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><img src="./imgs/Design-Pipelines-image.png" alt="Pipeline-image" /> 点云去畸变模块(imageProjection.cpp文件，文件命名应该是继承了<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>，其实我觉得应该叫做数据预处理模块更合适）主要有以下几个作用</p>
<ol type="1">
<li>去除激光雷达点云的运动畸变</li>
<li>检索每一帧点云对应的IMU输出角度、IMU里程计位姿（发布自ImuPreintegration），以便MapOptimization模块用这些信息作为该帧点云的初始位姿</li>
<li>转换点云格式，计算<code>Range</code>字段，方便特征提取模块进行边缘点、平面点提取</li>
</ol>
<p>总体的流程如下图：</p>
<figure>
<img src="./imgs/Design-imageProjection-pipeline.png" alt="" /><figcaption>pipeline</figcaption>
</figure>
<h2 id="消息订阅及发布">消息订阅及发布</h2>
<figure>
<img src="./imgs/Design-Node%26%26Topics-imageProjection.png" alt="" /><figcaption>消息订阅及发布</figcaption>
</figure>
<h2 id="cloudinfo数据类型">CloudInfo数据类型</h2>
<p>经过去畸变的点云通过<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>自定义的数据格式<code>CloudInfo.msg</code>(Simple-LIO-SAM/msg/CloudInfo.msg)发布；特征提取模块也是将特征点放入这个自定义数据格式发布。 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cloud Info</span></span><br><span class="line"><span class="string">std_msgs/Header</span> <span class="string">header</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在进行点云去畸变时，把range数据展开成一维向量</span></span><br><span class="line"><span class="comment"># ring代表第几条激光线数，比如16线的激光雷达有16个ring</span></span><br><span class="line"><span class="comment"># start_ring_index记录第一个ring在一维向量中的起始索引</span></span><br><span class="line"><span class="comment"># end_ring_index记录第一个ring在一维向量中的结束索引</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">start_ring_index</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">end_ring_index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录一维的Range数据中每一个点在原始range图片中属于那一个列</span></span><br><span class="line"><span class="string">int32[]</span>  <span class="string">point_col_ind</span> <span class="comment"># point column index in range image</span></span><br><span class="line"><span class="comment"># 所有点的range数值，展开为一维数组</span></span><br><span class="line"><span class="string">float32[]</span> <span class="string">point_range</span> <span class="comment"># point range </span></span><br><span class="line"></span><br><span class="line"><span class="string">int64</span> <span class="string">imu_available</span></span><br><span class="line"><span class="string">int64</span> <span class="string">odom_available</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attitude for LOAM initialization</span></span><br><span class="line"><span class="comment"># 从IMU原始数据获取的roll、pitch、yaw角初值</span></span><br><span class="line"><span class="comment"># 当上面的imu_avaliable为true，odom_available为false的时候，会被用来</span></span><br><span class="line"><span class="comment"># 当作这一帧点云的初值</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_roll_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_pitch_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_yaw_init</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial guess from imu pre-integration</span></span><br><span class="line"><span class="comment"># 从imuPreintegration，IMU预积分模块获取的与这一帧雷达最接近的初始位姿</span></span><br><span class="line"><span class="comment"># 当上面的odom_available标签被置为true的时候会被使用</span></span><br><span class="line"><span class="comment"># 优先级比imu_xxx_init高</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_x</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_y</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_z</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_roll</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_pitch</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_yaw</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Point cloud messages</span></span><br><span class="line"><span class="comment"># 去畸变后的原始点云</span></span><br><span class="line"><span class="comment"># 在经过imageProjection模块后，这个数据字段被填充。在经过特征提取之后这个字段被清空</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_deskewed</span> </span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云边缘点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_corner</span></span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云平面点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_surface</span></span><br></pre></td></tr></table></figure> 这里主要是前面几个数组类型会比较难理解，主要是要知道在去畸变模块中，将所有点的<code>range</code>信息（也就是点距离雷达的距离）拉成一个一维的数组，即<code>float32[] point_range</code>。 同时，<code>cloud_deskewed</code>里存储的是去完畸变后的点云，里面点的顺序与<code>point_range</code>的顺序是一样的。</p>
<p><code>cloud_corner</code>和<code>cloud_surface</code>两个字段在<code>imageProjection</code>模块中没有被放置数据。特征提取模块会将边缘点、平面点放置在这两个字段中，同时将<code>cloud_deskewed</code>字段清空。</p>
<h2 id="功能解读">功能解读</h2>
<h3 id="imu及imu里程计处理">IMU及IMU里程计处理</h3>
<p>ImageProjection监听IMU原始数据与从ImuPreintegration发布出来的IMU里程计数据，分别由两个回调函数处理，对于IMU原始数据，只是简单地将其旋转到雷达坐标系后塞入缓存队列。 对于IMU历程计，则是直接塞入缓存队列。</p>
<h3 id="去畸变流程">去畸变流程</h3>
<p>一句话说明点云运动畸变校正：根据每一帧点云中每一个点的时间戳，计算该点到该帧点云起始点的旋转平移变换，将每一个点变换到起始点的坐标系。</p>
<p>要注意的是，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中对运动畸变校正只做了旋转校正，没有做平移校正。</p>
<p>去畸变流程发生在点云的回调函数中 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection::cloudHandler</span></span><br><span class="line"><span class="comment">/** 原始雷达点云话题的回调函数，实际上真正做点云处理的函数</span></span><br><span class="line"><span class="comment">    * 实际处理流程是单线程流水线式处理，这个函数后面的所有函数都是为这个函数服务，因此需要了解</span></span><br><span class="line"><span class="comment">    * 点云去畸变的流程。</span></span><br><span class="line"><span class="comment">    * 订阅原始lidar数据</span></span><br><span class="line"><span class="comment">    * 1、转换点云为统一格式，提取点云信息</span></span><br><span class="line"><span class="comment">    *   1）添加一帧激光点云到队列，取出最早一帧作为当前帧</span></span><br><span class="line"><span class="comment">    *   2) 计算起止时间戳，检查数据有效性</span></span><br><span class="line"><span class="comment">    * 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line"><span class="comment">    *   imu数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu数据，初始时刻对应imu的姿态角RPY设为当前帧的初始姿态角</span></span><br><span class="line"><span class="comment">    *   2) 用角速度、时间积分，计算每一时刻相对于初始时刻的旋转量，初始时刻旋转设为0</span></span><br><span class="line"><span class="comment">    *   imu里程计数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu里程计数据，初始时刻对应imu里程计设为当前帧的初始位姿</span></span><br><span class="line"><span class="comment">    *   2) 用起始、终止时刻对应imu里程计，计算相对位姿变换，保存平移增量</span></span><br><span class="line"><span class="comment">    * 3、当前帧激光点云运动畸变校正</span></span><br><span class="line"><span class="comment">    *   1) 检查激光点距离、扫描线是否合规</span></span><br><span class="line"><span class="comment">    *   2) 激光运动畸变校正，保存激光点</span></span><br><span class="line"><span class="comment">    * 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line"><span class="comment">    * 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line"><span class="comment">    * 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cloudHandler</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::PointCloud2::SharedPtr laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、提取、转换点云为统一格式</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cachePointCloud</span>(laserCloudMsg))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">deskewInfo</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、当前帧激光点云运动畸变校正</span></span><br><span class="line">    <span class="built_in">projectPointCloud</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line">    <span class="built_in">cloudExtraction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line">    <span class="built_in">publishClouds</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line">    <span class="built_in">resetParameters</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>提取、转换点云为统一格式 <img src="./imgs/Design-imageProjection-cachePointCloud.png" alt="提取、转换点云为统一格式" /></p></li>
<li><p>提取去畸变信息 <img src="./imgs/Design-imageProjection-deskewInfo.png" alt="提取去畸变信息" /></p></li>
</ul>
<p>这里有几点要注意 1. 从IMU原始数据计算每一时刻的位姿变换用的是近似算法（因为一帧点云成像时间很短，一般小与100ms） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对角度做积分</span></span><br><span class="line"><span class="comment">// 再次强调，对角速度的积分不是简单的角速度乘以间隔时间</span></span><br><span class="line"><span class="comment">// 关于角速度的积分公式可以查阅：https://zhuanlan.zhihu.com/p/591613108</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> timeDiff;</span><br><span class="line">timeDiff = currentImuTime - imuTime[imuPointerCur<span class="number">-1</span>];</span><br><span class="line">imuRotX[imuPointerCur] = imuRotX[imuPointerCur<span class="number">-1</span>] + angular_x * timeDiff;</span><br><span class="line">imuRotY[imuPointerCur] = imuRotY[imuPointerCur<span class="number">-1</span>] + angular_y * timeDiff;</span><br><span class="line">imuRotZ[imuPointerCur] = imuRotZ[imuPointerCur<span class="number">-1</span>] + angular_z * timeDiff;</span><br><span class="line">imuTime[imuPointerCur] = currentImuTime;</span><br><span class="line">++imuPointerCur;</span><br></pre></td></tr></table></figure> 2. 对于速度较低，角度变化不那么剧烈的行驶系统，即使不做点云畸变校正也没有问题</p>
<ul>
<li><p>对点云做去畸变处理 <img src="./imgs/Design-imageProjection-projectPointCloud.png" alt="对点云做去畸变处理" /></p></li>
<li><p>提取有效点云并集合其他信息 这里主要是将经过去畸变处理后记录下来的有效点进行数据转换，并把各种信息填入准备发布的<code>cloud_info</code>消息中。</p></li>
<li><p>发布点云</p></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">Simple-LIO-SAM——utility文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-22 11:18:09 / 修改时间：21:32:22" itemprop="dateCreated datePublished" datetime="2023-03-22T11:18:09+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——utility文件解读" href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6ed3eebc09d2237963daad43bab3bc96" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<p>这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>里一个最基础的文件，主要有几个重要功能： 1. 作为所有其他节点的基类，放置所有从配置文件读取的配置字 2. 提供一些实用函数 3. 配置<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a></p>
<h2 id="配置基类">配置基类</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>为了方便配置，把所有节点的配置项都写在同一个文件<code>Simple-LIO-SAM/config/params.yaml</code>，同时构建了一个基类<code>ParamServer</code>统一读取该配置文件，其余模块都从该基类继承。 <img src="./imgs/Design-Class.png" alt="类图" /> 这可能不是最优的方式，不过从实现上来说的确是最简单的。</p>
<p>每个模块的具体配置项后面具体讲解到会逐一解释，目前只需要知道是在哪里配置就行。 <details class="note info no-icon"><summary><p>配置部分代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>
</td>
<td class="code">
<pre><span class="line">// Topics</span><br><span class="line">string pointCloudTopic;  // 原始点云数据话题（/points_raw）</span><br><span class="line">string imuTopic;         // 原始IMU数据话题（/imu_correct）</span><br><span class="line">string imuOdomTopic;     // IMU里程计，在imuPreintegration中对IMU做预积分得到（/lio_sam/imu/odometry）</span><br><span class="line">string lidarOdomTopic;   // 雷达里程计，在mapOptimization中得到（/lio_sam/mapping/odometry）</span><br><span class="line">string gpsTopic;         // 原始gps经过robot_localization包计算得到，暂未使用</span><br><span class="line"></span><br><span class="line">// Services</span><br><span class="line">string saveMapSrv;      // 保存地图service地址</span><br><span class="line"></span><br><span class="line">// Frames</span><br><span class="line">string imuFrame;        // IMU数据坐标系，如果IMU和激光雷达坐标系硬件对齐，可以认为IMU、Lidar、Chassis坐标系相同</span><br><span class="line">string lidarFrame;      // 激光雷达坐标系，点云数据坐标系，由激光雷达发布的数据指定。与lidarFrame相同，但是不同雷达有不同的名称</span><br><span class="line">string baseLinkFrame;   // 车辆底盘坐标系</span><br><span class="line">string odomFrame;       // 地图坐标系，在SLAM中一般也是世界坐标系，通常是车辆的起始坐标系</span><br><span class="line"></span><br><span class="line">// GPS Settings</span><br><span class="line">bool useImuHeadingInitialization;</span><br><span class="line">bool useGpsElevation;</span><br><span class="line">float gpsCovThreshold;</span><br><span class="line">float poseCovThreshold;</span><br><span class="line"></span><br><span class="line">// Save pcd</span><br><span class="line">bool savePCD;</span><br><span class="line">string savePCDDirectory;</span><br><span class="line"></span><br><span class="line">// Lidar Sensor Configuration</span><br><span class="line">SensorType sensor;</span><br><span class="line">int N_SCAN;</span><br><span class="line">int Horizon_SCAN;</span><br><span class="line">int downsampleRate;</span><br><span class="line">float lidarMinRange;</span><br><span class="line">float lidarMaxRange;</span><br><span class="line"></span><br><span class="line">// IMU</span><br><span class="line">float imuAccNoise;      // IMU加速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuGyrNoise;      // IMU角速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuAccBiasN;      // IMU加速度偏差，三轴统一</span><br><span class="line">float imuGyrBiasN;      // IMU角速度偏差，三轴统一</span><br><span class="line">float imuGravity;       // 重力加速度值</span><br><span class="line">float imuRPYWeight;     // 算法中使用IMU的roll、pitch角对激光里程计的结果加权融合</span><br><span class="line">vector&lt;double&gt; extRotV;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extRPYV;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extTransV;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Matrix3d extRot;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Matrix3d extRPY;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Vector3d extTrans;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Quaterniond extQRPY;     // IMU角速度向量到雷达坐标系的旋转（四元数形式）</span><br><span class="line"></span><br><span class="line">// LOAM</span><br><span class="line">float edgeThreshold;            // 边缘特征点提取阈值</span><br><span class="line">float surfThreshold;            // 平面特征点提取阈值</span><br><span class="line">int edgeFeatureMinValidNum;     // 边缘特征点数量阈值（default:10)</span><br><span class="line">int surfFeatureMinValidNum;     // 平面特征点数量阈值（default:100)</span><br><span class="line"></span><br><span class="line">// voxel filter paprams</span><br><span class="line">float odometrySurfLeafSize;</span><br><span class="line">float mappingCornerLeafSize;</span><br><span class="line">float mappingSurfLeafSize ;</span><br><span class="line"></span><br><span class="line">float z_tollerance;             // 限制z轴平移的大小</span><br><span class="line">float rotation_tollerance;      // 限制roll、pitch角的大小</span><br><span class="line"></span><br><span class="line">// CPU Params</span><br><span class="line">int numberOfCores;              // 在点云匹配中使用指令集并行加速（default:4）</span><br><span class="line">double mappingProcessInterval;  // 点云帧处理时间间隔（default:0.15s）</span><br><span class="line"></span><br><span class="line">// Surrounding map</span><br><span class="line">float surroundingkeyframeAddingDistThreshold;   // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingkeyframeAddingAngleThreshold;  // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingKeyframeDensity;               // 构建局部地图时对采用的关键帧数量做降采样</span><br><span class="line">float surroundingKeyframeSearchRadius;          // 构建局部地图时关键帧的检索半径</span><br><span class="line"></span><br><span class="line">// Loop closure</span><br><span class="line">bool  loopClosureEnableFlag;</span><br><span class="line">float loopClosureFrequency;                     // 回环检测独立线程的执行频率</span><br><span class="line">int   surroundingKeyframeSize;                  // 回环检测构建局部地图的最大关键帧数量</span><br><span class="line">float historyKeyframeSearchRadius;              // 执行回环检测时关键帧的检索半径</span><br><span class="line">float historyKeyframeSearchTimeDiff;            // 执行回环检测时关键帧的检索时间范围</span><br><span class="line">int   historyKeyframeSearchNum;                 // 执行回环检测时融合局部地图时对目标关键帧执行+-25帧的关键帧融合</span><br><span class="line">float historyKeyframeFitnessScore;              // 执行回环检测时使用ICP做点云匹配，阈值大于0.3认为匹配失败，不采纳当前回环检测</span><br><span class="line"></span><br><span class="line">// global map visualization radius</span><br><span class="line">float globalMapVisualizationSearchRadius;</span><br><span class="line">float globalMapVisualizationPoseDensity;</span><br><span class="line">float globalMapVisualizationLeafSize;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details></p>
<h2 id="实用函数">实用函数</h2>
<p>这里主要讲解其中一个<code>imuConverter</code>函数。该函数的功能主要是将<code>IMU</code>的原始数据<strong>旋转到</strong><code>Lidar</code>坐标系。这里要先知道，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中， 默认将雷达坐标系和小车的坐标系等同为同一个坐标系，同时，这里只做了<strong>旋转</strong>操作，没有做平移操作。代码中有很多处位置都用到这个函数，因此需要理解这个函数到底做了什么。 简单来说这个函数就是做了一个<strong>向量坐标变换</strong>。旋转矩阵操作空间中一个点有两种意义：1）三维旋转；2）坐标变换。这两种不同的操作在做连续的操作时，对应旋转矩阵的左乘和右乘。 由于笔者以前的研究方向是六自由度姿态估计，用三维旋转操作比较多，一开始被这里的<code>矩阵右乘</code>搞蒙了。关于旋转矩阵的左乘和右乘，可以看这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45632220/article/details/117735223">博客</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将原始IMU数据：三轴加速度、三轴角速度、三轴角度，与雷达坐标系进行旋转对齐</span></span><br><span class="line"><span class="comment">+ 对齐之后输出的加速度、角速度、角度的x，y，z就变成雷达坐标系的x，y，z</span></span><br><span class="line"><span class="comment">+ 这里的特殊之处在于允许IMU的加速度、角速度与角度的输出是两个不同的坐标系。但在算法中，角度的输出除了用来做第一帧的初始化和加权融合，似乎没有其他作用</span></span><br><span class="line"><span class="comment">+ 这里是将IMU的三个轴与雷达的三个轴在旋转上做对齐，不能加上平移</span></span><br><span class="line"><span class="comment">+ 对向量做坐标系变换，对多个变换的复合应该是右乘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sensor_msgs::<span class="function">msg::Imu <span class="title">imuConverter</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::Imu&amp; imu_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sensor_msgs::msg::Imu imu_out = imu_in;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对加速度向量做坐标系变换，注意这里要理解成坐标系变换，也就是同一个加速度在IMU坐标系和Lidar坐标系的不同表达。不能想象成对加速度做旋转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">acc</span><span class="params">(imu_in.linear_acceleration.x, imu_in.linear_acceleration.y, imu_in.linear_acceleration.z)</span></span>;</span><br><span class="line">    acc = extRot * acc;</span><br><span class="line">    imu_out.linear_acceleration.x = acc.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.linear_acceleration.y = acc.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.linear_acceleration.z = acc.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角速度做坐标系变换。将IMU坐标系下的向量变换到雷达坐标系。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">gyr</span><span class="params">(imu_in.angular_velocity.x, imu_in.angular_velocity.y, imu_in.angular_velocity.z)</span></span>;</span><br><span class="line">    gyr = extRot * gyr;</span><br><span class="line">    imu_out.angular_velocity.x = gyr.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.angular_velocity.y = gyr.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.angular_velocity.z = gyr.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角度做坐标系变换。</span></span><br><span class="line"><span class="comment">    + q_from是IMU在全局坐标系下的位姿，q_from: transformation_from_map_to_imu</span></span><br><span class="line"><span class="comment">    + extQRPY如果与extRot对应的话应该是lidar到imu的变换：transformation_from_lidar_to_imu</span></span><br><span class="line"><span class="comment">    + q_final是将雷达点云从雷达坐标系转换到map坐标系的变换，也是：transformation_from_map_to_lidar -&gt; pcd_in_map = q_final * pcd_in_lidar</span></span><br><span class="line"><span class="comment">    + 这里原代码是q_final = q_from * extQRPY；似乎有点问题，还是按照我的推导修改成q_final = q_from * extQRPT.inverse()；由于这里的extQRPY是</span></span><br><span class="line"><span class="comment">    + 直接从配置文件里面读取的，所以这里加不加逆只需要在配置文件里改就行。认为这里有问题的假设是认为extQRPY和extRot的坐标系关系的定义是一致的，也就是</span></span><br><span class="line"><span class="comment">    + 将imu坐标系下的向量转换到雷达坐标系下。如果作者对这两者的定义刚好是相反的，那这里就没有问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Quaterniond <span class="title">q_from</span><span class="params">(imu_in.orientation.w, imu_in.orientation.x, imu_in.orientation.y, imu_in.orientation.z)</span></span>;</span><br><span class="line">    Eigen::Quaterniond q_final = q_from * extQRPY.<span class="built_in">inverse</span>();</span><br><span class="line">    imu_out.orientation.x = q_final.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.orientation.y = q_final.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.orientation.z = q_final.<span class="built_in">z</span>();</span><br><span class="line">    imu_out.orientation.w = q_final.<span class="built_in">w</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sqrt</span>(q_final.<span class="built_in">x</span>()*q_final.<span class="built_in">x</span>() + q_final.<span class="built_in">y</span>()*q_final.<span class="built_in">y</span>() + q_final.<span class="built_in">z</span>()*q_final.<span class="built_in">z</span>() + q_final.<span class="built_in">w</span>()*q_final.<span class="built_in">w</span>()) &lt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Invalid quaternion, please use a 9-axis IMU!&quot;</span>);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imu_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="qosquality-of-service">QoS:Quality of Service</h2>
<p>关于ROS2中<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a>的基本介绍，参考官方文档学习。<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a>的设置中，有两个参数是最重要的。一个是<code>depth</code>，一个是<code>RELIABILITY</code>。<code>depth</code>可以简要理解成中间件DDS为这个消息预留的缓存队列长度。 <code>RELIABILITY</code>主要有两种选项<code>best_effort</code>和<code>reliable</code>，它们的关系类似<code>TCP</code>,<code>UDP</code>。<code>best_effort</code>不能保证每一个消息到到达接收端，但可以保持最好的实时信。<code>reliable</code>保证每一帧消息 都到达接收端，但是无法保证实时性。ROS2中专门为传感器预设了一个<a target="_blank" rel="noopener" href="https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1SensorDataQoS.html">SensorDataQoS</a>，里面采用的就是<code>best_effort</code> 的设置。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>设置了三种<code>QoS</code>，分别为：原始IMU数据、原始雷达数据、框架内部传输</p>
<ol type="1">
<li><p>原始IMU数据QoS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始IMU数据的QOS，因为IMU数据较小，所以depth可以设成较大</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_imu&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">2000</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_imu = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_imu.history,</span><br><span class="line">      qos_profile_imu.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_imu);</span><br></pre></td></tr></table></figure></p></li>
<li><p>原始雷达数据QoS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始雷达数据topic的QOS，主要是best_effort和depth起作用</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_lidar&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">5</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_lidar = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_lidar.history,</span><br><span class="line">      qos_profile_lidar.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_lidar);</span><br></pre></td></tr></table></figure></p></li>
<li><p>算法框架内部传输QoS 算法框架内部要求有最高的实时性，并且由于传输中有很多点云类型的数据（较大），因此作者把<code>depth</code>设置为1 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 算法框架中默认的QOS，主要是depth=1和reliability=best_effort起作用。对于传输实时性有要求，不要求每个数据可接收的消息，一般</span></span><br><span class="line"><span class="comment">/// 设成best_effort。在ROS2中对于传感器数据，有一个内置的QOS叫rclcpp::SensorDataQoS()</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> qos = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile.history,</span><br><span class="line">      qos_profile.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile);</span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/" class="post-title-link" itemprop="url">Simple-LIO-SAM——总体流程认识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-16 19:38:59" itemprop="dateCreated datePublished" datetime="2023-03-16T19:38:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-22 21:31:59" itemprop="dateModified" datetime="2023-03-22T21:31:59+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——总体流程认识" href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::152660a48ad07f280a45860dc663a523" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总体流程">总体流程</h2>
<p>话不多说，直接上干货。下图是整理出来的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>整体运行流程</p>
<figure>
<img src="./imgs/Design-Pipelines.png" alt="" /><figcaption>Pipeline</figcaption>
</figure>
<h3 id="整体认识">整体认识</h3>
<p>所谓的紧耦合，我是这么理解的：IMU本身就可以积分出来一个位姿，连续帧的点云匹配也可以计算出一个位姿，如果两者分别进行，然后再做一个加权融合，那么就属于松耦合。而从上面的框架图也可以看出，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的融合框架整体呈现一个<code>圈</code>，每个环节都为下一个环节提供信息，最后一个环节又为第一个环节提供信息。同时，耦合之处还在于以下几点： 1. 高频的IMU信息对激光雷达点云做了畸变矫正，做了畸变矫正后的点云被用来做匹配计算激光里程计 2. IMU的积分结果被用来当作该帧点云的初值，为点云匹配提供了较好的初始估计 3. 雷达里程计的结果被用来计算IMU的偏差，同时也被用来持续纠正IMU里程计</p>
<p>虽然<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中还可以融合<code>GPS</code>信息，但是主要还是对雷达点云和IMU信息，因此，可以认为输入是点云和IMU数据，输出是小车当前时刻的位姿，已经对历史时刻位姿的平滑。</p>
<ul>
<li><p>框架的入口是点云去畸变模块，主要的功能就是对激光雷达运动畸变做矫正，然后输出去完畸变的点云。</p></li>
<li><p>去完畸变的点云经过特征提取模块，提取出角特征点和平面特征点，被图优化模块中的点云匹配部分用来做点云匹配。</p></li>
<li><p>图优化模块利用去完畸变后的点云与历史帧构建的局部地图做匹配，得出较准确的里程计结果。同时利用图优化，加入回环检测因子，使得整体估计更为准确顺滑</p></li>
<li><p>IMU预积分模块从IMU和图优化模块接收数据，对IMU的原始数据做积分，得出每一帧点云的初始位姿，提供给图优化模块作为优化初始值。同时又从图优化模块拿出经过点云、图优化校正后的里程计结果校正本身的结果</p></li>
<li><p>坐标系发布主要是为了<code>RIVZ</code>显示中用的，主要就是将各种里程计结果转换成<code>TF</code>坐标关系发布出去。在原始<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中是与<code>imuPreintegration</code>放置在同一个文件</p></li>
</ul>
<h3 id="运动畸变矫正">运动畸变矫正</h3>
<ul>
<li>为什么激光雷达有运动畸变？ 激光雷达通过发射高能量激光线束，计算激光线束往返时间，得到该激光线打到的物体的距离。以机械式激光雷达为例，雷达在统一时刻可以发送多条激光线（32、64、128），这多条激光线在垂直方向上可以扫到三维空间中垂直的一条线，激光雷达通过环绕一周的方式可以对360的空间做三维成像 <img src="./imgs/lidar.webp" alt="lidar" /></li>
</ul>
<p>由于激光雷达是通过激光线束环绕一周的方式成像一帧的点云，那么这一帧点云的点就是在不同的时间探测的。如果激光线束在环绕一周的过程中，激光雷达是在运动的，那么这一帧点云就由于激光雷达的运动而变得不准确，因此需要对其做校正。 <img src="./imgs/livox_lidar_distortion.png" alt="livox_lidar_distortion_removal" /> （上面这幅图片引用自livox官网[Liovox_distortion_removal])</p>
<p>激光雷达输出的每一帧点云<span class="math inline">\(P\)</span>，里面的每一个点<span class="math inline">\(p_i\)</span>，都有一个属性<span class="math inline">\(t_i\)</span>，记录了该点距离该帧点云起始时刻的时间间隔，也就是下面代码段里的<code>time</code>字段。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection.cpp 49-60</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VelodynePointXYZIRT</span></span><br><span class="line">&#123;</span><br><span class="line">    PCL_ADD_POINT4D</span><br><span class="line">    PCL_ADD_INTENSITY;</span><br><span class="line">    <span class="type">uint16_t</span> ring;</span><br><span class="line">    <span class="type">float</span> time;</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">&#125; EIGEN_ALIGN16;</span><br><span class="line"><span class="built_in">POINT_CLOUD_REGISTER_POINT_STRUCT</span> (VelodynePointXYZIRT,</span><br><span class="line">    (<span class="type">float</span>, x, x) (<span class="type">float</span>, y, y) (<span class="type">float</span>, z, z) (<span class="type">float</span>, intensity, intensity)</span><br><span class="line">    (<span class="type">uint16_t</span>, ring, ring) (<span class="type">float</span>, time, time)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>由于IMU是非常高频的，因此我们可以得出该帧点云成像时间段内的激光雷达位移和旋转的变换，然后通过每一个点的时间<span class="math inline">\(t_i\)</span>，可以根据时间进行插值得出每一个点相对于起始点的转换关系<span class="math inline">\(T_i\)</span>。（注：LIOSAM里面是直接通过时间戳查找，而不是进行插值）。从而，我们就可以将每个点都转换到起始点的坐标系 <span class="math display">\[
p_i^0 = T_ip_i
\]</span></p>
<h3 id="点云特征提取">点云特征提取</h3>
<p>激光里程计中一般会涉及到点云匹配，如果用原始点云进行匹配由于点数过多的关系，会导致耗时太长，因此<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的方法进行<code>边缘点</code>,<code>平面点</code>两类特征点的提取，后面点云匹配部分使用这两种特征点进行<code>LM</code>优化求解出匹配关系。</p>
<p>这部分的代码相对简单，后面关于这个模块的详细内容会介绍，这里唯一要清楚的是，这里的点云特征点提取用的是每个点的曲率，选择曲率大的点作为边缘点，选择曲率小的点作为平面点。但是曲率的计算是用每个点周围的点到其平均距离作为近似。</p>
<h3 id="imu预积分模块">IMU预积分模块</h3>
<p>这一个模块虽然从原理和实现上来说稍微有一点点复杂，但是从功能上简单来说只有一个功能，就是实时对<code>IMU原始数据</code>做处理（积分），得到每一个时刻的IMU里程计（也是6自由度位姿），然后该位姿被用来作为该帧点云的初始估计位姿，这个初始估计位姿会被用来作为点云匹配的初始估计。</p>
<h3 id="点云匹配及图优化">点云匹配及图优化</h3>
<p>这是整个框架最复杂的一个模块（也许是没有很好解耦？）。这个模块主要包含了以下几个功能： 1. 点云匹配 2. 回环检测 3. 因子图构建及优化 4. 根据关键帧信息构建全局地图</p>
<p>具体内容会在后面的章节展开，这里应该要有几个感性认识： 1. 一般点云精细匹配（比如ICP算法）需要有一个良好的初始值，这里的初始值可以理解成采用IMU预积分模块的输出。 2. 点云匹配部分用的是沿用自LOAM-&gt;LeGO-LOAM的点云匹配算法，不是使用ICP。<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>也是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan" title="作者Github">TixiaoShan</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的上一篇相关论文 3. 回环检测根据里程计的x,y,z检索紧邻帧，然后通过ICP算法计算当前帧与近邻帧的转换关系 4. 经过点云匹配后的位姿会经过图优化得出更平滑的位姿 5. 地图和因子图的因子实际上是以关键帧的形态存在后端优化部分，关键帧的选取会比较稀疏，比如距离小与1米不会采用为关键帧。不采用为关键帧的点云会执行完点云匹配后就直接输出位姿。 6. 在有新的回环因子加入因子图后，会进行多次因子图优化器的更新步骤，然后将所有历史关键帧的位姿都更新一遍 7. 这个部分还支持<code>GPS里程计</code>的监听，并将<code>GPS里程计</code>也加入因子图进行优化</p>
<h2 id="坐标系规定">坐标系规定</h2>
<h3 id="坐标系规定-1">坐标系规定</h3>
<p>原有的<code>urdf</code>文件加入了太多额外没必要的关节，导致<code>rviz</code>中<code>tf-tree</code>关系太过复杂。为了简化坐标系关系，但同时又维持坐标系关系标准化并且与<code>ROS</code>的规定相同（<code>ROS</code>中关于姿态估计的坐标系关系主要参考：<a target="_blank" rel="noopener" href="http://docs.ros.org/en/melodic/api/robot_localization/html/preparing_sensor_data.html">robot_localization_coordinate_system</a>，这里对项目中的坐标系关系做了一些简化修改。 根据robot_localization包的规定，所有姿态都要转到世界坐标系，通常是<code>map</code>或者<code>odom</code>坐标系。所有的twist数据，都要转到base_link坐标系下处理。</p>
<h3 id="simple-lio-sam坐标系说明">Simple-LIO-SAM坐标系说明</h3>
<ol type="1">
<li>根据REP资料，一般有4个坐标系<code>earth</code>,<code>map</code>,<code>odom</code>,<code>base_link</code>。由于在SLAM中一般没有引入地球坐标系。所以在这里只有后三个坐标系。 同时，如果是以起始点作为地图原点，<code>map</code>,<code>odom</code>两个坐标系是重合的关系。</li>
<li>另外，为了可以在Rivz显示原始点云信息，则也加入一个雷达坐标系。</li>
<li>为了让坐标系定义自洽，虽然在算法中没有直接用到，但是IMU加速度速度和角速度应该定义在IMU坐标系，因此引入IMU坐标系</li>
<li>为了让定义更为标准，这里保留<code>map</code>坐标系，虽然在SLAM中<code>map</code>,<code>odom</code>大部分情况是重叠的</li>
<li>因此，整个spl_lio_sam框架可以简化成5个坐标系：<code>map</code>, <code>odom</code>,<code>base_link</code>,<code>lidar_link</code>,<code>imu_link</code>坐标系。其中， <code>map</code>是地图原点，在建图时是起始点，在重定位模式时，是地图原点。<code>odom</code>是里程计坐标系；<code>base_link</code>是车辆自身坐标系。<code>lidar_link</code>坐标系是雷达坐标系， 在lio_sam中是与<code>base_link</code>坐标系对齐的，但是<code>lidar_link</code>字段会根据雷达型号不同，被修改。<code>imu_link</code>坐标系是IMU坐标系，配置文件中 有指明IMU坐标系到Lidar坐标系的转换关系。</li>
</ol>
<h3 id="坐标系关系的其他说明">坐标系关系的其他说明</h3>
<ol type="1">
<li>ROS的Message Header只有一个frame_id字段，表明这个数据是在哪个坐标系下的。</li>
<li>nav_msgs/Odometry中还有一个child_frame_id字段，nav_msgs/Odometry中的twist数据应该是在child_frame_id坐标系下的数据 &gt; The twist in this message should be specified in the coordinate frame given by the child_frame_id</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">记一次解决rosbag2内存错误问题过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 18:28:01" itemprop="dateCreated datePublished" datetime="2023-03-15T18:28:01+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/ROS/" itemprop="url" rel="index"><span itemprop="name">ROS</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="记一次解决rosbag2内存错误问题过程" href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73e4783c1a71c1ae17cdb35318885253" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
</ul>
<h2 id="问题背景">问题背景</h2>
<p>由于工作需要，需要开发一个程序，根据记录的信息，从<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>保存的数据包根据打点的时间戳，提取出一段段单独的数据包。 为了存储空间考虑，保存时以及提取时都指定了使用<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#recording-with-compression">压缩的方式</a>进行存储。压缩器和压缩模式如下： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line"><span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>不仅有命令行工具，同时还开放API给开发者使用。<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>还提供了<code>convert</code>功能，可以对录下来的bagfile进行<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">二次提取</a>。因此开发这部分功能可以参考源码里面的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp">bag_rewriter.cpp</a></p>
<h2 id="开发环境">开发环境</h2>
<blockquote>
<p>ROS: ROS2-humble</p>
</blockquote>
<blockquote>
<p>OS: ubuntu 22.04</p>
</blockquote>
<blockquote>
<p>language: cpp17</p>
</blockquote>
<blockquote>
<p>rosbag2: 0.15.4-2jammy.20230118.031755</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p>完成上述数据提取功能后进行测试，发现提取的时候如果同时提取多个目标（构建多个writer，读取message后进行写操作，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L135">rosbag2源码参考部分</a>，并且都进行压缩的时候，会有<code>core dump</code>，错误信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corrupted size vs. prev_size</span><br><span class="line">[ros2run]: Aborted</span><br></pre></td></tr></table></figure></p>
<p>然而在其他情况：1.同时提取多个目标，但是不进行压缩；2.提取一个目标，进行压缩；的时候，程序都可以正常运行</p>
<p>为了确保不是自己编写的程序导致的问题，又使用<code>rosbag2 cli</code>进行类似的尝试。根据<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">converting-bags</a>的说明，我使用下面的<code>output_options.yaml</code>进行数据转换： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p>然后使用如下命令进行提取 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<p>果不其然，直接使用<code>rosbag2</code>的包也会有<code>core</code>问题，不过报的信息会有区别，不同次运行报的信息还不一样，主要是类似下面这样： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc(): unsorted double linked list corrupted</span><br><span class="line">free(): corrupted unsorted chunks</span><br><span class="line">corrupted double-linked list</span><br></pre></td></tr></table></figure></p>
<h2 id="问题复现">问题复现</h2>
<p>简单起见可以直接使用<code>rosbag2 cli</code>复现这个问题 1. 准备一个ros2的bag包 2. 新建一个配置文件命名为：<code>output_options.yaml</code>，并填入下面内容： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure> 3. 执行数据转换命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="问题定位">问题定位</h2>
<h3 id="增加日志">增加日志</h3>
<p>由于已经确认不是自己写的程序的问题，所以其实可以跳过这一步 ### gdb检查 cpp程序排查还是需要上gdb，不要自己瞎折腾瞎改代码。<a href="#appendA">文末记录</a>如何在<code>ubuntu</code>上生成<code>core文件</code>。 运行一次程序，生成<code>core文件</code>后使用gdb检查错误堆栈 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ros_ws/install/package/lib/package/excutable /path/to/corefile</span><br><span class="line"></span><br><span class="line">bt  <span class="comment"># gdb命令，打印错误堆栈</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到如下的报错信息</p>
<figure>
<img src="./imgs/backtraces.png" alt="" /><figcaption>backtraces</figcaption>
</figure>
<p>虽然是在子线程中出错，但是大概也能看到是在<code>rosbag2_compression::SequentialCompressonWriter::compression_thread_fn()</code>函数中出错。 这也符合了现象，只在进行压缩的时候会出错。</p>
<p>同时，从错误堆栈里可以看出应该是<code>rosbag2_compression_zstd::ZstdCompressor</code>在进行压缩处理的时候调用<code>rcutils_uint8_array_resize</code>函数出错。</p>
<h3 id="对比不同的writer">对比不同的writer</h3>
<p>由于在进行多个<code>writers</code>写数据，但是不执行压缩的时候并没有相关问题发生，所以可以对比一下普通的<code>writer</code>和<code>SequentialCompressonWriter</code>在写函数中的区别 #### 普通的writer，即rosbag2_cpp::SequentialWriter 普通的<code>writer</code>，即<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp">rosbag2_cpp::SequentialWriter</a>中，<code>void SequentialWriter::write(std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>函数比较简单，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp#L328-L337">核心代码</a>是这几行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (storage_options_.max_cache_size == <span class="number">0u</span>) &#123;</span><br><span class="line"><span class="comment">// If cache size is set to zero, we write to storage directly</span></span><br><span class="line">storage_-&gt;<span class="built_in">write</span>(converted_msg);</span><br><span class="line">++topic_information-&gt;message_count;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Otherwise, use cache buffer</span></span><br><span class="line">message_cache_-&gt;<span class="built_in">push</span>(converted_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>bag_rewrite</code>在调用<code>writer</code>的时候，<code>max_cache_size</code>始终<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L191">设置为0</a>，因此执行的是<code>if</code>分支，也就是直接调用底层的数据库封装类直接写入硬盘。</p>
<h4 id="带压缩的writer即rosbag2_compressionsequentialcompressionwriter">带压缩的writer即rosbag2_compression::SequentialCompressionWriter</h4>
<p>带压缩功能的writer这部分的逻辑增加了一个单独线程做压缩处理，函数<code>void SequentialCompressionWriter::write(   std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>的核心部分主要是<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L317-L321">这几行</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(compressor_queue_mutex_)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (compressor_message_queue_.<span class="built_in">size</span>() &gt; compression_options_.compression_queue_size) &#123;</span><br><span class="line">    compressor_message_queue_.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">compressor_message_queue_.<span class="built_in">push</span>(message);</span><br><span class="line">compressor_condition_.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>compressor_message_queue_</code>在另一个线程，即函数<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L63">void SequentialCompressionWriter::compression_thread_fn()</a>被处理。 这里面有一个对传入的<code>SerializedMessageSharedPtr</code>对象中的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L96">内存直接进行处理</a></p>
<h4 id="重新查看调用api的代码">重新查看调用API的代码</h4>
<p>调用<code>rosbag2 API</code>进行数据写操作的主要过程如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create rosbag2_storage::StorageOptions</span></span><br><span class="line">rosbag2_storage::StorageOptions storageOptions;</span><br><span class="line"><span class="comment">// create reader</span></span><br><span class="line"><span class="keyword">auto</span> inputReader = rosbag2_transport::ReaderWriterFactory::<span class="built_in">make_reader</span>(storageOptions);</span><br><span class="line"><span class="comment">// open file</span></span><br><span class="line">inputReader-&gt;<span class="built_in">open</span>(storageOptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create multiplt writers</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
<p><strong>可以看到，我们从<code>reader</code>中拿到的<code>SerializedBagMessage</code>是以共享指针的形式使用，当我们把共享指针传给不同的<code>writer</code>时，不同的<code>writer</code>内部同时对同一块内存进行数据压缩处理，因此也就导致了不同线程操作同一块地址空间的错误。</strong></p>
<h2 id="修复">修复</h2>
<p>由于不想更改<code>rosbag2</code>的代码，因此想办法在调用层解决。既然问题共享指针指向的内存被不同线程同时处理，那么我们就在每一次调用<code>writer-&gt;write(nextMsg)</code>的时候对<code>nextMsg</code>执行一次深拷贝，让不同的<code>writer</code>操作不同内存即可。 这里比较复杂的是<code>SerializedBagMessage</code>中使用一个指向<code>rcutils_uint8_array_t</code>的指针对内存进行管理。而<code>rcutils_uint8_array_t</code>里面又使用一个裸<code>uint8_t*</code>指针指向管理的内存。同时<code>rcutils</code>的文档不够详细，也没有提供函数对<code>rcutils_uint8_array_t</code>执行深拷贝操作。不过只要能够明白上面的内存管理关系，修复起来不太困难，关于<code>rcutils_uint8_array_t</code>的操作可以参考<code>rosbag2</code>里面的代码，最终修复的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">...create reader &amp;&amp; writer</span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg_copy = std::<span class="built_in">make_shared</span>&lt;rosbag2_storage::SerializedBagMessage&gt;();</span><br><span class="line">        <span class="comment">// 新建rcutils_uint8_array_t需要按照下面这样的操作</span></span><br><span class="line">        nextMsg_copy-&gt;serialized_data = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">rcutils_uint8_array_t</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">rcutils_uint8_array_t</span>,</span><br><span class="line">        [](<span class="type">rcutils_uint8_array_t</span> * msg) &#123;</span><br><span class="line">        <span class="keyword">auto</span> fini_return = <span class="built_in">rcutils_uint8_array_fini</span>(msg);</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">        <span class="keyword">if</span> (fini_return != RCUTILS_RET_OK) &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR_STREAM</span>(</span><br><span class="line">            rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rosbag2_cpp&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Failed to destroy serialized message: &quot;</span> &lt;&lt; <span class="built_in">rcutils_get_error_string</span>().str);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建后需要执行内存初始化</span></span><br><span class="line">        <span class="type">rcutils_allocator_t</span> allocator = <span class="built_in">rcutils_get_default_allocator</span>();</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">rcutils_uint8_array_init</span>(</span><br><span class="line">            nextMsg_copy-&gt;serialized_data.<span class="built_in">get</span>(),</span><br><span class="line">            nextMsg-&gt;serialized_data-&gt;buffer_capacity,</span><br><span class="line">            &amp;allocator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span> (ret != RCUTILS_RET_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Init arrry failed with ret code = %d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制内容</span></span><br><span class="line">        nextMsg_copy-&gt;topic_name = nextMsg-&gt;topic_name;</span><br><span class="line">        nextMsg_copy-&gt;time_stamp = nextMsg-&gt;time_stamp;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_capacity = nextMsg-&gt;serialized_data-&gt;buffer_capacity;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_length = nextMsg-&gt;serialized_data-&gt;buffer_length;</span><br><span class="line">        <span class="comment">// 复制内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)nextMsg_copy-&gt;serialized_data-&gt;buffer,</span><br><span class="line">                (<span class="type">void</span>*)nextMsg-&gt;serialized_data-&gt;buffer, nextMsg-&gt;serialized_data-&gt;buffer_length);</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg_copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<p>这个bug同时提交到<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>仓库<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/issues/1262">issues中</a>，看看后面有没有机会修复并提交PR</p>
<h2 id="附录aubuntu-core文件生成">附录A：ubuntu core文件生成</h2>
<div id="appendA">

</div>
<ol type="1">
<li><p>ubuntu有一个默认的错误搜集系统apport，必须要关掉之后才能生成core文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service apport status</span><br><span class="line">sudo service apport stop</span><br><span class="line">sudo systemctl apport disble  <span class="comment"># 似乎无法关闭开机启动，每次需要的时候需要手工确认是否关闭</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>设置core文件大小，默认是0，所以不会生成core文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c  <span class="comment"># 若结果是0，则不会生成core文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 不限制core文件大小</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 选择当前使用的终端</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></p></li>
<li><p>设置corefile路径(注意，路径必须普通用户可读！） <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /corefile</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /corefile</span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>CMakeLists.txt加上``Debug模式</code>下不进行编译器优化 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In CMakeLists.txt</span></span><br><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;<span class="variable">$ENV</span>&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb -Wno-unused-parameter&quot;</span>)  </span><br></pre></td></tr></table></figure> 注意在编译<code>ROS2</code>包的时候要指明<code>Debug</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select package_name --cmake-args -DCMAKE_BUILD_TYPE=Debug</span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-title-link" itemprop="url">Simple-LIO-SAM——环境搭建与运行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-14 19:49:06" itemprop="dateCreated datePublished" datetime="2023-03-14T19:49:06+08:00">2023-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——环境搭建与运行" href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::b824fa070f036b85c958cacd75daa48f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="运行环境搭建">运行环境搭建</h2>
<p>本项目提供基于<code>ROS2-humble</code>的镜像，并提供脚本可直接在镜像中启动可视化程序 ### 数据 本项目同时提供转为<code>rosbag2</code>格式的数据包，<a href="">下载地址</a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATA_DIR=/path/to/download/ros2bag/dir</span><br></pre></td></tr></table></figure> 本项目中默认的配置文件<code>params_default.yaml</code>可以直接运行下面的数据： - park_dataset - walking_dataset - garden_dataset</p>
<h3 id="环境部署">环境部署</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zeal-up/Simple-LIO-SAM.git</span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_run.sh -h  <span class="comment"># show help message</span></span><br><span class="line">./docker_run.sh -c /path/to/code/repo -d <span class="variable">$DATA_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./docker_into.sh  # enter the container next time</span></span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令在镜像中执行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws/</span><br><span class="line"><span class="built_in">mkdir</span> src &amp;&amp; <span class="built_in">cd</span> src &amp;&amp;<span class="built_in">ln</span> -s /home/splsam/codes ./</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">colcon build --packages-select spl_lio_sam</span><br></pre></td></tr></table></figure>
<h3 id="运行">运行</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker镜像下运行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws</span><br><span class="line"><span class="built_in">source</span> ./install/setup.bash</span><br><span class="line">ros2 launch spl_lio_sam run.launch.py </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开终端</span></span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"><span class="built_in">cd</span> data/ros2/</span><br><span class="line">ros2 bag play ./park_dataset/ --topics /points_raw /imu_raw</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行时画面： <img src="./imgs/runtime.gif" alt="SplRunParkDataset" /></p>
<h2 id="开发环境搭建">开发环境搭建</h2>
<p>由于本项目作者在使用<code>vscode</code>开发<code>c++</code>时经常会遇到无法快捷跳转问题（其实笔者发现有很多人在使用vscode开发时都会有这个问题）， 因此一并把解决方案写入项目中。</p>
<h3 id="vscode-cpp函数快捷跳转">vscode Cpp函数快捷跳转</h3>
<ol type="1">
<li>安装cpp扩展 vscode侧边栏进入扩展选项（ctrl+shift+x)，搜索<code>c++</code>，安装<code>C/C++ Extension Pack</code></li>
<li>打开项目 &gt; File-&gt;Open Folder</li>
<li>保存为工作区 &gt; File-&gt;Save Workspace as 选择目标目录及文件（默认以<code>.code-workspace</code>结尾）</li>
<li>打开刚才保存的工作区文件 &gt; File-&gt;Open File 选择刚才打开的工作区文件</li>
<li>对工作区添加<code>c++</code>库检索路径 在刚才打开的工作区文件中，参考以下格式编辑 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;folders&quot;:</span> [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;path&quot;:</span> <span class="string">&quot;../Simple-LIO-SAM&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.includePath&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/**&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/c++/9/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/8/include/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/include/**&quot;</span>,</span><br><span class="line"></span><br><span class="line">			<span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">//</span> <span class="string">重点！！这里的路径要设置为ros2工作空间下spl_lio_sam编译出来的头文件</span></span><br><span class="line">			<span class="string">&quot;/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam&quot;</span></span><br><span class="line"></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;C_Cpp.files.exclude&quot;:</span> &#123;</span><br><span class="line">			<span class="string">&quot;**/.vscode&quot;</span><span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">			<span class="string">&quot;**/.vs&quot;</span><span class="string">:</span> <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cStandard&quot;:</span> <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cppStandard&quot;:</span> <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;python.analysis.include&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.autoComplete.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.analysis.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="对工作区文件的解释">对工作区文件的解释</h3>
<p>其实主要起作用的是工作区文件中<code>settings-&gt;C_Cpp.default.includePath</code>字段内容，vscode的cpp扩展会读取该工作空间文件下 的这个字段，并将里面的路径进行解析加到头文件解析路径中。</p>
<p>这里有两个路径要注意的</p>
<ol type="1">
<li><code>"$&#123;workspaceFolder&#125;/include"</code>，也就是Simple-LIO-SAM仓库下的include路径</li>
<li><code>"/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam"</code>，这个要设置成你的ros工作空间对应的路径</li>
</ol>
<p>另外，如果发现自己路径设置完成，但是有些函数还提示下划线，要看看是不是那些函数是<code>c++17</code>或者更高的标准才支持的特性，在上面的配置文件中 设置c++/c标准为17</p>
<h3 id="其余注意">其余注意</h3>
<ol type="1">
<li>尽量不要用<code>/path/**</code>的格式添加include路径，虽然看起来很省事，但会影响检索效率</li>
<li>刚设置完路径需要等待vscode检索构建数据库，在vscode右下方状态条会提示正在进行检索</li>
<li>上面配置文件中<code>"python.analysis.extraPaths","python.autoComplete.extraPaths","python.analysis.include"</code>是设置python语法提示器的 库检索路径，不同的python提示器插件会使用不同的路径。</li>
</ol>
<h2 id="reference">Reference</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIO-SAM</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258">LIO-SAM paper</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">This Project</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note">LIO-SAM-note</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/lio_sam/intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/lio_sam/intro/" class="post-title-link" itemprop="url">Simple-LIO-SAM——项目简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 19:45:58" itemprop="dateCreated datePublished" datetime="2023-03-13T19:45:58+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——项目简介" href="/2023/03/13/lio_sam/intro/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::d227db67a0df8ebb129db6bbfad2da40" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="liosam介绍">LIOSAM介绍</h2>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>（Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping），紧耦合激光——惯性里程计历程方法。 作者<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan" title="作者Github">TixiaoShan</a>是SLAM届大神，在LIOSAM之前发表过LeGO-LOAM，在LIOSAM之后发布了LVI-SAM，在LIOSAM基础上又加入了语义定位因子。 由于网上关于<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>的解读已经有很多了，这里不会进行太过详细的复述，具体的内容解析会放在后面讲解代码的时候慢慢仔细阐述。</p>
<p>简单来说，LIOSAM整体的框架与其他方法区别在与： 1. 使用因子图作为后端优化框架，将IMU预积分与雷达点云匹配及回环检测等紧耦合 1. 使用当前帧-局部地图匹配而不是对全局地图匹配来加速点云匹配速度 1. 基于位置关系选择回环帧，并使用点云匹配计算回环因子 1. 使用高频IMU并进行简单积分对点云做运动畸变校正</p>
<p>另外，LIOSAM作者的工程功底很好，LIOSAM代码库被github上很多SLAM开源项目作为code base</p>
<h2 id="本项目目的及特点介绍">本项目目的及特点介绍</h2>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>源代码虽然不能说庞大，甚至可以说简单，因为整个代码库主要只要5个文件。 <img src="./imgs/org_files.png" alt="原始src目录" /> 但是里面每个模块都通过ROS的topic与其他模块有紧密的联系。 整个的流程对新手十分不友好，下图是LIOSAM原本运行时的<code>rqt_graph</code></p>
<figure>
<img src="./imgs/org_rqtgraph.png" alt="" /><figcaption>原始rqt_graph</figcaption>
</figure>
<p>第二个复杂之处在与LIOSAM框架设计到的知识点和工具较多，至少要熟悉<code>ROS,gtsam,pcl</code>几个库，算法层面需要熟悉<code>点云匹配、IMU积分、因子图、三维转换</code>等。 对于熟悉SLAM的人来说可能较为简单上手，但是对于新入门的人来说则一开始会一头雾水。</p>
<p>基于上述这些原因，笔者进行了<a href="Simple%20Lio%20Sam">SPL-LIO-SAM</a>项目，希望能够以最大幅度帮助初学者理解<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>框架及里面的算法细节。 本项目对<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>做了如下改进</p>
<h3 id="基于最新的ros2-humble实现">基于最新的ROS2-humble实现</h3>
<p>虽然LIOSAM源码中有一个ros2分支，但该分支的维护者并不是原作者，而且已经长时间没有人维护，且该分支存在一些bug没有被修复。为了能够在进行本项目的学习过程中 熟悉最新的ROS2框架，笔者在LIOSAM的ros2分支基础上，修复了存在的bug，同时将功能较为独立的<code>Transformfusion</code>类抽取成独立的类。</p>
<p>为了便于上手及部署，笔者同时准备了适配的docker镜像供学习者使用。</p>
<h3 id="简化">简化</h3>
<h4 id="话题发布的简化">话题发布的简化</h4>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>原始代码中有很多中间结果的发布，这些中间结果可以用来可视化及调试程序，但是对于学习者和开发者而言不仅意义不大，而且会在初始学习源码阶段误导学习者。 本项目在话题发布上进行<code>大幅度简化</code>，简化后的设计如下： <img src="./imgs/Design-Node%26%26Topics.png" alt="节点及话题设计" /></p>
<p>简化后运行时的<code>rqt_graph</code>: <img src="./imgs/spl_liosam_rosgraph.png" alt="简化后的ros—grpah" /></p>
<h4 id="坐标系简化">坐标系简化</h4>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>中实用的坐标系并不复杂，但是作者提供的<code>urdf</code>包含了太多为了兼容性考虑的坐标系，这些坐标系对于实际运行和理解并没有用。因此，本项目基于ROS对坐标系的约束，将 坐标系关系树简化为如下： <img src="./imgs/Design-CoordinateSystem.png" alt="简化后的坐标系关系" /></p>
<h4 id="保留算法及定义完整性">保留算法及定义完整性</h4>
<p>虽然本项目去除了很多非必要话题，同时对于一些非必要代码也进行了简化，但对一些学习算法有帮助的细节依旧保留。比如激光里程计在发布的时候有<code>mapping/odometry</code>和<code>mapping/odometry_incremental</code>两个话题，两个话题虽然类似但是背后却有很不同的函数，但同时两者合一又不影响算法的运行。因此采取的做法时在代码中保留这部分代码，同时加以解释，但发布时只发布其中一个话题。</p>
<h3 id="完善的注释及流程图">完善的注释及流程图</h3>
<p>网上其实对<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>源码的注释并不少，比如<a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note" title="LIO-SAM-note">LIO-SAM-note</a>和<a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote" title="LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a>，还有一些blog也对源码做了解释，但是都不太完美，同时缺少流程性的组织。本项目借鉴了一些开源项目的注释，并加以完善，可以说，本项目是目前对<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>注释最完善的开源项目。 <img src="./imgs/comments.png" alt="部分注释图" /></p>
<p>为了最为清晰的展示<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258" title="liosam论文">LIOSAM</a>算法不同模块的流程，该项目还对各个模块流程进行梳理，建立了完善的流程图设计 <img src="./imgs/Design-Pipelines.png" alt="Pipeline" /> <img src="./imgs/Design-imageProjection_top0.png" alt="imageProjection_top0" /> <img src="./imgs/Design-imageProjection_top1.png" alt="imageProjection_top0" /></p>
<h2 id="后续章节">后续章节</h2>
<ol type="1">
<li>节一：开发环境搭建及运行</li>
<li>节二：总体流程及utility文件</li>
<li>节三：激光雷达运动畸变矫正模块</li>
<li>节四：点云特征提取模块</li>
<li>节五：Gtsam快速认识</li>
<li>节六：IMU预积分模块</li>
<li>节七：激光里程计模块</li>
<li>节八：坐标系发布模块</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">FastDDS关键概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 18:02:43" itemprop="dateCreated datePublished" datetime="2023-03-13T18:02:43+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/DDS/" itemprop="url" rel="index"><span itemprop="name">DDS</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="FastDDS关键概念" href="/2023/03/13/dds/FastDDS%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73f7a0f706535d55ad531611b3af6c03" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="架构">架构</h1>
<p>架构图 <img src="./imgs/fast-dds-architecture.svg" alt="架构图" /></p>
<p>域（Domain）的概念 <img src="imgs/domain_concept.jpg" alt="Domain" /> <img src="imgs/dds_domain.svg" alt="Domain" /></p>
<p>数据中心收发模型（DCPS:Data Centric Publisher and Subscriber) <img src="imgs/DataCentricModel.png" alt="DCPS" /></p>
<h1 id="why-need-a-publisher-and-subscriber">Why need a publisher and subscriber</h1>
<blockquote>
<p>These publishers and subscribers don’t need to know about each other ahead of time; they discover each other dynamically at runtime. The data they share is described by a “topic,” and publishers and subscribers send and receive data only for the topics they are interested in. In this pattern, many publishers may publish the same topic, and many subscribers may subscribe to the same topic. Subscribers receive data from all of the publishers that they share a topic with. Publishers send data directly to subscribers, with no need for a broker or centralized application to mediate communications. (https://community.rti.com/static/documentation/connext-dds/6.0.1/doc/manuals/connext_dds/getting_started/cpp11/intro_pubsub_cpp.html)</p>
</blockquote>
<h1 id="notes">Notes</h1>
<p>Publisher 和 Subscriber 负责生成DataWriter&amp;&amp;DataReader，一个Publisher[Subscriber]可以绑定多个DataWriter[DataReader]。每一个DataWriter[DataReader]都会绑定到一个topic，同时可以指定对应的回调函数DataWriterListener[DataReaderListener]</p>
<h1 id="数据监控fastdds-monitor">数据监控——FastDDS Monitor</h1>
<p><a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/getting_started/tutorial.html">FastDDS Monitor Tutorial</a> ## 原理 FastDDS库有一个内嵌的Participant，叫做Statistic Participant，包含在FastDDS的Statistic Module中。该模块不是默认编译的，因此需要在编译FastDDS的时候指明CMake选项。 实际上是用户开发应用时，在构建<strong>DomainParticipants</strong>阶段，如果通过某种方式指明了要将数据统计信息往外发送，则Statistic Module模块就会自动收集信息，然后往固定的topic发送监控数据。FastDDS Monitor通过这些内嵌的topic，可以监控数据的收发情况。</p>
<p><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/statistics/statistics.html">如何打开Statistics DataWriters</a> <a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/getting_started/tutorial.html">如何使用FastDDS Monitor</a></p>
<p><strong>注意，如果编译FastDDS的时候打开Statistics Module模块，由于会发送额外的信息，所以会损失性能</strong> &gt; Consequently, by default, Fast DDS does not compile this module because it may entail affecting the application’s performance.(https://fast-dds.docs.eprosima.com/en/latest/fastdds/statistics/statistics.html)</p>
<figure>
<img src="imgs/monitor.jpg" alt="" /><figcaption>数据监控窗口</figcaption>
</figure>
<h1 id="record-replay">Record &amp;&amp; Replay</h1>
<blockquote>
<p>rosbag2 is a ROS 2 application that can be used to capture DDS messages and store them on an SQLite database which allows inspecting and replaying said messages at a later time.</p>
</blockquote>
<ol type="1">
<li>rosbag2可以将在Topic中传送的数据以SQLite的形式保存</li>
<li>FastDDS没有自己的数据保存和回放工具，官方说明用的是ROS2的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2">rosbag2</a>包。要使用该包来记录和回放FastDDS的数据需要安装ROS2环境和rosbag2</li>
<li>由于rosbag2是用来保存ros2的message的，并不是FastDDS的官方工具，因此如果要用rosbag2回放，需要做较多的配置</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/use_cases/rosbag_capture/rosbag_capture.html#rosbag-capture">使用rosbag-capture</a></p>
<h1 id="limitations">Limitations</h1>
<ol type="1">
<li>没有进程管理和启动工具。ROS/Apollo/XPilot都有属于自己的进程调度系统，可以直接按指定顺序启动多个进程并执行相关调度。</li>
<li>似乎无法实现像ROS的Service这种类似RPC的功能</li>
</ol>
<h1 id="reference-resources-link">Reference &amp;&amp; Resources link</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/eProsima/Fast-DDS">FastDDS Github</a></li>
<li><a target="_blank" rel="noopener" href="https://fast-dds-monitor.readthedocs.io/en/latest/rst/installation/linux.html">FastDDS Monitor Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://fast-dds.docs.eprosima.com/en/latest/fastdds/use_cases/rosbag_capture/rosbag_capture.html#rosbag-capture">使用rosbag-capture</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/eProsima/Fast-DDS-python.git">Fast-DDS-Python</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/archives/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywzGuJ0w","appkey":"7c4a236bb42c7db38424a76bf68ccf99","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
