<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeal-up.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录及分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeal&#39;s Blog">
<meta property="og:url" content="https://zeal-up.github.io/archives/index.html">
<meta property="og:site_name" content="Zeal&#39;s Blog">
<meta property="og:description" content="学习记录及分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeal">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeal-up.github.io/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeal's Blog</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SE75EDBKX6","only_pageview":true}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/zeal-up" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeal's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习～天天向上～</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zeal</p>
  <div class="site-description" itemprop="description">学习记录及分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/11/lio_sam/mapOptimization-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/lio_sam/mapOptimization-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——后端优化模块详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 22:00:19" itemprop="dateCreated datePublished" datetime="2023-04-11T22:00:19+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-13 18:29:05" itemprop="dateModified" datetime="2023-04-13T18:29:05+08:00">2023-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/04/11/lio_sam/mapOptimization-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——后端优化模块详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——后端优化模块详解" href="/2023/04/11/lio_sam/mapOptimization-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::fddca820098456617fc64b80ba797a81" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<p><img src="./imgs/Design-Pipelines-mapOpt.png" alt="后端优化" /> 这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>四大部分（点云去畸变、特征提取、预积分、后端优化）中最复杂的一个模块了，完全弄懂这个模块也就离完全理解<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>不远了。 这个模块负责SLAM框架中的后端优化，由于<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中使用图优化作为后端优化算法，所以有时候笔者也会称这个模块为图优化模块。但是这个模块的 作用不单单是负责后端优化，还有1）、全局地图可视化；2）、回环检测等功能。</p>
<p>这个模块一共有三个主要线程执行具体功能，三个线程分别如下：</p>
<ol type="1">
<li>雷达里程计及后端优化线程 这个线程主要负责执行雷达到地图的匹配，得到较为准确的雷达里程计，然后将雷达里程计、回环检测因子加入因子图进行优化，得到全局优化的关键帧位姿。</li>
<li>回环检测线程 回环检测使用较为费时的ICP算法，因此作为一个单独的线程运行。当检测到合适的回环因子后，会加入全局缓存队列，在雷达里程计线程中被加入因子图优化。</li>
<li>全局地图可视化线程 <a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中对于地图的存储格式是通过一系列关键帧的点云和位姿存储，而不是通过一整个点云存储。为了能够以较低的频率发布全局地图，后端优化模块单独有一个线程 对历史关键帧的点云根据最新的位姿转换到地图坐标系，然后将融合后的全局点云地图发布出去。</li>
</ol>
<p>废话不多说，下面分别介绍这三个线程的主要流程和方法</p>
<h2 id="雷达里程计及后端优化线程">雷达里程计及后端优化线程</h2>
这个线程的流程主要如下图所示 <img src="./imgs/Design-mapOptimization-top.png" alt="雷达里程计及后端优化线程流程图" />
<center>
雷达里程计及后端优化线程流程图
</center>
<p>这个线程是点云的回调函数，点云来自<code>FeatureExtraction</code>模块输出的经过特征提取后的点云。整个函数执行过程代码如下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特征点云回调函数，也是整个模块核心的计算函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 提取当前点云时间戳</span></span><br><span class="line">    timeLaserInfoStamp = msgIn-&gt;header.stamp;</span><br><span class="line">    timeLaserInfoCur = <span class="built_in">stamp2Sec</span>(msgIn-&gt;header.stamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取当前点云的特征角点和特征平面点</span></span><br><span class="line">    cloudInfo = *msgIn;</span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_corner,  *laserCloudCornerCur);</span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_surface, *laserCloudSurfCur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 一共三个线程使用到这把锁</span></span><br><span class="line"><span class="comment">        * 1. 雷达里程计线程，也就是当前线程</span></span><br><span class="line"><span class="comment">        * 2. 发布全局地图线程，执行关键帧点云拷贝转换操作</span></span><br><span class="line"><span class="comment">        * 3. 回环检测线程，执行关键帧姿态拷贝操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一帧的时间戳，两帧之间时间间隔大于mappingProcessInterval才会进行处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> timeLastProcessing = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)</span><br><span class="line">    &#123;</span><br><span class="line">        timeLastProcessing = timeLaserInfoCur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前帧位姿初始化</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;updateInitialGuess&quot;</span>);</span><br><span class="line">        <span class="built_in">updateInitialGuess</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建局部地图</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;extractSurroundingKeyFrames&quot;</span>);</span><br><span class="line">        <span class="built_in">extractSurroundingKeyFrames</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对当前帧点云做降采样</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;downsampleCurrentScan&quot;</span>);</span><br><span class="line">        <span class="built_in">downsampleCurrentScan</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前帧点云匹配到构建的局部地图，优化当前位姿</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;scan2MapOptimization&quot;</span>);</span><br><span class="line">        <span class="built_in">scan2MapOptimization</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算是否将当前帧采纳为关键帧，加入因子图优化</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;saveKeyFramesAndFactor&quot;</span>);</span><br><span class="line">        <span class="built_in">saveKeyFramesAndFactor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当新的回环因子或者GPS因子加入因子图时，对历史帧执行位姿更新</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;correctPoses&quot;</span>);</span><br><span class="line">        <span class="built_in">correctPoses</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布激光历程计</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;publishOdometry&quot;</span>);</span><br><span class="line">        <span class="built_in">publishOdometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布当前帧对齐到地图坐标系的点云和完整轨迹</span></span><br><span class="line">        <span class="built_in">RCLCPP_DEBUG</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;publishFrames&quot;</span>);</span><br><span class="line">        <span class="built_in">publishFrames</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="雷达里程计的最高频率">雷达里程计的最高频率</h3>
<p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)</span><br></pre></td></tr></table></figure> <code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1/0.15Hz</p>
<h3 id="点云匹配的初始值">点云匹配的初始值</h3>
<p>基本所有的精细点云匹配都需要一个较好的初值。<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中的点云匹配使用高斯牛顿算法优化当前帧点云到局部地图的距离（具体算法见本项目博客的相关文章），基于最小二乘法的点云匹配更需要一个优良的初值。 回顾一下我们在<code>ImageProjection</code>也就是点云去畸变模块的内容，在点云去畸变模块，除了对点云做运动畸变校正之外，还从IMU原始输出的角度和预积分模块的输出找到与当前帧点云时间最相近的数据，加入发布的消息中跟随点云一起发布。</p>
在后端优化模块中，会优先判断接收的消息中是否有设置好的预积分数据，若有，则使用该数据作为该帧点云的初始值，否则，使用IMU的角度增量作为初始值。当然，特殊情况是第一帧的时候会使用IMU输出的角度作为初始值。 <img src="./imgs/Design-mapOptimization-initialGuess.png" alt="初始值选取" />
<center>
初始值选取
</center>
<p>这里比较特殊的是，初始值是通过计算当前帧的位姿和上一帧的缓存位姿计算位姿增量，然后将该增量应用到上一帧优化后的里程计结果。</p>
<p><span class="math display">\[
T_{incre} = \hat{T}_{pre}^{-1}\hat{T}_{cur}\\
\bar{T}_{cur} = T^{opt}_{pre}T_{incre}
\]</span></p>
<p>以使用预积分数据作为初始值为例，上面公式中的<span class="math inline">\(\hat{T}_{pre},\hat{T}_{cur}\)</span>分别是上一次缓存和当前的消息中包含的预积分位姿；<span class="math inline">\(T_{incre}\)</span>计算除了从上一帧到当前帧的位姿增量；<span class="math inline">\(T^{opt}_{pre}\)</span>是上一帧经过点云匹配、图优化之后的里程计结果；<span class="math inline">\(\bar{T}_{cur}\)</span>则是最终采用的当前帧点云的估计值。</p>
<h3 id="构建局部点云地图">构建局部点云地图</h3>
<figure>
<img src="./imgs/Design-mapOptimization-localMap.png" alt="" /><figcaption>构建局部点云地图</figcaption>
</figure>
<p>局部点云地图简单说就是根据最后一帧关键帧，找到其空间、时间附近的一些其他关键帧，将这些关键帧的点云都使用对应的位姿转换到地图坐标系下，融合成地图坐标系下的局部地图，后面这个局部地图就是点云匹配的目标点云。这个函数主要是一些几何计算。</p>
<h3 id="点云匹配">点云匹配</h3>
<p>这部分用的算法比较复杂，具体参考本项目的另一篇文章<a href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">Simple-LIO-SAM——点云匹配算法详解</a>。 只要明白，经过这个步骤后，在第一步设置的点云位姿初始值已经被点云匹配算法更新为更准确的位姿。 <img src="./imgs/Design-mapOptimization-scan2Map.png" alt="点云匹配" /></p>
<h3 id="因子图构建及优化">因子图构建及优化</h3>
<p>这个步骤稍微比较复杂，我们先理一下目前手头有什么： 1. 经过点云匹配校正后的当前帧的位姿 2. 回环检测得到的某一帧关键帧到另一帧关键帧的相对位姿（这个部分在回环检测线程进行，这里只需要当作现有数据即可） 3. gps里程计（由于这部分需要额外的计算，暂且忽略gps的输入）</p>
<p>PS:这部分需要<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的知识，可以参考本项目的另外一篇文章：<a href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">Simple-LIO-SAM——GTSAM快速入门</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>使用上面两个位姿关系构建因子图，并使用因子图优化算法进行整体的优化，得到全局优化下的关键帧位姿 <img src="./imgs/Design-mapOptimization-graphOpt01.png" alt="因子图构建流程" /></p>
<p><strong>关键帧的选择</strong> 并不是所有的雷达帧都会被当作关键帧，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>使用一种比较简单的方案判断是否将当前帧采纳为关键帧：只有与上一帧关键帧的位姿相差足够大才会采纳为关键帧。</p>
<p><strong>添加激光里程计因子</strong> <img src="./imgs/Design-mapOptimization-graphOpt-odomFactor.png" alt="激光里程计因子" /></p>
<p><strong>回环因子</strong> <img src="./imgs/Design-mapOptimization-graphOpt-loopFactor.png" alt="添加回环因子" /></p>
<p><strong>设置因子图初值并优化</strong> <img src="./imgs/Design-mapOptimization-graphOpt-optimization.png" alt="因子图优化" /></p>
<h3 id="更新历史关键帧位姿">更新历史关键帧位姿</h3>
<p>当有新的回环被检测到，该回环关系被加入因子图进行优化。由于回环关系是一种很强约束性的观测，因此，在观测到新的回环之后，因子图优化对历史关键帧的位姿变化会比较大，因此需要对历史关键帧的位姿一起做一次更新。 <img src="./imgs/Design-mapOptimization-updatePath.png" alt="更新历史位姿" /></p>
<h3 id="发布里程计及可视化点云">发布里程计及可视化点云</h3>
<p>在原始的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>代码中这部分还有较多处理，但实际上并没有太多作用。在本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM" title="Simple LIO-SAM">spl</a>中，已经去除了冗余部分。这部分就只是将计算出来的激光里程计往外发布。</p>
<h2 id="回环检测线程">回环检测线程</h2>
回环检测是SLAM中很重要的一个环节。通过检查当前位置是否已经是到达过的位置，并对重复到达的位置匹配计算位姿。如下图中，<span class="math inline">\(x_5\)</span>与<span class="math inline">\(x_2\)</span>够成回环，<span class="math inline">\(f_5(x_5,x_2)\)</span>是两个位置间的相对位置关系。通过回环之间的约束，对因子图优化器提供很强的信息，使得整体的位姿估计达到全局最优的状态。 <img src="./imgs/loopClosure.png" alt="回环因子" />
<center>
回环因子示意图
</center>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中回环检测使用ICP算法，计算最新的关键帧与可能形成回环的位置的点云匹配，并只有在匹配分数非常好的情况下才采纳这个回环结果。由于这部分是比较耗费计算时间的，并且，回环关系只需要以比较低的状态加入因子图即可，因此，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的<code>mapOptimization.cpp</code>中是使用一个独立线程执行回环检测： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> MO = std::<span class="built_in">make_shared</span>&lt;mapOptimization&gt;(options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回环检测独立线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">loopthread</span><span class="params">(&amp;mapOptimization::loopClosureThread, MO)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>同时，这个线程内部也默认被设为较低的执行频率（默认1Hz） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 回环检测独立线程</span></span><br><span class="line"><span class="comment">  * 1. 由于回环检测中用到了点云匹配，较为耗时，所以独立为单独的线程运行</span></span><br><span class="line"><span class="comment">  * 2. 新的回环关系被检测出来时被主线程加入因子图中优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loopClosureThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loopClosureEnableFlag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 1</span></span><br><span class="line">    <span class="function">rclcpp::Rate <span class="title">rate</span><span class="params">(loopClosureFrequency)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">        <span class="built_in">performLoopClosure</span>();</span><br><span class="line">        <span class="built_in">visualizeLoopClosure</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
回环检测线程的整体流程如下： <img src="./imgs/Design-mapOptimization-loopThread.png" alt="回环检测线程流程图" />
<center>
回环检测线程流程图
</center>
<h3 id="寻找回环对应的帧">寻找回环对应的帧</h3>
<p>当开始寻找新的回环关系时，会根据最后一帧关键帧找到是否有合适的对应帧作为回环帧。主要通过两个约束： 1. 空间位置最近（使用kdtree做距离检索） 2. 时间距离够远（去除时间过近的帧）</p>
<p>这个部分主要是函数<code>detectLoopClosureDistance</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 根据位置关系寻找当前帧与对应帧的索引</span></span><br><span class="line"><span class="comment">  * 1. 将最后一帧关键帧作为当前帧，如果当前帧已经在回环对应关系中，则返回（已经处理过这一帧了）。如果找到的回环对应帧相差时间过短也返回false。回环关系用一个全局map缓存</span></span><br><span class="line"><span class="comment">  * 2. 对关键帧3D位姿构建kd树，并用当前帧位置从kd树寻找距离最近的几帧，挑选时间间隔最远的那一帧作为匹配帧</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @param latestID 传出参数，找到的当前帧索引，实际就是用最后一帧关键帧</span></span><br><span class="line"><span class="comment">  * @param closestID 传出参数，找到的当前帧对应的匹配帧</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">detectLoopClosureDistance</span><span class="params">(<span class="type">int</span> *latestID, <span class="type">int</span> *closestID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> loopKeyCur = copy_cloudKeyPoses3D-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> loopKeyPre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认最后一帧关键帧没有被加入过回环关系中</span></span><br><span class="line">    <span class="keyword">auto</span> it = loopIndexContainer.<span class="built_in">find</span>(loopKeyCur);</span><br><span class="line">    <span class="keyword">if</span> (it != loopIndexContainer.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将关键帧的3D位置构建kdtree，并检索空间位置相近的关键帧</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pointSearchIndLoop;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; pointSearchSqDisLoop;</span><br><span class="line">    kdtreeHistoryKeyPoses-&gt;<span class="built_in">setInputCloud</span>(copy_cloudKeyPoses3D);</span><br><span class="line">    <span class="comment">// 寻找空间距离相近的关键帧</span></span><br><span class="line">    kdtreeHistoryKeyPoses-&gt;<span class="built_in">radiusSearch</span>(copy_cloudKeyPoses3D-&gt;<span class="built_in">back</span>(), historyKeyframeSearchRadius, pointSearchIndLoop, pointSearchSqDisLoop, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保空间距离相近的帧是较久前采集的，排除是前面几个关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)pointSearchIndLoop.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = pointSearchIndLoop[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(copy_cloudKeyPoses6D-&gt;points[id].time - timeLaserInfoCur) &gt; historyKeyframeSearchTimeDiff)</span><br><span class="line">        &#123;</span><br><span class="line">            loopKeyPre = id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到位置关系、时间关系都符合要求的关键帧，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (loopKeyPre == <span class="number">-1</span> || loopKeyCur == loopKeyPre)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *latestID = loopKeyCur;</span><br><span class="line">    *closestID = loopKeyPre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="构建局部地图">构建局部地图</h3>
<p>找到匹配的关键帧id后，会在该关键帧的周围抽取其他关键帧构建局部点云地图。这个步骤跟雷达里程计线程中的局部地图构建是类似的，这里就不再赘述。</p>
<h3 id="点云匹配-1">点云匹配</h3>
<p>这里使用ICP直接对<code>curKeyframeCloud</code>(最后一帧关键帧)和<code>preKeyframeCloud</code>(回环对应帧周围构建的点云地图)做点云匹配，并得出当前帧到回环帧的转换矩阵<span class="math inline">\(T_{cur}^{pre}\)</span></p>
<h3 id="添加回环关系到队列">添加回环关系到队列</h3>
<p>由于回环关系检测跟因子图优化是两个线程，为了避免复杂的线程同步关系，在回环线程中用几个队列将回环关系缓存，在雷达里程计线程中从这几个队列提取相应的回环关系加入因子图。这里主要缓存几个内容：1）、回环索引；2）、回环关系的位姿转换矩阵（也就是ICP的结果）；3）、噪声因子（根据匹配的分数计算的噪声） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9. 将回环索引、回环间相对位姿、回环噪声模型加入全局变量</span></span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">loopIndexQueue.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(loopKeyCur, loopKeyPre));</span><br><span class="line">loopPoseQueue.<span class="built_in">push_back</span>(poseFrom.<span class="built_in">between</span>(poseTo));</span><br><span class="line">loopNoiseQueue.<span class="built_in">push_back</span>(constraintNoise);</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="全局地图可视化线程">全局地图可视化线程</h2>
<p>这个线程主要是将所有历史关键帧，使用关键帧的位姿，全部转换到地图坐标系下，构建一个全局地图，并发布。这个线程完全是为了可视化，同时，处理所有的关键帧也需要很大计算量，因此，这个线程也被默认限制在5Hz的频率下执行。主要操作就是点云坐标系转换，这里就不赘述了。函数是<code>publishGlobalMap</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发布全局地图点云，在全局地图可视化线程中调用</span></span><br><span class="line"><span class="comment">  * 1. 对所有关键帧3D位姿构建KD树</span></span><br><span class="line"><span class="comment">  * 2. 以最后一帧关键帧为索引找出一定半径范围内的所有关键帧</span></span><br><span class="line"><span class="comment">  * 3. 对找出的关键帧数量做降采样</span></span><br><span class="line"><span class="comment">  * 4. 对所有关键帧的点云做拼接（投影到地图坐标系）</span></span><br><span class="line"><span class="comment">  * 5. 对地图点云做降采样</span></span><br><span class="line"><span class="comment">  * 6. 发布全局地图点云</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publishGlobalMap</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/04/06/lio_sam/pcdRegistration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/06/lio_sam/pcdRegistration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——点云匹配算法详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-06 23:17:19" itemprop="dateCreated datePublished" datetime="2023-04-06T23:17:19+08:00">2023-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-10 22:06:53" itemprop="dateModified" datetime="2023-04-10T22:06:53+08:00">2023-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/04/06/lio_sam/pcdRegistration-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——点云匹配算法详解" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——点云匹配算法详解" href="/2023/04/06/lio_sam/pcdRegistration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6bd455643b6442d6e43dd9a0a5cd9a7a" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中激光历程计的点云匹配方法沿用自<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>，这个基于点到线和点到面距离求解最小二乘问题的方法起始被用到很多框架，包括<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>,<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">Lego-LOAM</a>,各种LOAM的变种，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>及其变种。这段点云匹配代码可以说被重用了很多次，但是各个论文对这部分的描述实际上很少或者基本省略，<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>原始论文对这部分的描述与实际的代码实现差别比较大，导致如果想真正看懂这段代码还是挺难的。这篇文章详细地剖析这部分的原理、实现、以及与论文中不同之处。这里面唯一有一点还没有搞清楚的是对于 <a href="#Degenerate">高斯矩阵退化</a>部分的实现。</p>
<p>由于本文主要是想讲明白在上述这些SLAM框架中点云匹配的实现，因此对于最小二乘问题的求解不会详细展开，需要这部分知识可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113946848">最小二乘问题求解的四种解法</a>或者《视觉SLAM十四讲》中关于最小二乘问题求解的章节。</p>
<h2 id="点云-局部地图匹配流程scan-2-map">点云-局部地图匹配流程Scan-2-Map</h2>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，对于每一帧点云<span class="math inline">\(\mathbb{F}_i\)</span>会先进行特征点提取。特征点包括线特征点和平面特征点（具体方法参考本博客文章：xxxx)。我们记提取后的线特征点云为<span class="math inline">\(F^e_i\)</span>，平面特征点云为<span class="math inline">\(F^p_i\)</span>。</p>
<p>经过一段时间后<span class="math inline">\(1,2,3,...,i-1\)</span>后，我们拥有一系列关键帧的线特征点云<span class="math inline">\(F^e_1,F^e_2,F^e_3,...,F^e_{i-1}\)</span>和平面特征点云<span class="math inline">\(F^p_1,F^p_2,F^p_3,...,F^p_{i-1}\)</span>，以及这些关键帧对应的位姿<span class="math inline">\(T_1,T_2,T_3,...,T_{i-1}\)</span>. 同时对于点云<span class="math inline">\(\mathbb{F}_i\)</span>，我们通过IMU里程计还可以获得该帧点云的初始位姿估计<span class="math inline">\(\hat{T}_i\)</span>，这个位姿估计<span class="math inline">\(\hat{T}_i\)</span>其实就是我们要优化的量。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，激光里程计匹配的是当前帧点云和局部地图。局部地图是通过当前帧空间以及时间近邻的其他关键帧构建的。 <img src="./imgs/Design-mapOptimization-scan2MapOpt.png" alt="scan2MapOptimization" /></p>
<p>对于任何一帧点云以及对应的位姿，我们可以将点云转换到地图坐标系： <span class="math display">\[\mathbb{F}^m_i = R_i\mathbb{F}_i+t_i\]</span> 其中<span class="math inline">\(m\)</span>上标指的是地图坐标系，<span class="math inline">\(R_i\)</span>和<span class="math inline">\(t_i\)</span>是位姿<span class="math inline">\(T_i\)</span>中的旋转矩阵和平移向量。</p>
<p>对选择为构建局部地图的关键帧分别应用上式并累加起来（实际累加后会进行体素降采样）后就构成局部地图<span class="math inline">\(M^e_i\)</span>和<span class="math inline">\(M^p_i\)</span>，<span class="math inline">\(e\)</span>和<span class="math inline">\(p\)</span>下标表示edge和planner。</p>
<p>同时，我们对当前帧的特征点云<span class="math inline">\(F^e_i\)</span>和<span class="math inline">\(F^p_i\)</span>应用位姿的初始估计<span class="math inline">\(\hat{T}_i\)</span>可以得到在近似地图坐标系下的点云。为了方便后面叙述，这里省略坐标系和关键帧索引的上下标。重申一下我们的输入：</p>
<ol type="1">
<li>地图坐标系下的局部点云地图<span class="math inline">\(M^e\)</span>和<span class="math inline">\(M^p\)</span></li>
<li>雷达坐标系下的当前帧特征点云<span class="math inline">\(F^e\)</span>和<span class="math inline">\(F^p\)</span></li>
<li>当前帧的初始位姿估计<span class="math inline">\(\hat{T}_i=[\hat{R}_i,\hat{t}_i]\)</span></li>
</ol>
<p>我们的目标就是优化位姿<span class="math inline">\(T_i\)</span>使得用这个位姿将<span class="math inline">\(F^e\)</span>和<span class="math inline">\(F^p\)</span>转换到地图坐标系后与地图点云的匹配程度最好。</p>
<h2 id="几何相关知识">几何相关知识</h2>
<h3 id="点到线距离">点到线距离</h3>
<h4 id="论文中计算方法">论文中计算方法</h4>
<img src="./imgs/LOAM-fig7.png" title="fig:" alt="LOAM-fig7" />
<center>
LOAM论文图7：展示如何根据当前帧的边缘点和平面点在局部地图中找到对应的线和平面
</center>
<p>上图的子图（a）展示如何对当前帧边缘点点集<span class="math inline">\(F^e\)</span>中的每一个点从局部地图<span class="math inline">\(M^e\)</span>中找到对应的直线。对于每一个边缘点<span class="math inline">\(P^{F^e}_i \in F^e\)</span>，从局部地图的边缘点集合<span class="math inline">\(M^e\)</span>中找到最近点<span class="math inline">\(P^{M^e}_j\)</span>，橘色线是点<span class="math inline">\(j\)</span>所在的激光线束，蓝色线是前后相近的另外两条激光线束。从前后两条激光线束（蓝色线）找出与<span class="math inline">\(e_i\)</span>距离最近的点，并选择两者中距离更小的点作为点<span class="math inline">\(P^{M^e}_l\)</span>，则经过点<span class="math inline">\(P^{M^e}_j\)</span>、<span class="math inline">\(P^{M^e}_l\)</span>组成的线为点<span class="math inline">\(P^{F^e}_i\)</span>对应的直线。那么问题就转化为点<span class="math inline">\(P^{F^e}_i\)</span>到经过点<span class="math inline">\(P^{M^e}_j\)</span>、<span class="math inline">\(P^{M^e}_l\)</span>的直线的距离。</p>
<p>该距离计算公式如下：</p>
<p><span class="math display">\[
d_{e}=\frac{|(P^{F^e}_i - P^{M^e}_j)\times (P^{F^e}_i - P^{M^e}_l)|}{|(P^{M^e}_j - P^{M^e}_l)|}\tag{1}
\]</span></p>
<p>公式（1）中分子部分计算的是向量<span class="math inline">\((P^{F^e}_i - P^{M^e}_j)\)</span>和<span class="math inline">\((P^{F^e}_i - P^{M^e}_l)\)</span>的叉积的模长。两个向量的叉积是一个向量，方向于两个向量构成的平面垂直，模长等于两个向量组成的平行四边形面积。公式（1）的分母代表的是该平行四边形对角线的长度。因此分子除以分母就等于直线外一点到直线的距离。</p>
<h4 id="代码中计算方法">代码中计算方法</h4>
<p>在论文中对<span class="math inline">\(F^e\)</span>的点找到<span class="math inline">\(M^e\)</span>对应的直线是通过找到两个距离最近的点，但是在代码中是找到距离最近的5个点，然后计算这5个点的协方差，对协方差做特征值分解，最大的特征值对应的特征向量为主方向，并判断这5个点的分布是否接近直线的要求。 代码中寻找点到局部地图的对应直线，然后计算距离和法向量主要是在<code>mapOptimization</code>中的函数<code>cornerOptimization</code>中完成。</p>
<ol type="1">
<li><p>对点集<span class="math inline">\(F^e\)</span>中的点从局部地图<span class="math inline">\(M^e\)</span>中找到最近5个点 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从局部地图（已经提前设置好kdtree）中找到最近的5个点</span></span><br><span class="line"><span class="comment">// pointSel为检索点</span></span><br><span class="line"><span class="comment">// pointSearchInd存储检索结果的5个点在原始点云中的索引</span></span><br><span class="line"><span class="comment">// pointSearchSqDis存储检索出的5个点与检索点的距离的平方</span></span><br><span class="line">kdtreeCornerFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br></pre></td></tr></table></figure></p></li>
<li><p>计算这5个点的协方差矩阵 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cx,cy,cz是检索出的5个点的中心坐标</span></span><br><span class="line"><span class="type">float</span> cx = <span class="number">0</span>, cy = <span class="number">0</span>, cz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    cx += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">    cy += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">    cz += laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">&#125;</span><br><span class="line">cx /= <span class="number">5</span>; cy /= <span class="number">5</span>;  cz /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协方差矩阵是对称矩阵</span></span><br><span class="line"><span class="type">float</span> a11 = <span class="number">0</span>, a12 = <span class="number">0</span>, a13 = <span class="number">0</span>, a22 = <span class="number">0</span>, a23 = <span class="number">0</span>, a33 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="type">float</span> ax = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].x - cx;</span><br><span class="line">    <span class="type">float</span> ay = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].y - cy;</span><br><span class="line">    <span class="type">float</span> az = laserCloudCornerFromMapDS-&gt;points[pointSearchInd[j]].z - cz;</span><br><span class="line"></span><br><span class="line">    a11 += ax * ax; a12 += ax * ay; a13 += ax * az;</span><br><span class="line">    a22 += ay * ay; a23 += ay * az;</span><br><span class="line">    a33 += az * az;</span><br><span class="line">&#125;</span><br><span class="line">a11 /= <span class="number">5</span>; a12 /= <span class="number">5</span>; a13 /= <span class="number">5</span>; a22 /= <span class="number">5</span>; a23 /= <span class="number">5</span>; a33 /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储协方差的值到matA1</span></span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = a11; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>) = a12; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) = a13;</span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>) = a12; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>) = a22; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) = a23;</span><br><span class="line">matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>) = a13; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">1</span>) = a23; matA1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) = a33;</span><br></pre></td></tr></table></figure></p></li>
<li><p>计算直线方向，也就是特征值分解，最大特征值对应的特征向量为数据主方向 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对协方差矩阵做特征值分解，最大特征值对应的特征向量是这5个点的主方向</span></span><br><span class="line">cv::<span class="built_in">eigen</span>(matA1, matD1, matV1);</span><br></pre></td></tr></table></figure></p></li>
<li><p>计算点到直线距离 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下部分是在计算当前点pointSel到检索出的直线的距离和方向，如果距离够近，则认为匹配成功，否则认为匹配失败</span></span><br><span class="line"><span class="comment">// x0,y0,z0是直线外一点</span></span><br><span class="line"><span class="type">float</span> x0 = pointSel.x;</span><br><span class="line"><span class="type">float</span> y0 = pointSel.y;</span><br><span class="line"><span class="type">float</span> z0 = pointSel.z;</span><br><span class="line"><span class="comment">// matV1的第一行就是5个点形成的直线的方向，cx,cy,cz是5个点的中心点</span></span><br><span class="line"><span class="comment">// 因此，x1,y1,z1和x2,y2,z2是经过中心点的直线上的另外两个点，两点之间的距离是0.2米</span></span><br><span class="line"><span class="type">float</span> x1 = cx + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> y1 = cy + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">float</span> z1 = cz + <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">float</span> x2 = cx - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> y2 = cy - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">float</span> z2 = cz - <span class="number">0.1</span> * matV1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这边是在求[(x0-x1),(y0-y1),(z0-z1)]与[(x0-x2),(y0-y2),(z0-z2)]叉乘得到的向量的模长</span></span><br><span class="line"><span class="comment">// 这个模长是由0.2*V1[0]和点[x0,y0,z0]构成的平行四边形的面积</span></span><br><span class="line"><span class="comment">// 垂直于0,1,2三点构成的平面的向量[XXX,YYY,ZZZ] = [(y0-y1)(z0-z2)-(y0-y2)(z0-z1),-(x0-x1)(z0-z2)+(x0-x2)(z0-z1),(x0-x1)(y0-y2)-(x0-x2)(y0-y1)]</span></span><br><span class="line"><span class="type">float</span> a012 = <span class="built_in">sqrt</span>(((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) * ((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">                + ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) * ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">                + ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)) * ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// l12表示的是0.2*(||V1[0]||)</span></span><br><span class="line"><span class="comment">// 点x1,y1,z1到点x2,y2,z2的距离</span></span><br><span class="line"><span class="type">float</span> l12 = <span class="built_in">sqrt</span>((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求叉乘结果[la&#x27;,lb&#x27;,lc&#x27;]=[(x1-x2),(y1-y2),(z1-z2)]x[XXX,YYY,ZZZ]</span></span><br><span class="line"><span class="comment">// [la,lb,lc]=[la&#x27;,lb&#x27;,lc&#x27;]/a012/l12</span></span><br><span class="line"><span class="comment">// LLL=[la,lb,lc]是0.2*V1[0]这条高上的单位法向量。||LLL||=1；</span></span><br><span class="line"><span class="type">float</span> la = ((y1 - y2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">          + (z1 - z2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lb = -((x1 - x2)*((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1)) </span><br><span class="line">            - (z1 - z2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lc = -((x1 - x2)*((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1)) </span><br><span class="line">            + (y1 - y2)*((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1))) / a012 / l12;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ld2就是点pointSel(x0,y0,z0)到直线的距离</span></span><br><span class="line"><span class="type">float</span> ld2 = a012 / l12;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="点到面距离">点到面距离</h3>
<h4 id="论文中计算方法-1">论文中计算方法</h4>
再次贴出论文中的图 <img src="./imgs/LOAM-fig7.png" alt="LOAM-fig7" />
<center>
LOAM论文图7：展示如何根据当前帧的边缘点和平面点在局部地图中找到对应的线和平面
</center>
<p>与计算点到直线的距离类似，对于一个平面点<span class="math inline">\(P^{F^p}_i \in F^p\)</span>，从局部地图平面点集<span class="math inline">\(M^p\)</span>中找到最近点<span class="math inline">\(P^{M^p}_j\)</span>，再从该点所在的激光线束找到另一个点<span class="math inline">\(P^{M^p}_l\)</span>以及前后两条激光线束中找到另外一个最近点<span class="math inline">\(P^{M^p}_m\)</span>，这样就确保了三个点不会共线。 那么问题就转化为已知经过三个点<span class="math inline">\(P^{M^p}_{jlm}\)</span>的平面，求平面外一点<span class="math inline">\(P^{F^p}_i\)</span>到该平面的距离 首先，根据三个点，我们可以计算该平面的法向量，并归一化为单位法向量</p>
<p><span class="math display">\[
n_{jlm}=(P^{M^p}_j - P^{M^p}_l)\times (P^{M^p}_j - P^{M^p}_m)
\]</span></p>
<p><span class="math display">\[
n_{jlm} = \frac{n_{jlm}}{|n_{jlm}|}
\]</span></p>
<p>于是，点到平面的距离为 <span class="math display">\[
d_p = |(P^{F^p}_i - P^{M^p}_j)n_{jlm}|\tag{2}
\]</span></p>
<h4 id="代码中计算方法-1">代码中计算方法</h4>
<p>在代码中，也是先根据点<span class="math inline">\(P^{F^p}_i\)</span>从局部地图平面点集中找到最近的5个点，然后对这5个点用最小二乘法（求解超定方程）得到拟合平面的法向量。得到平面方程后就可以直接计算点到平面的距离了。这部分代码在<code>mapOptimization.cpp</code>中<code>surfOptimization</code>函数</p>
<ol type="1">
<li><p>从局部地图找到距离最近的5个点 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与边缘点找直线一样，从局部地图的平面点集中找到与pointSel距离最近的5个点</span></span><br><span class="line">kdtreeSurfFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br></pre></td></tr></table></figure></p></li>
<li><p>求解方程Ax+By+Cz+1=0方程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的过程要求解Ax+By+Cz+1=0的平面方程</span></span><br><span class="line"><span class="comment">// 由于有5个点，因此是求解超定方程</span></span><br><span class="line"><span class="comment">// 假设5个点都在平面上，则matA0是系数矩阵，matB0是等号右边的值（都是-1）；matX0是求出来的A，B，C</span></span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">5</span>, <span class="number">3</span>&gt; matA0;</span><br><span class="line">Eigen::Matrix&lt;<span class="type">float</span>, <span class="number">5</span>, <span class="number">1</span>&gt; matB0;</span><br><span class="line">Eigen::Vector3f matX0;</span><br><span class="line"></span><br><span class="line">matA0.<span class="built_in">setZero</span>();</span><br><span class="line">matB0.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">matX0.<span class="built_in">setZero</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">0</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">1</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">    <span class="built_in">matA0</span>(j, <span class="number">2</span>) = laserCloudSurfFromMapDS-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是求解matA0XmatX0 = matB0方程</span></span><br><span class="line">matX0 = matA0.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(matB0);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>求点到平面距离 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pa = <span class="built_in">matX0</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pb = <span class="built_in">matX0</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pc = <span class="built_in">matX0</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">float</span> pd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （pa,pb,pc)是平面的法向量，这里是对法向量规一化，变成单位法向量</span></span><br><span class="line"><span class="type">float</span> ps = <span class="built_in">sqrt</span>(pa * pa + pb * pb + pc * pc);</span><br><span class="line">pa /= ps; pb /= ps; pc /= ps; pd /= ps;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="最小二乘问题求解">最小二乘问题求解</h2>
<p>从前面两步，我们得到了一些边缘点和平面点到局部地图的距离和距离向量，我们的目标就是优化这些距离。由于我们现在有6个未知数，也就是位姿的6个自由度<span class="math inline">\(T_i=[t_x,t_y,t_z,roll,pitch,yaw]\)</span>，但是我们的点超过6个，因此是求解最小二乘问题。</p>
<p>最小二乘问题是最优化里的基础问题，这里就不展开公式推导了，具体可以参考这篇文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113946848">最小二乘问题求解的四种解法</a>。</p>
<p>常见的求解最小二乘问题有高斯牛顿法（Gauss-Newton Method）和列温伯格马夸克法（Levernberg-Marquate），后者是前者的改进。<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>论文里面虽然用的是LM算法，但是在代码中实际用的是GN算法。这里只强调GN算法的核心思路。</p>
<p>GN算法也是迭代更新的算法，每一步重点在与求出未知量的更新方向和步长，每一步将更行向量叠加到未知量上，让目标函数逐渐收敛。</p>
<p>在这里，未知量是位姿<span class="math inline">\(T_i\)</span>，目标函数是点到直线点到平面距离<span class="math inline">\(\mathbb{d}\)</span>，因此，我们在每一步迭代中要找到一个<span class="math inline">\(\Delta{T}_i\)</span>，更新未知量<span class="math inline">\(T_i \larr T_i + \Delta{T}_i\)</span>，并使得距离<span class="math inline">\(\mathbb{b}\)</span>逐渐下降。</p>
<p>在高斯牛顿法中，更新向量的是通过求解增量方程得到 <span class="math display">\[
J(x)J(x)^T\Delta{x}=-J(x)f(x)\tag{3}
\]</span></p>
<p>公式（3）就是高斯牛顿法的增量方程，<span class="math inline">\(J(x)\)</span>是雅克比矩阵，也就是目标函数相对于未知量的偏导；<span class="math inline">\(f(x)\)</span>是目标函数；<span class="math inline">\(\Delta{x}\)</span>就是我们要求的增量。</p>
<h2 id="代码中点云匹配算法基于gn算法">代码中点云匹配算法（基于GN算法）</h2>
<p>这部分内容对于数学公式推导部分主要参考<a target="_blank" rel="noopener" href="https://wykxwyc.github.io/2019/08/01/The-Math-Formula-in-LeGO-LOAM/#lmoptimization%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97">wykxwyc.github.io</a>，但是原文中对于旋转矩阵对欧拉角的求导似乎有点问题，与代码对不上。</p>
<h3 id="欧拉角转旋转矩阵">欧拉角转旋转矩阵</h3>
<p>代码中对角度的表达使用欧拉角表达，因此我们需要先将欧拉角转换为旋转矩阵形式。记<span class="math inline">\(x,y,z\)</span>轴的角度为<span class="math inline">\(\alpha,\beta,\gamma\)</span> <span class="math display">\[
\begin{split}
R_{\alpha}=
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;\cos\alpha&amp;-\sin\alpha\\
0&amp;\sin\alpha&amp;\cos\alpha
\end{bmatrix}
\end{split}
\]</span></p>
<p><span class="math display">\[
\begin{split}
R_{\beta}=
\begin{bmatrix}
\cos\beta&amp;0&amp;\sin\beta\\
0&amp;1&amp;0\\
-\sin\beta&amp;0&amp;\cos\beta
\end{bmatrix}
\end{split}
\]</span></p>
<p><span class="math display">\[
\begin{split}
R_{\gamma}=
\begin{bmatrix}
\cos\gamma&amp;-\sin\gamma&amp;0\\
\sin\gamma&amp;\cos\gamma&amp;0\\
0&amp;0&amp;1\\
\end{bmatrix}
\end{split}
\]</span></p>
<p><strong>PS:</strong> 为了简便起见，我们在后面的推导中使用<span class="math inline">\(c_1,c_2,c_3\)</span>表示<span class="math inline">\(\cos\alpha,\cos\beta,\cos\gamma\)</span>，用<span class="math inline">\(s_1,s_2,s_3\)</span>表示<span class="math inline">\(\sin\alpha,\sin\beta,\sin\gamma\)</span></p>
<p>根据上面转换关系，使用<span class="math inline">\(Z-X-Y\)</span>顺序，将欧拉角转换为旋转矩阵如下</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
R
&amp;=&amp;R_yR_xR_z\\
&amp;=&amp;
\begin{bmatrix}
c_2&amp;0&amp;s_2\\
0&amp;1&amp;0\\
-s_2&amp;0&amp;c_2
\end{bmatrix}
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;c_1&amp;-s_1\\
0&amp;s_1&amp;c_1
\end{bmatrix}
\begin{bmatrix}
c_3&amp;-s_3&amp;0\\
s_3&amp;c_3&amp;0\\
0&amp;0&amp;1
\end{bmatrix}\\
&amp;=&amp;
\begin{bmatrix}
c_2c_3+s_1s_2s_3&amp;-c_2s_3+s_1s_2c_3&amp;c_1s_2\\
c_1s_3&amp;c_1c_3&amp;-s_1\\
-s_2c_3+s_1c_2s_3&amp;s_2s_3+s_1c_2c_3&amp;c_1c_2
\end{bmatrix}
\end{array}
\end{split}
\]</span></p>
<h3 id="目标函数对位姿求雅克比矩阵">目标函数对位姿求雅克比矩阵</h3>
<p><strong>Keep In Mind：位姿<span class="math inline">\(T_i=[t_x,t_y,t_z,\alpha,\beta,\gamma]=[R,t]\)</span>是我们要求的量</strong></p>
<p>对于当前帧特征点<span class="math inline">\(F^e,F^p\)</span>中的一个点<span class="math inline">\(P_i=[p_x,p_y,p_z]\)</span>（这里没有区分边缘点和平面点，因为两者的偏导公式一样），我们使用函数<span class="math inline">\(G(\cdot)\)</span>将其从雷达坐标系转换到局部坐标系(m上标表示地图坐标系) <span class="math display">\[
P^m_i=G(P_i,T_i)=R\cdot P_i+t
\]</span> 我们使用函数<span class="math inline">\(D(\cdot)\)</span>表示该点到局部地图的距离，也就是目标函数 <span class="math display">\[
loss=D(G(P_i,T_i),Map) = d
\]</span> 上式中<span class="math inline">\(d\)</span>对于边缘点代表点到直线距离，对于平面点表示点到平面距离</p>
<p><strong>误差对旋转求偏导</strong> 这里以<span class="math inline">\(x\)</span>轴的旋转<span class="math inline">\(\alpha\)</span>为例</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\frac{\partial loss}{\partial \alpha}
&amp;=&amp;
\frac{\partial D\left(G(P_i,T_i),Map\right)}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial G}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i+t}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i}{\partial \alpha}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R}{\partial \alpha}\cdot P_i
\end{array}
\end{split}\tag{4}
\]</span></p>
<p><strong>误差对平移求偏导</strong> 这里以<span class="math inline">\(x\)</span>轴的平移<span class="math inline">\(t_x\)</span>为例</p>
<p><span class="math display">\[
\begin{split}
\begin{array}{rcl}
\frac{\partial loss}{\partial t_x}
&amp;=&amp;
\frac{\partial D\left(G(P_i,T_i),Map\right)}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial G}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i+t}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}\cdot \frac{\partial R\cdot P_i}{\partial \alpha} + \frac{\partial D}{\partial G}\cdot\frac{\partial t}{\partial t_x}\\
&amp;=&amp;
0+\frac{\partial D}{\partial G}\cdot\frac{\partial t}{\partial t_x}\\
&amp;=&amp;
\frac{\partial D}{\partial G}
\end{array}
\end{split}\tag{5}
\]</span></p>
<p><strong>求解<span class="math inline">\(\frac{\partial D}{\partial G}\)</span></strong> 在上面误差对旋转求偏导中旋转矩阵对欧拉角求偏导<span class="math inline">\(\frac{\partial R}{\partial \alpha}\)</span>已经在前面的章节推导过了。公式(4)(5)还有一个未知量就是<span class="math inline">\(\frac{\partial D}{\partial G}\)</span></p>
<p><span class="math display">\[
\frac{\partial D}{\partial G} = \frac{\partial d}{\partial P^m_i}
\]</span> 也就是说<span class="math inline">\(\frac{\partial D}{\partial G}\)</span>求的是损失函数也就是点到线和点到面的距离相对于点（地图坐标系下）的偏导数。这点可以理解成求一个移动方向，使得让点<span class="math inline">\(P^m_i\)</span>沿着这个方向移动，损失函数上升得最快。很容易想到这个方向就是法线方向（对于点到直线的情况则是直线的垂线方向） 因此</p>
<p><span class="math display">\[
\frac{\partial D}{\partial G} = \frac{\partial d}{\partial P^m_i}=\big(\frac{\partial d}{\partial x}, \frac{\partial d}{\partial y}, \frac{\partial d}{\partial z}\big)=(n_x,n_y,n_z)
\]</span></p>
<h3 id="代码中雅克比矩阵的计算">代码中雅克比矩阵的计算</h3>
<p>这部分计算主要在<code>mapOptimization.cpp</code>中的<code>LMOptimization</code>函数。这里要注意的是，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>这部分代码计算中还加了坐标系的转换，实际上是没有必要的，这部分代码可以看<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的代码，是完全一样的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算三轴欧拉角的sin、cos，后面使用旋转矩阵对欧拉角求导中会使用到</span></span><br><span class="line"><span class="comment">// lidar -&gt; camera</span></span><br><span class="line"><span class="type">float</span> srx = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">1</span>]);</span><br><span class="line"><span class="type">float</span> crx = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">1</span>]);</span><br><span class="line"><span class="type">float</span> sry = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"><span class="type">float</span> cry = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"><span class="type">float</span> srz = <span class="built_in">sin</span>(transformTobeMapped[<span class="number">0</span>]);</span><br><span class="line"><span class="type">float</span> crz = <span class="built_in">cos</span>(transformTobeMapped[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// laserCloudOri是在cornerOptimization、surfOptimization两个函数中找到的有匹配关系的</span></span><br><span class="line"><span class="comment">// 角点和平面点，如果找到的可供优化的点数太少，则跳过此次优化</span></span><br><span class="line"><span class="type">int</span> laserCloudSelNum = laserCloudOri-&gt;<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (laserCloudSelNum &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matA是Jacobians矩阵J</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matA</span><span class="params">(laserCloudSelNum, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAt</span><span class="params">(<span class="number">6</span>, laserCloudSelNum, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtA</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// matB是目标函数，也就是距离</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matB</span><span class="params">(laserCloudSelNum, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matAtB</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// matX是高斯-牛顿法计算出的更新向量</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matX</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matP</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">PointType pointOri, coeff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudSelNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 坐标系转换这部分可以不用看，没有什么作用</span></span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    pointOri.x = laserCloudOri-&gt;points[i].y;</span><br><span class="line">    pointOri.y = laserCloudOri-&gt;points[i].z;</span><br><span class="line">    pointOri.z = laserCloudOri-&gt;points[i].x;</span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    coeff.x = coeffSel-&gt;points[i].y;</span><br><span class="line">    coeff.y = coeffSel-&gt;points[i].z;</span><br><span class="line">    coeff.z = coeffSel-&gt;points[i].x;</span><br><span class="line">    coeff.intensity = coeffSel-&gt;points[i].intensity;</span><br><span class="line">    <span class="comment">// in camera</span></span><br><span class="line">    <span class="comment">// 求雅克比矩阵的值，也就是求目标函数（点到线、平面的距离）相对于tx,ty,tz,rx,ry,rz的导数</span></span><br><span class="line">    <span class="comment">// 具体的公式推导看仓库README中本项目博客，高斯牛顿法方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)，\Delta&#123;x&#125;就是要求解的更新向量matX</span></span><br><span class="line">    <span class="comment">// arx是目标函数相对于roll的导数</span></span><br><span class="line">    <span class="type">float</span> arx = (crx*sry*srz*pointOri.x + crx*crz*sry*pointOri.y - srx*sry*pointOri.z) * coeff.x</span><br><span class="line">              + (-srx*srz*pointOri.x - crz*srx*pointOri.y - crx*pointOri.z) * coeff.y</span><br><span class="line">              + (crx*cry*srz*pointOri.x + crx*cry*crz*pointOri.y - cry*srx*pointOri.z) * coeff.z;</span><br><span class="line">    <span class="comment">// ary是目标函数相对于pitch的导数</span></span><br><span class="line">    <span class="type">float</span> ary = ((cry*srx*srz - crz*sry)*pointOri.x </span><br><span class="line">              + (sry*srz + cry*crz*srx)*pointOri.y + crx*cry*pointOri.z) * coeff.x</span><br><span class="line">              + ((-cry*crz - srx*sry*srz)*pointOri.x </span><br><span class="line">              + (cry*srz - crz*srx*sry)*pointOri.y - crx*sry*pointOri.z) * coeff.z;</span><br><span class="line">    <span class="comment">// arz是目标函数相对于yaw的导数</span></span><br><span class="line">    <span class="type">float</span> arz = ((crz*srx*sry - cry*srz)*pointOri.x + (-cry*crz-srx*sry*srz)*pointOri.y)*coeff.x</span><br><span class="line">              + (crx*crz*pointOri.x - crx*srz*pointOri.y) * coeff.y</span><br><span class="line">              + ((sry*srz + cry*crz*srx)*pointOri.x + (crz*sry-cry*srx*srz)*pointOri.y)*coeff.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在求点到直线的距离时，coeff表示的是如下内容</span></span><br><span class="line"><span class="comment">    [la,lb,lc]表示的是点到直线的垂直连线方向，s是长度</span></span><br><span class="line"><span class="comment">    coeff.x = s * la;</span></span><br><span class="line"><span class="comment">    coeff.y = s * lb;</span></span><br><span class="line"><span class="comment">    coeff.z = s * lc;</span></span><br><span class="line"><span class="comment">    coeff.intensity = s * ld2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在求点到平面的距离时，coeff表示的是</span></span><br><span class="line"><span class="comment">    [pa,pb,pc]表示过外点的平面的法向量，s是线的长度</span></span><br><span class="line"><span class="comment">    coeff.x = s * pa;</span></span><br><span class="line"><span class="comment">    coeff.y = s * pb;</span></span><br><span class="line"><span class="comment">    coeff.z = s * pc;</span></span><br><span class="line"><span class="comment">    coeff.intensity = s * pd2;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lidar -&gt; camera</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">0</span>) = arz;</span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">1</span>) = arx;</span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">2</span>) = ary;</span><br><span class="line">    <span class="comment">// 目标函数相对于tx的导数等于法向量的x</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">3</span>) = coeff.z;</span><br><span class="line">    <span class="comment">// 目标函数相对于ty的导数等于法向量的y</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">4</span>) = coeff.x;</span><br><span class="line">    <span class="comment">// 目标函数相对于tz的导数等于法向量的z</span></span><br><span class="line">    matA.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">5</span>) = coeff.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matB存储的是目标函数（距离）的负值，因为：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)</span></span><br><span class="line">    matB.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">0</span>) = -coeff.intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="更新">更新</h3>
<p>得到雅克比矩阵后就可以直接求解高斯-牛顿法里的增量方程 <span class="math display">\[
J(x)J(x)^T\Delta{x}=-J(x)f(x)\tag{3}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">transpose</span>(matA, matAt);</span><br><span class="line">matAtA = matAt * matA;</span><br><span class="line">matAtB = matAt * matB;</span><br><span class="line"><span class="comment">// 求解高斯-牛顿法中的增量方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)，这里解出来的matX就是更新向量</span></span><br><span class="line"><span class="comment">// matA是雅克比矩阵J</span></span><br><span class="line"><span class="comment">// matAtB是上面等式中等号的右边，负号在matB赋值的时候已经加入</span></span><br><span class="line">cv::<span class="built_in">solve</span>(matAtA, matAtB, matX, cv::DECOMP_QR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将增量matX叠加到变量（位姿）transformTobeMapped中</span></span><br><span class="line">transformTobeMapped[<span class="number">0</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">1</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">2</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">3</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">4</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">transformTobeMapped[<span class="number">5</span>] += matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高斯矩阵退化">高斯矩阵退化</h3>
<div id="Degenerate">

</div>
<p>这部分代码其实有一小段没办法完全理解，就是在进行第一次迭代时会对近似Hessian矩阵做是否退化的的判断，然后对退化的方向进行处理，最后对增量进行重新加权。但是实在没有找到这种用法的出处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是第一次迭代，判断求解出来的近似Hessian矩阵，也就是J^&#123;T&#125;J:=matAtA是否退化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这部分的计算说实话没有找到很好的理论出处，这里只能大概说一下这段代码想要做的事情</span></span><br><span class="line"><span class="comment">    * 这里用matAtA也就是高斯-牛顿中的近似海瑟（Hessian）矩阵H。求解增量方程：J^&#123;T&#125;J\Delta&#123;x&#125; = -Jf(x)</span></span><br><span class="line"><span class="comment">    * 要求H:=J^&#123;T&#125;J可逆，但H不一定可逆。下面的代码通过H的特征值判断H是否退化，并将退化的方向清零matV2。而后又根据</span></span><br><span class="line"><span class="comment">    * matV.inv()*matV2作为更新向量的权重系数，matV是H的特征向量矩阵。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (iterCount == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">matE</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matV2</span><span class="params">(<span class="number">6</span>, <span class="number">6</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对近似Hessian矩阵做特征值分解，matE是特征值，matV是特征向量。opencv的matV中每一行是一个特征向量</span></span><br><span class="line">    cv::<span class="built_in">eigen</span>(matAtA, matE, matV);</span><br><span class="line">    matV.<span class="built_in">copyTo</span>(matV2);</span><br><span class="line"></span><br><span class="line">    isDegenerate = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> eignThre[<span class="number">6</span>] = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matE.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, i) &lt; eignThre[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                matV2.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isDegenerate = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matP = matV.<span class="built_in">inv</span>() * matV2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当第一次迭代判断到海瑟矩阵退化，后面会使用计算出来的权重matP对增量matX做加权组合</span></span><br><span class="line"><span class="keyword">if</span> (isDegenerate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">matX2</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_32F, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    matX.<span class="built_in">copyTo</span>(matX2);</span><br><span class="line">    matX = matP * matX2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="收敛条件判断">收敛条件判断</h3>
<p>当增量步长达到一定阈值后，认为优化已经收敛，因此可以跳出后续迭代。这里用增量中的角度增量和平移增量的幅度做判断。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算roll、pitch、yaw的迭代步长</span></span><br><span class="line"><span class="type">float</span> deltaR = <span class="built_in">sqrt</span>(</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>)), <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(pcl::<span class="built_in">rad2deg</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)), <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 计算tx，ty，tz的迭代步长</span></span><br><span class="line"><span class="type">float</span> deltaT = <span class="built_in">sqrt</span>(</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(matX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span>, <span class="number">0</span>) * <span class="number">100</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果迭代的步长达到设定阈值，则认为已经收敛</span></span><br><span class="line"><span class="keyword">if</span> (deltaR &lt; <span class="number">0.05</span> &amp;&amp; deltaT &lt; <span class="number">0.05</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// converged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/30/lio_sam/imuPreintegration-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——IMU预积分模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-30 20:55:54" itemprop="dateCreated datePublished" datetime="2023-03-30T20:55:54+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-31 22:32:13" itemprop="dateModified" datetime="2023-03-31T22:32:13+08:00">2023-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/30/lio_sam/imuPreintegration-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——IMU预积分模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——IMU预积分模块" href="/2023/03/30/lio_sam/imuPreintegration-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::447e7d053e8cf00fca42d617e062a049" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><img src="./imgs/Design-Pipelines-IMU.png" alt="Pipelines-ImuPreintegration" /> IMU预积分模块无论在VIO或者LIO中都是一个非常重要的模块。VIO或者LIO中的<code>I</code>，也就是<code>Inertial</code>指的是惯性，基本上在这类SLAM框架里指的就是IMU里程计。 IMU可以输出车辆坐标系下的三轴加速度、三轴角速度、三轴地磁计（九轴IMU）。我们都知道，加速度的积分是速度、速度的积分是距离，角速度的积分是角度，地磁计可以计算与地磁北极的偏角，因此，如果IMU的输出是准确的话，使用IMU原始数据并进行积分就可以得到车辆的位姿。然而，目前无论多么高精度的IMU，都很难在较长时间下保持较高的准确度，而且积分会对误差也进行积分，导致IMU里程计只能用来做短时间内的位姿校正。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>是IMU里程计和激光雷达里程计紧耦合的SLAM框架。“紧耦合”三个字在IMU预积分模块得到明显的表达。如果用一句话说明IMU预积分模块的作用，那就是：利用IMU数据，为车辆位姿提供一个较好的位姿初始估计。由于目前的激光雷达大部分是10Hz，部分可以达到20Hz以上，因此，在两帧雷达点云期间，车辆会发生旋转和位移，如果旋转和位移很小，那么点云匹配就能够单独算出一个较准确的里程计（在运动缓慢的情况下，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>即使去除了IMU预积分也可以工作，只需要不启动imuPreintegration节点即可）；但是如果旋转和位移较大，点云匹配就可以失败；IMU一般拥有较高频率（200Hz以上），因此可以为两帧雷达点云的匹配提供较好的初始位姿值。</p>
<p>前面提到单纯利用IMU数据做积分，时间一场误差累积会很大，无法提供良好的初始位姿估计，因此需要融合其他传感器校正IMU积分算法。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，通过不断从激光里程计获取最新的里程计信息，作为IMU积分算法的观测来达到校正IMU积分算法的目的。</p>
<p><em>PS：此部分代码很大程度利用了<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>，因此，需要提前阅读本项目《Simple-LIO-SAM——GTSAM快速入门》一章</em></p>
<h2 id="imu预积分模块的整体框架流程图">IMU预积分模块的整体框架流程图</h2>
<img src="./imgs/Design-imuPreintegration-top01.png" title="fig:预积分模块流程图" alt="整体框架流程图" />
<center>
预积分模块流程图
</center>
<h2 id="偏差估计和imu里程计">偏差估计和IMU里程计</h2>
<p>这个模块容易让人看晕的地方在与模块里有两个队列缓存IMU原始数据，同时有两个IMU预积分器。只所以需要有两个预积分器的原因在于，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中对于IMU的预积分，在预测时（predict）需要指明上一时刻的<code>bias</code>，也就是IMU的积分误差。通常这个<code>bias</code>会随着时间慢慢改变，因此不能用离线标定的数据直接使用。于是，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，有一个线程（LaserHandler）会利用激光里程计当作额外的观测量，不断估计最新的<code>bias</code>值。而另一个线程（ImuHandler）则可以一直利用最新的<code>bias</code>值对实时接收到的IMU数据做积分，并发布为IMU里程计。</p>
<p>为了简单起见，我们将用来做偏差估计的队列和预积分器叫做<strong>优化队列</strong>和<strong>优化预积分器</strong>；将用来实时对IMU数据积分并发布IMU里程计的队列和预积分器叫做<strong>IMU队列</strong>和<strong>IMU预积分器</strong>。</p>
一图胜千言，下面这幅图描述了两个队列是如何被耦合起来输出更为准确的IMU预积分结果。其中<code>imuQueOpt</code>是优化队列，<code>imuQueImu</code>是IMU队列，两者命令与代码中一致。 <img src="./imgs/TwoImuQues.png" alt="两个IMU队列" />
<center>
线程交互图
</center>
<h2 id="偏差估计线程即odometryhandler">偏差估计线程——即odometryHandler</h2>
<p>这个回调函数占据了预积分模块大部分内容，而且有较多的重置条件和与<code>imuHandler</code>线程同步的操作，比较容易弄混。</p>
<p>这个回调函数会在接收到新的一帧雷达里程计（发自<code>MapOptimization</code>模块），主要操作上图中的<code>imuQueOpt</code>和<code>优化预积分器</code>。每当节点新收到一帧雷达里程计时，就会执行<code>预积分模块流程图</code>中左侧的一系列操作。主要目的就是利用雷达里程计做观测数据，实时更新IMU的偏差<code>bias</code>。同时，更新过的<code>bias</code>会传递到<code>IMU预积分器</code>。</p>
<h3 id="系统初始化">系统初始化</h3>
<img src="./imgs/Design-imuPreintegration-sysinit.png" title="fig:" alt="SystemInitialization" />
<center>
系统初始化流程
</center>
<p>当接收到第一帧雷达里程计时，需要对系统做初始化操作。主要包括因子图、因子图优化器、两个预积分器的初始化。由于初始化操作需要将第一帧雷达里程计的位姿作为先验因子，因此不能在构造函数中初始化。</p>
<h3 id="判断是否应该重置因子图">判断是否应该重置因子图</h3>
<img src="./imgs/Design-imuPreintegration-reset.png" title="fig:" alt="ResetSystem" />
<center>
重置系统
</center>
<p>为了保证拥有足够的实时性（预积分模块需要与IMU频率保持一致），<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的预积分模块在因子图中里程计因子数量大于100时会重置因子图与优化器。操作主要是从当前的因子图优化器拿出最新结果，并当作先验因子构造新的因子图。</p>
<h3 id="对优化队列中imu原始数据进行积分">对优化队列中IMU原始数据进行积分</h3>
<img src="./imgs/Design-imuPreintegration-integraOpt.png" title="fig:" alt="IntegrateOpt" />
<center>
积分优化队列
</center>
<p>这里要重新回顾上文的<code>线程交互图</code>。偏差估计线程的主要目的就是为IMU里程计线程提供最新的<code>bias</code>估计，因此每当到达新的一帧雷达里程计，意味着有新的观测到达，<code>bias</code>就可以进行更新。于是需要对优化队列中在当前雷达里程计时间之前的IMU原始数据用IMU预积分器进行积分，然后构造IMU因子。将IMU因子和雷达里程计加入因子图优化，得出最新的<code>bias</code>估计。</p>
<h3 id="因子图优化">因子图优化</h3>
<img src="./imgs/Design-imuPreintegration-factorgraph.png" title="fig:" alt="FactorGraphOptimization" />
<center>
因子图优化
</center>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>可以使用IMU预积分器构造IMU因子。利用<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>可以用因子图优化出<code>速度</code>,<code>IMU bias</code>,<code>位姿</code>的估计。</p>
<h3 id="传递优化结果">传递优化结果</h3>
<p><img src="./imgs/Design-imuPreintegration-setBias.png" alt="TransferOptimizationResults" /> 使用因子图优化出最新的IMU偏差估计之后，实际上还有优化后的位姿，这个位姿和IMU偏差会用来重置另外一个预积分器——IMU预积分器。IMU预积分器是在另一个回调函数中被主要使用，回顾<code>线程交互图</code>的下半部分和<code>模块流程图</code>的右侧流程。同时，设置完<code>IMU预积分器</code>之后，会将<code>imuQueImu</code>中剩余的其他IMU原始数据放入<code>IMU预积分器</code>做积分，这样<code>IMU预积分器</code>就一直保持最新状态，在<code>imuHandler</code>中可以实时积分并发布IMU里程计。</p>
<h2 id="imu里程计线程即imuhandler">IMU里程计线程——即imuHandler</h2>
这个回调函数比起odometryHandler就要简单很多。这个回调函数的主要功能就只有两个：1）不断地将新收到的IMU数据塞入两个放置IMU原始数据的队列——<code>线程交互图</code>中的imuQueOpt和imuQueImu；2）使用<code>IMU预积分器</code>对收到的IMU数据做积分，并将结果作为IMU里程计发布。 主要流程如下图： <img src="./imgs/Design-imuPreintegration-imuHandler.png" alt="imuHandler" />
<center>
imuHandler
</center>
<p>这个回调函数比较简单，就不再赘述。</p>
<h2 id="代码要点">代码要点</h2>
<h3 id="坐标系转换">坐标系转换</h3>
<p>IMU预积分模块中代码涉及到多次坐标系转换。主要是要明白IMU积分的原理和<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中坐标系的转换关系。关于坐标系有几个注意要点：</p>
<p><strong>1. 所有IMU原始数据都会先旋转到与雷达的坐标系朝向一致后再进行处理</strong></p>
<p>在<code>imuHandler</code>中每收到一个IMU数据就先旋转再存放。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L555-L556">code</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU数据旋转到lidar的旋转朝向</span></span><br><span class="line">sensor_msgs::msg::Imu thisImu = <span class="built_in">imuConverter</span>(*imu_raw);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存IMU数据</span></span><br><span class="line">imuQueOpt.<span class="built_in">push_back</span>(thisImu);</span><br><span class="line">imuQueImu.<span class="built_in">push_back</span>(thisImu);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 里程计都是对齐到雷达坐标系</strong></p>
<p>所有在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中发布出来的里程计，无论是IMU里程计或者是雷达里程计，度量的都是雷达在地图坐标系下的位姿。但是在IMU预积分模块的偏差估计线程中，使用IMU数据做积分，又需要使用雷达里程计作为观测，两者要同时加入因子图中，所以必须统一两者的坐标系。IMU原始数据在上面提到的第一个注意要点已经旋转到对齐雷达的方向，两者之间还差一个平移。因此，在接收到雷达里程计时，会先平移到旋转后的IMU坐标系，最后再平移回来。 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L298-L300">雷达里程计平移到旋转后的IMU坐标系代码</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化因子图的prior状态</span></span><br><span class="line"><span class="comment">// 将雷达里程计位姿平移到IMU坐标系，只是做了平移</span></span><br><span class="line">prevPose_ = lidarPose.<span class="built_in">compose</span>(lidar2Imu);</span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L585-L587">将IMU里程计对齐到雷达坐标系代码</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将IMU里程计完全对齐到雷达（剩下一个平移关系）</span></span><br><span class="line">gtsam::Pose3 imuPose = gtsam::<span class="built_in">Pose3</span>(currentState.<span class="built_in">quaternion</span>(), currentState.<span class="built_in">position</span>());</span><br><span class="line">gtsam::Pose3 lidarPose = imuPose.<span class="built_in">compose</span>(imu2Lidar);</span><br></pre></td></tr></table></figure></p>
<h3 id="时间同步">时间同步</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中各个模块都是进行异步通信（ros topic），因此在每个模块里面都有几个队列保存数据，处理的时候再根据时间戳做同步。IMU预积分模块中有多个地方对数据做了时间戳同步。 比如在更新完<code>bias</code>之后，对IMU队列做积分时，会先抛弃早于最新的雷达里程计时间之前的数据。<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM/blob/dda6459aaf79913ab27d1950ccac14e07ce8ec71/src/imuPreintegration.cpp#L480-L486">code link</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样先做IMU数据队列和雷达里程计的时间同步</span></span><br><span class="line"><span class="type">double</span> lastImuQT = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!imuQueImu.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp) &lt; currentLidarOdomTime - <span class="type">sync_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lastImuQT = <span class="built_in">stamp2Sec</span>(imuQueImu.<span class="built_in">front</span>().header.stamp);</span><br><span class="line">    imuQueImu.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/27/lio_sam/gtsam-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-title-link" itemprop="url">Simple-LIO-SAM——GTSAM快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-27 21:28:48" itemprop="dateCreated datePublished" datetime="2023-03-27T21:28:48+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-29 19:16:46" itemprop="dateModified" datetime="2023-03-29T19:16:46+08:00">2023-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/27/lio_sam/gtsam-quickstart/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——GTSAM快速入门" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——GTSAM快速入门" href="/2023/03/27/lio_sam/gtsam-quickstart/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::0d35c30bd7aedf439c2d1184605769ac" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="前言">前言</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>其中的两大模块<code>imuPreintegration</code>和<code>mapOptimization</code>都依赖了因子图优化框架——<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>。 为了确保本项目的自洽性以及后面章节讲解的展开，不介绍一下因子图后端优化算法似乎说不过去。但是笔者目前对因子图的原理还没有进行非常详细的推导，因此这部分 内容会偏向如何对<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>快速入门。当然，最快速的入门方式就是完整地阅读一遍<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的官方教程。这部分章节只是拙劣地进行知识的搬迁，当然不是直接将 <a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的教程直接翻译过来。本章节会介绍<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>快速入门的知识，同时讲解<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>提供的<code>examples</code>中跟<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>联系较为紧密的一两个，同时指明<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中的用法出处。 至少阅读完本章节后应该能够对因子图有基本的认识，并且能够看懂<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中对<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的使用</p>
<h2 id="slam后端图优化">SLAM后端——图优化</h2>
<h3 id="问题描述">问题描述</h3>
<p>让我们先回归问题本身。在SLAM中，我们可以拥有多个输入，我们的最终目的是获取一条最准确的轨迹，然后使用这条准确的轨迹实时构建地图。在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中，我们有以下输入： 1. IMU数据； 2. 点云数据； 3. GPS数据（可选）； 4. 回环检测；</p>
<p>我们的问题是如何使用这些数据计算出一条最准确的历史轨迹，使用该轨迹就可以将对应的点云投影到地图坐标系，以此来建立一个点云格式地图。 PS：这只是SLAM的一个形式，就是优化出一条光滑准确的轨迹，这也是在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中使用的方法，因此本文以这种类型作为讲解。</p>
<h3 id="非线性优化">非线性优化</h3>
<p>在SLAM领域后端优化的一个分支是<code>滤波器方法</code>，主要以扩展卡尔曼滤波方法为主，采用隐马尔科夫假设，只保存上一次状态，并通过当前输入预测当前状态，偶尔通过观测修正状态。具体可见本博客的卡尔曼滤波相关文章。</p>
<p>目前的后端优化主要以各种非线性优化方法为主，把批量的位姿加入目标方程（projective function）一起优化，得到具有更好的全局性质的解。 <span class="math display">\[
\mathbf{x}^* = \argmin_{\mathbf{x}}\mathbb{F}(\mathbf{x})
\]</span> 其中，<span class="math inline">\(\mathbb{F}\)</span>是历史轨迹引入的各个误差之和 <span class="math display">\[
\mathbb{F}(\mathbf{x}) = \sum\mathbf{e}(x_i,c_{ij},x_j)
\]</span> <span class="math inline">\(x_i,x_j\)</span>是历史时刻的位姿，<span class="math inline">\(c_{ij}\)</span>是两者之间的约束（可以认为是观测或者输入）</p>
<p><strong>PS：再重申一句，SLAM后端体系很庞大，不是一篇文章能说清楚的，笔者目前也还没有这个能力。目前只求能够稍微讲清楚<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中是怎么被使用的即可。</strong></p>
<p>为了求解非线性方程在不同的SLAM任务中的特点，又发展出各种不同的优化方式，比如VIO中有Bundle Adjustment，有其他叫PoseGraph的，还有<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中使用的FactorGraph。 简单理解就是这些都是非线性方程和求解在不同的任务场景中的细分。后面有机会再单独列一篇文章讲解这些后端优化方法把。 <img src="./imgs/introToBA.png" alt="一图说明BA" /></p>
<h3 id="图优化">图优化</h3>
<p><strong>以下内容大量引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-repo/doc/gtsam.pdf</a></strong></p>
<p>为了批量优化历史位姿<span class="math inline">\(\mathbf{x} = \{x_0, x_1, x_2, ... x_i\}\)</span>，研究者将图论引入SLAM后端优化。每一个机器的位姿<span class="math inline">\(x_i\)</span>是图中的顶点；通过各种里程计计算，比如连续位姿间的IMU积分结果或者点云匹配结果，成为两个位姿<span class="math inline">\(x_i,x_j\)</span>之间的边；对于一些额外的观测，比如GPS数据，成为连接顶点的一元边（只有一端连接到顶点）。比如下图(引用自：<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>) <img src="./imgs/egForFactorGraph.png" alt="FactorGraph" /></p>
<h2 id="gtsam">GTSAM</h2>
<p>GTSAM使用因子图（FactorGraph）作为通用的图问题描述框架，并为各种机器人任务提供实现好的优化算法API，使得研究者快速开发后端优化框架。</p>
<p><strong>图优化（GraphOptimization）vs. <a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中使用的因子图优化（FactorGraph Optimization）区别 vs. BA</strong></p>
<ol type="1">
<li><strong>图优化</strong>似乎一般指位姿图（PoseGraph）的优化，图中的顶点都是机器人的位姿</li>
<li><strong>BA</strong>(Bundle Adjustment)似乎一般指在视觉SLAM中对地标（Landmarks）和位姿同时优化的方法</li>
<li><strong>GTSAM</strong>的因子图除了能够构建位姿图之外，还可以将速度、偏差、IMU预积分等当作顶点和边加入图中。另外，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>框架实现了iSAM和iSAM2两个递增式优化器</li>
</ol>
<h3 id="重要概念">重要概念</h3>
<p><strong>变量（variables）</strong>：因子图中的每一个顶点是一个代求的变量。假设我们只需要求解每一个时刻的机器人姿态，那么每个顶点就是该时刻的机器人位姿，如上图中的<span class="math inline">\({X_1,X_2,X_3}\)</span></p>
<p><strong>值（values）</strong>：值是每个变量数值。在调用优化器对因子图做优化时，我们要先为每个变量设置初始值，优化结束后再从优化器中拿出每个变量优化后的值。</p>
<p><strong>因子（factors）</strong>：因子是因子图中的边，每条边都可以视为一个因子，每个因子又可以认为是一个约束。比如连续两个位姿之间可以由IMU计算出两个位姿的变换，该变换作为一条边加入因子图连接两个变量（<code>二元因子：binary factor</code>）；又或者在某个时刻有GPS数据输入，GPS数据是一个观测，也可以作为一个因子加入因子图，这时候GPS的边只有一端连接到变量（<code>一元因子：unary factor</code>）。</p>
<p><strong>因子图（factor graph）</strong>：因子图由顶点（变量）和因子（边）构成。</p>
<p><strong>优化器（Optimizer）</strong>：因子图只是建模了SLAM的历史位姿和输入与观测间的关系，如何求解这个因子图也就是如何设置变量使得整个图最符合所有的约束（误差最小）则需要用到优化器。除了最常见的求解非线性问题的<code>Gaussian-Newton</code>和<code>Levenberg-Marquardt</code>优化器之外，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>还实现了两个增量式优化器<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>,<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a></p>
<p><strong>键（Keys）</strong>：往因子图添加因子需要指定该因子连接到哪些变量。GTSAM中使用键来指明。一元因子需要指明其连接到第几个变量；二元因子需要指明其连接到哪两个变量。因子图中每个变量的键都应该是唯一的。为了方便在多种变量类型的情况下指明键，GTSAM提供<code>Symbols</code>来让用户方便生成不同变量类型的键值。（键不一定是连续的，但必须是唯一的）</p>
<h3 id="gtsam例子最小例子">GTSAM例子——最小例子</h3>
<p>本小节引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>—第2章 以构建并求解下面因子图为例 <img src="./imgs/gtsam-minExample.png" alt="GTSAM最小例子" /> 图中<span class="math inline">\(x_1,x_2,x_3\)</span>为机器人三个时刻的位姿；<span class="math inline">\(f_0\)</span>为第一个时刻机器人位姿的观测；<span class="math inline">\(f_1,f_2\)</span>为时刻1-2和时刻2-3之间的里程计估计。<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/OdometryExample.cpp">代码</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个空的非线性因子图</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建先验因子，也就是图中的f_0</span></span><br><span class="line"><span class="comment">// 这里使用二维姿态（x,y,theta）简化问题</span></span><br><span class="line"><span class="function">Pose2 <span class="title">priorMean</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 高斯噪声，代表我们对该因子的不确定性</span></span><br><span class="line"><span class="keyword">auto</span> priorNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将先验因子加入因子图</span></span><br><span class="line"><span class="comment">// 其中的1表示该因子连接到第1个变量</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, priorMean, priorNoise));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建里程计因子，也就是图中的f_1,f_2</span></span><br><span class="line"><span class="comment">// 往前移动2米，y轴不便，theta不变</span></span><br><span class="line"><span class="function">Pose2 <span class="title">odometry</span><span class="params">(<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> odometryNoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将里程计因子加入因子图</span></span><br><span class="line"><span class="comment">// 1,2代表该里程计约束是从变量1到变量2</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">1</span>, <span class="number">2</span>, odometry, odometryNoise));</span><br><span class="line"><span class="comment">// 添加相同的因子到变量2和变量3之间</span></span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose2&gt;(<span class="number">2</span>, <span class="number">3</span>, odometry, odometryNoise));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置各个变量的初始值</span></span><br><span class="line">Values initial;</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="built_in">Pose2</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="built_in">Pose2</span>(<span class="number">2.3</span>, <span class="number">0.1</span>, <span class="number">-0.2</span>));</span><br><span class="line">initial.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="built_in">Pose2</span>(<span class="number">4.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用优化器并使用设定好的初始值对因子图优化</span></span><br><span class="line">Values result = <span class="built_in">LevenberMarquardtOptimizer</span>(graph, initial).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure></p>
<h3 id="gtsam例子imu预积分及imufactor">GTSAM例子——IMU预积分及ImuFactor</h3>
<p>在目前的SLAM，无论是VIO还是LIO，前端都需要IMU做积分得到一个位姿的初始估计。<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中实现了一个IMU预积分算法，并可以将其直接加入因子图中做优化。这在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中也被使用到。 本例子引用自<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/ImuFactorsExample2.cpp">GTSAM-repo/examples/ImuFactorExample2.cpp</a>，为了说明<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>中IMU预积分器及<code>ImuFactor</code>的用法，对该例子进行简化。最后构建出的因子图如下（为了可视化，人工调整了布局）： <img src="./imgs/ImuFactorGraph.png" alt="ImuFactorGraph" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，完整代码见下文</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IMU 预积分器</span></span><br><span class="line"><span class="comment">// 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span></span><br><span class="line"><span class="keyword">auto</span> params = PreintegrationParams::<span class="built_in">MakeSharedU</span>(kGravity);</span><br><span class="line">params-&gt;<span class="built_in">setAccelerometerCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setGyroscopeCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setIntegrationCovariance</span>(I_3x3 * <span class="number">0.1</span>);</span><br><span class="line">params-&gt;<span class="built_in">setUse2ndOrderCoriolis</span>(<span class="literal">false</span>);</span><br><span class="line">params-&gt;<span class="built_in">setOmegaCoriolis</span>(<span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 设置IMU预积分器</span></span><br><span class="line"><span class="function">PreintegratedImuMeasurements <span class="title">accum</span><span class="params">(params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个非线性因子图</span></span><br><span class="line">NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明因子图的初始值和优化结果</span></span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置位姿的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量x0的一元因子</span></span><br><span class="line"><span class="comment">// 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span></span><br><span class="line"><span class="keyword">auto</span> noise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(</span><br><span class="line">    (<span class="built_in">Vector</span>(<span class="number">6</span>) &lt;&lt; Vector3::<span class="built_in">Constant</span>(<span class="number">0.1</span>), Vector3::<span class="built_in">Constant</span>(<span class="number">0.3</span>)).<span class="built_in">finished</span>());</span><br><span class="line"><span class="comment">// 将位姿的先验因子加入因子图中</span></span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0, noise);</span><br><span class="line"><span class="comment">// 将位姿0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(<span class="number">0</span>), pose_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置IMU偏差的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量b0的一元因子</span></span><br><span class="line">Key biasKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> biasnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(Vector6::<span class="built_in">Constant</span>(<span class="number">0.1</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>(), biasnoise);</span><br><span class="line"><span class="comment">// 将IMU偏差b0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置速度的先验因子</span></span><br><span class="line"><span class="comment">// 对应到上图中连接到变量v0的一元因子</span></span><br><span class="line"><span class="comment">// 这里设置初始速度为0：Vector3(0,0,0)</span></span><br><span class="line"><span class="keyword">auto</span> velnoise = noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">newgraph.<span class="built_in">addPrior</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), velnoise);</span><br><span class="line"><span class="comment">// 将速度v0的初始值加入初始估计集合</span></span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(<span class="number">0</span>), <span class="built_in">Vector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于机器人的所有位姿时刻（关键帧）</span></span><br><span class="line"><span class="keyword">for</span> (i in N_steps)</span><br><span class="line">&#123;</span><br><span class="line">  biasKey++;</span><br><span class="line">  Symbol b1 = biasKey - <span class="number">1</span>;</span><br><span class="line">  Symbol b2 = biasKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置i时刻的位姿初始值</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">X</span>(i), pose_i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于两个时刻之间的所有IMU数据进行积分</span></span><br><span class="line">  <span class="keyword">for</span> (j in N_imu_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    accum.<span class="built_in">integrateMeasurement</span>(measuredAcc, measuredOmega, <span class="type">delta_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用预积分器构建IMU因子，并加入因子图中</span></span><br><span class="line">  <span class="comment">// IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span></span><br><span class="line">  <span class="function">ImuFactor <span class="title">imufac</span><span class="params">(X(i - <span class="number">1</span>), V(i - <span class="number">1</span>), X(i), V(i), biasKey, accum)</span></span>;</span><br><span class="line">  newgraph.<span class="built_in">add</span>(imufac);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加两个时刻之间IMU偏差因子</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::<span class="built_in">ConstantBias</span>(), cov);</span><br><span class="line">  newgraph.<span class="built_in">add</span>(f);</span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(biasKey, imuBias::<span class="built_in">ConstantBias</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">V</span>(i), linear_velocity_vector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重值IMU预积分器</span></span><br><span class="line">  accum.<span class="built_in">resetIntegration</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用LM优化器对因子图进行优化并获取优化结果</span></span><br><span class="line">result = <span class="built_in">LevenbergMarquardtOptimizer</span>(newgraph, initialEstimate).<span class="built_in">optimize</span>();</span><br></pre></td></tr></table></figure></p>
<details class="note info no-icon"><summary><p>IMU预积分及IMU因子完整代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre>
</td>
<td class="code">
<pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @file ImuFactorExample2</span><br><span class="line"> * @brief Test example for using GTSAM ImuFactor and ImuCombinedFactor with ISAM2. Simplify and add graphviz by Zeal</span><br><span class="line"> * @author Robert Truax</span><br><span class="line"> * @author Zeal</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;gtsam/geometry/PinholeCamera.h&gt;</span><br><span class="line">#include &lt;gtsam/geometry/Cal3_S2.h&gt;</span><br><span class="line">#include &lt;gtsam/inference/Symbol.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuBias.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/ImuFactor.h&gt;</span><br><span class="line">#include &lt;gtsam/navigation/Scenario.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/ISAM2.h&gt;</span><br><span class="line">#include &lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span><br><span class="line">#include &lt;gtsam/slam/BetweenFactor.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace gtsam;</span><br><span class="line"></span><br><span class="line">// Shorthand for velocity and pose variables</span><br><span class="line">using symbol_shorthand::V;</span><br><span class="line">using symbol_shorthand::X;</span><br><span class="line"></span><br><span class="line">const double kGravity = 9.81;</span><br><span class="line"></span><br><span class="line">/* ************************************************************************* */</span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // 起点</span><br><span class="line">  Pose3 pose_0(Rot3::Rodrigues(0, 0, 0), Point3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // 设置一个姿态仿真器，姿态沿着y轴以5m/s的速度前进，没有角度变化</span><br><span class="line">  Vector3 angular_velocity_vector(0, 0, 0);</span><br><span class="line">  Vector3 linear_velocity_vector(0, 5, 0);</span><br><span class="line">  auto scenario = ConstantTwistScenario(angular_velocity_vector,</span><br><span class="line">                                        linear_velocity_vector, pose_0);</span><br><span class="line">  // 设置仿真步长为1s</span><br><span class="line">  double delta_t = 1.0;</span><br><span class="line"></span><br><span class="line">  // 设置一个非线性因子图</span><br><span class="line">  NonlinearFactorGraph newgraph;</span><br><span class="line"></span><br><span class="line">  // 声明因子图的初始值和优化结果</span><br><span class="line">  Values initialEstimate, result;</span><br><span class="line"></span><br><span class="line">  // 设置位姿的先验因子</span><br><span class="line">  // 对应到上图中连接到变量x0的一元因子</span><br><span class="line">  // 噪声设置为roll、pitch、yaw有0.1rad的标准差，x，y，z有30cm的标准差</span><br><span class="line">  auto noise = noiseModel::Diagonal::Sigmas(</span><br><span class="line">      (Vector(6) &lt;&lt; Vector3::Constant(0.1), Vector3::Constant(0.3)).finished());</span><br><span class="line">  // 将位姿的先验因子加入因子图中</span><br><span class="line">  newgraph.addPrior(X(0), pose_0, noise);</span><br><span class="line">  // 将位姿0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(X(0), pose_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 设置IMU偏差的先验因子</span><br><span class="line">  // 对应到上图中连接到变量b0的一元因子</span><br><span class="line">  Key biasKey = Symbol(&#x27;b&#x27;, 0);</span><br><span class="line">  auto biasnoise = noiseModel::Diagonal::Sigmas(Vector6::Constant(0.1));</span><br><span class="line">  newgraph.addPrior(biasKey, imuBias::ConstantBias(), biasnoise);</span><br><span class="line">  // 将IMU偏差b0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">  </span><br><span class="line">  // 设置速度的先验因子</span><br><span class="line">  // 对应到上图中连接到变量v0的一元因子</span><br><span class="line">  // 这里设置初始速度为0：Vector3(0,0,0)</span><br><span class="line">  auto velnoise = noiseModel::Diagonal::Sigmas(Vector3(0.01, 0.01, 0.01));</span><br><span class="line">  newgraph.addPrior(V(0), Vector3(0,0,0), velnoise);</span><br><span class="line">  // 将速度v0的初始值加入初始估计集合</span><br><span class="line">  initialEstimate.insert(V(0), Vector3(0,0,0));</span><br><span class="line"></span><br><span class="line">  // IMU 预积分器</span><br><span class="line">  // 设置预积分器的噪声参数，这些噪声参数一般来自IMU的离线标定结果</span><br><span class="line">  auto params = PreintegrationParams::MakeSharedU(kGravity);</span><br><span class="line">  params-&gt;setAccelerometerCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setGyroscopeCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setIntegrationCovariance(I_3x3 * 0.1);</span><br><span class="line">  params-&gt;setUse2ndOrderCoriolis(false);</span><br><span class="line">  params-&gt;setOmegaCoriolis(Vector3(0, 0, 0));</span><br><span class="line">  // 设置IMU预积分器</span><br><span class="line">  PreintegratedImuMeasurements accum(params);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 模仿机器人在运动，这里一共有3个位姿节点0,1,2</span><br><span class="line">  // 在运动过程中模拟IMU预积分，并将IMU因子、IMU偏差因子加入因子图中</span><br><span class="line">  for (size_t i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">    double t = i * delta_t;</span><br><span class="line">    if (i &gt; 0) &#123;  // 设置位姿的初始值，这里是错误示范，使用真值作为初始值设置</span><br><span class="line">      auto pose_i = scenario.pose(t);</span><br><span class="line">      initialEstimate.insert(X(i), pose_i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加IMU因子和IMU偏差因子</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">      // 周期性添加IMU的偏差因子；IMU的偏差需要用其他方式计算，也可以使用离线标定的参数（一般不会）</span><br><span class="line">      if (i % 2 == 0) &#123;</span><br><span class="line">        // b1是上一次的IMU偏差变量的键值；b2是本次IMU偏差的键值</span><br><span class="line">        biasKey++;</span><br><span class="line">        Symbol b1 = biasKey - 1;</span><br><span class="line">        Symbol b2 = biasKey;</span><br><span class="line">        // 添加两个IMU偏差变量之间的二元因子</span><br><span class="line">        Vector6 covvec;</span><br><span class="line">        covvec &lt;&lt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1;</span><br><span class="line">        auto cov = noiseModel::Diagonal::Variances(covvec);</span><br><span class="line">        auto f = std::make_shared&lt;BetweenFactor&lt;imuBias::ConstantBias&gt; &gt;(</span><br><span class="line">            b1, b2, imuBias::ConstantBias(), cov);</span><br><span class="line">        newgraph.add(f);</span><br><span class="line">        // 将当前的IMU偏差变量的初始估计加入初始值集合</span><br><span class="line">        initialEstimate.insert(biasKey, imuBias::ConstantBias());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 这部分才是预积分器进行积分的地方</span><br><span class="line">      // 每次积分接收加速度、角速度以及间隔时间delta_t</span><br><span class="line">      Vector3 measuredAcc = scenario.acceleration_b(t);</span><br><span class="line">      Vector3 measuredOmega = scenario.omega_b(t);</span><br><span class="line">      accum.integrateMeasurement(measuredAcc, measuredOmega, delta_t);</span><br><span class="line"></span><br><span class="line">      // 使用预积分器构建IMU因子，并加入因子图中</span><br><span class="line">      // IMU因子需要指定本次积分的过程连接了哪两个位姿X，速度V以及当前的偏差估计，因此也叫`5-way factor`</span><br><span class="line">      ImuFactor imufac(X(i - 1), V(i - 1), X(i), V(i), biasKey, accum);</span><br><span class="line">      newgraph.add(imufac);</span><br><span class="line"></span><br><span class="line">      // 将速度的初始值加入初始值集合，注意，这里加入的是GroundTruth的速度，只是为了做示例</span><br><span class="line">      initialEstimate.insert(V(i), linear_velocity_vector);</span><br><span class="line">      // 重值IMU预积分器</span><br><span class="line">      accum.resetIntegration();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 使用初始值保存因子图</span><br><span class="line">  newgraph.saveGraph(&quot;ImuFactorsExample2_graphviz.dot&quot;, initialEstimate);</span><br><span class="line">  // 打印到命令行</span><br><span class="line">  newgraph.dot(cout, result);</span><br><span class="line"></span><br><span class="line">  // 调用LM优化器对因子图进行优化并获取优化结果</span><br><span class="line">  result = LevenbergMarquardtOptimizer(newgraph, initialEstimate).optimize();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* ************************************************************************* */</span><br><span class="line"></span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<h3 id="gtsam例子递增式优化">GTSAM例子——递增式优化</h3>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>不仅内置了<code>Gaussian-Newton</code>和<code>Leverberg-Marquat</code>两个常见的非线性优化器，还是实现了<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess08tro.pdf">iSAM</a>和<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a>两个递增式的优化器。 递增式优化器更符合SLAM中常见的使用方式，也就是持续加入新的位姿和约束，并持续进行优化。</p>
<p>这部分内容可以参考<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">GTSAM-Hands-on Introduction</a>——第7章</p>
<p><a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/examples/VisualISAM2Example.cpp">example/VisualISAM2Example.cpp</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置iSAM2优化器</span></span><br><span class="line"><span class="function">ISAM2 <span class="title">isam</span><span class="params">(parameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置因子图和初始值</span></span><br><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">Values initialEstimate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; poses.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; relations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;Pose3&gt;(i, j))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加初始值到初始估计集合</span></span><br><span class="line">  initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>,i), initial_x[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将因子图加入优化器</span></span><br><span class="line">  isam.<span class="built_in">update</span>(graph, initialEstimate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空当前因子图和初始值</span></span><br><span class="line">  <span class="comment">// 因子图已经加入优化器，因此需要清空为下一次因子图做准备</span></span><br><span class="line">  graph.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">  initialEstimate.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="gtsam学习路径">GTSAM学习路径</h2>
<p><a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>对整个SLAM后端问题都封装得很好，因此可以让我们在不了解优化细节的情况下也可以构建自己的优化算法。除了对后端优化和图优化这些知识掌握外，<a target="_blank" rel="noopener" href="https://gtsam.org/" title="gtsam.org">GTSAM</a>的学习主要还是要<code>学以致用</code>， 这里只是简单列出笔者觉得比较合适的资料阅读和学习顺序。</p>
<ol type="1">
<li>本文</li>
<li>GTSAM仓库下<code>doc</code>文件夹中的<a target="_blank" rel="noopener" href="https://github.com/borglab/gtsam/blob/develop/doc/gtsam.pdf">gtsam.pdf</a></li>
<li>GTSAM仓库下<code>examples</code>文件夹中的一些例子，主要是对照上面的文档以及本文出现的例子进行阅读运行</li>
<li>本项目博客中关于<code>ImuPreintegration</code>和<code>MapOptimization</code>的讲解</li>
<li>本项目代码<a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM" title="Simple LIO-SAM">spl</a>中<code>src/mapOptimization.cpp</code>和<code>src/imuPreintegration.cpp</code>代码</li>
</ol>
<h2 id="资料参考">资料参考</h2>
<ol type="1">
<li>对目前各个图优化框架（g2o,GTSAM,ceres,SE-Sync）等做统一分析的综述性论文（强烈建议）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://lamor.fer.hr/images/50036607/2021-ajuric-comparison-mipro.pdf">A Comparison of Graph OptimizationApproaches for Pose Estimation in SLAM</a></p>
<ol start="2" type="1">
<li>Introduction to Bundle Adjustment, ppt</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://vincentqin.gitee.io/blogresource-3/slam-summer-courses-CADCG-Lab/BA-haominLiu.pdf">Bundle Adjustment</a></p>
<ol start="3" type="1">
<li>对基于图的SLAM后端优化算法的讲解，对SLAM的后端问题做比较正式的描述，接近2000引用</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf">A Tutorial on Graph-Based SLAM</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/featureExtraction-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——特征提取模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 20:03:12" itemprop="dateCreated datePublished" datetime="2023-03-22T20:03:12+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-30 21:29:49" itemprop="dateModified" datetime="2023-03-30T21:29:49+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/featureExtraction-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——特征提取模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——特征提取模块" href="/2023/03/22/lio_sam/featureExtraction-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::e84bd67344741c4da21c259e3e444c5d" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><img src="./imgs/Design-Pipelines-feature.png" alt="Pipeline-featureExtraction" /> <a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>、<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法，从原始点云中提取出边缘点和平面点。边缘点和平面点被下游模块用来做点云匹配和构建地图。 特征提取模块是比较简单的模块，只监听来自<code>imageProjection</code>发布出来的去畸变后点云，同时将提取特征后的点云发布出去。这里有几点需要注意：</p>
<ol type="1">
<li>特征点的提取根据点的平滑度，而平滑度则通过每个点与周围点距离的平均值做近似</li>
<li>实际上在提取完边缘点和平面点之后，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>在代码里又把所有非边缘点的点都加入了平面点集合。这是比较奇怪的地方。从这里看出也许特征提取也不是必要的， 因为平面点已经包含了大部分的点云。事实上，在Github的一个仓库<a target="_blank" rel="noopener" href="https://github.com/YJZLuckyBoy/liorf" title="Based LIO-SAM, remove featureExtraction">liorf</a>中，就将特征提取模块去掉。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将该段中除了角点之外的点加入平面点集合</span></span><br><span class="line"><span class="comment">// ！！！ 这点让步骤2感觉是多余的，最终的结果可能只是原始点云降采样，可能特征点提取也是没有必要的！！！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cloudLabel[k] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        surfaceCloudScan-&gt;<span class="built_in">push_back</span>(extractedCloud-&gt;points[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>cloudLabel</code>标识该点的性质，-1为平面点，0为非特征点，1为边缘点。</li>
</ol>
<h2 id="特征点提取原理">特征点提取原理</h2>
<p>关于特征点提取部分<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的论文基本略过，因为跟<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>和<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法基本相同，这里建议这部分可以阅读<a target="_blank" rel="noopener" href="http://www.roboticsproceedings.org/rss10/p07.pdf">LOAM</a>论文。</p>
<h3 id="转换到rangemat">转换到RangeMat</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>沿用<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的做法，先把三维点全部投影到二维图片，图像像素保存每个点距离原点的距离，称做<code>RangeMat</code>，<code>RangeMat</code>是规则的，每一行代表一条激光线束扫射360度所产生的点，因此后面用这个<code>RangeMat</code>做特征提取更快速更简单。 PS：这部分是在<code>ImageProjection</code>就已经处理好，并且<code>RangeMat</code>也被展开成一维向量存储。</p>
<h3 id="平滑度估计">平滑度估计</h3>
<p>特征点提取通过每个点的平滑度来提取，平滑度高于某个阈值的认为是边缘点；平滑度小于某个阈值的认为是平面点。 而平滑度的估计则通过每一个点在该激光线成像的前后几个点的平均距离代替。 我们另时间<span class="math inline">\(t\)</span>的点云为<span class="math inline">\(P_t = \{p_i, i \in |P_t|\}\)</span>，同时我们可以根据每个点的坐标算出每个点距离原点的距离<span class="math inline">\(r_i\)</span>，对于每个点，我们取其同一条激光线上前后5个点构成集合<span class="math inline">\(S\)</span>，则，点<span class="math inline">\(p_i\)</span>的平滑度可以这样计算： <span class="math display">\[
c = \frac{1}{|S|\cdot||r_i||}\left|\left|\sum_{j\in S,j\neq i}(r_j-r_i)\right|\right|
\]</span></p>
<h3 id="分段提取及特征点数量数量限制">分段提取及特征点数量数量限制</h3>
<p>为了让特征点分布更均匀，采用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>，将整个360的图像在水平方向分成6个子图像，在每个子图像中进行特征点提取。并且，对于每一个子图像中的每一条激光线束，会限制边缘点数量不超过20个，平面点的数量则没有限制。</p>
<h3 id="特殊情况">特殊情况</h3>
<p>有3种特殊情况不能将该点设置为边缘点。 1. 当一个点被选择为特征点，则把该点左右5个点都排除在特征点选取范围 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对该角点左右各5个点，如果两点之间的列索引差距小于10，则抛弃周围的点，避免重复对同一块区域提取角点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[ind + l] - cloudInfo.point_col_ind[ind + l + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span> (columnDiff &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>当该点可能是由于遮挡导致被选择为边缘点</li>
</ol>
<figure>
<img src="./imgs/illegal_feature_point.png" alt="" /><figcaption>不合格的特征点(from LOAM)</figcaption>
</figure>
<p>如上图（b）所示，点A是由于被平面遮挡而产生的边缘点，当视角变化后，点A就不再是边缘点。 这个逻辑的判断也是通过点与其周围点的range差距判断。如果是由于遮挡产生的边缘点，则其与左边或者右边会存在距离的图片。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// featureExtraction.cpp&gt;markOccludedPoints</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markOccludedPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cloudSize = extractedCloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 标记被遮挡的点和与激光束平行的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 标记被遮挡的点</span></span><br><span class="line">        <span class="type">float</span> depth1 = cloudInfo.point_range[i];</span><br><span class="line">        <span class="type">float</span> depth2 = cloudInfo.point_range[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> columnDiff = std::<span class="built_in">abs</span>(<span class="built_in">int</span>(cloudInfo.point_col_ind[i+<span class="number">1</span>] - cloudInfo.point_col_ind[i]));</span><br><span class="line">        <span class="comment">// 两个点的列索引相差10个像素之内，认为是同一块区域</span></span><br><span class="line">        <span class="keyword">if</span> (columnDiff &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前点距离大于右点距离0.3米，认为当前点及左边6个点无效</span></span><br><span class="line">            <span class="keyword">if</span> (depth1 - depth2 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前点距离小于右边点距离0.3米，认为右边6个点无效</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (depth2 - depth1 &gt; <span class="number">0.3</span>)&#123;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">                cloudNeighborPicked[i + <span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记平行与激光束的点</span></span><br><span class="line">        <span class="type">float</span> diff1 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i<span class="number">-1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="type">float</span> diff2 = std::<span class="built_in">abs</span>(<span class="built_in">float</span>(cloudInfo.point_range[i+<span class="number">1</span>] - cloudInfo.point_range[i]));</span><br><span class="line">        <span class="comment">// 当前点与左右两点的距离均大于阈值，认为当前点是处于平行面的点</span></span><br><span class="line">        <span class="keyword">if</span> (diff1 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i] &amp;&amp; diff2 &gt; <span class="number">0.02</span> * cloudInfo.point_range[i])</span><br><span class="line">            cloudNeighborPicked[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>当点处于跟激光线平行的平面上时，也可能被认为时边缘点，也需要排除 如上图中的(a)所示，点B位于一个跟激光线较为平行的面上，激光线扫过去，前后几个点的距离差距会很大，因此在处理时可能会被认为是边缘点。这些点也需要做标记，不要设置为边缘点。</li>
</ol>
<h2 id="特征点提取流程">特征点提取流程</h2>
<p>由于这部分代码和原理都比较简单，这里只说一下特征提取的流程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief</span></span><br><span class="line"><span class="comment">* cloudInfo话题的回调函数，这个模块的功能都是顺序进行</span></span><br><span class="line"><span class="comment">* 1. 接收到从imageProjection中发布出的一个去畸变点云信息cloudInfo(自定义格式)</span></span><br><span class="line"><span class="comment">* 2. 对每个点计算曲率。计算时是计算周围点的平均距离用来作为曲率的替代</span></span><br><span class="line"><span class="comment">* 3. 标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="comment">* 4. 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="comment">* 5. 整合信息，发布完整数据包</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param msgIn 从去畸变模块接受的数据包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">laserCloudInfoHandler</span><span class="params">(<span class="type">const</span> spl_lio_sam::msg::CloudInfo::SharedPtr msgIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 缓存全局变量，后面的函数可以直接读取cloudInfo和cloudHeader进行处理</span></span><br><span class="line">cloudInfo = *msgIn;</span><br><span class="line">cloudHeader = msgIn-&gt;header;</span><br><span class="line"><span class="comment">// 把ros2 PointCloud2转成PCL格式，方便后面处理</span></span><br><span class="line">pcl::<span class="built_in">fromROSMsg</span>(msgIn-&gt;cloud_deskewed, *extractedCloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点云每一个点曲率</span></span><br><span class="line"><span class="built_in">calculateSmoothness</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记遮挡点和与激光平行的点，后续这些点不能采纳为特征点</span></span><br><span class="line"><span class="built_in">markOccludedPoints</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征提取。分别做角点（曲率大）和平面点（曲率小）特征点提取</span></span><br><span class="line"><span class="built_in">extractFeatures</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合信息，发布完整数据包</span></span><br><span class="line"><span class="built_in">publishFeatureCloud</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/imageProjection-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/imageProjection-doc/" class="post-title-link" itemprop="url">Simple-LIO-SAM——点云去畸变模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-22 15:55:36" itemprop="dateCreated datePublished" datetime="2023-03-22T15:55:36+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-30 21:30:17" itemprop="dateModified" datetime="2023-03-30T21:30:17+08:00">2023-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/imageProjection-doc/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——点云去畸变模块" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——点云去畸变模块" href="/2023/03/22/lio_sam/imageProjection-doc/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::92a09cadad63fefbcbc8404aeb27c1f1" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总述">总述</h2>
<p><img src="./imgs/Design-Pipelines-image.png" alt="Pipeline-image" /> 点云去畸变模块(imageProjection.cpp文件，文件命名应该是继承了<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>，其实我觉得应该叫做数据预处理模块更合适）主要有以下几个作用</p>
<ol type="1">
<li>去除激光雷达点云的运动畸变</li>
<li>检索每一帧点云对应的IMU输出角度、IMU里程计位姿（发布自ImuPreintegration），以便MapOptimization模块用这些信息作为该帧点云的初始位姿</li>
<li>转换点云格式，计算<code>Range</code>字段，方便特征提取模块进行边缘点、平面点提取</li>
</ol>
<p>总体的流程如下图：</p>
<figure>
<img src="./imgs/Design-imageProjection-pipeline.png" alt="" /><figcaption>pipeline</figcaption>
</figure>
<h2 id="消息订阅及发布">消息订阅及发布</h2>
<figure>
<img src="./imgs/Design-Node%26%26Topics-imageProjection.png" alt="" /><figcaption>消息订阅及发布</figcaption>
</figure>
<h2 id="cloudinfo数据类型">CloudInfo数据类型</h2>
<p>经过去畸变的点云通过<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>自定义的数据格式<code>CloudInfo.msg</code>(Simple-LIO-SAM/msg/CloudInfo.msg)发布；特征提取模块也是将特征点放入这个自定义数据格式发布。 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cloud Info</span></span><br><span class="line"><span class="string">std_msgs/Header</span> <span class="string">header</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在进行点云去畸变时，把range数据展开成一维向量</span></span><br><span class="line"><span class="comment"># ring代表第几条激光线数，比如16线的激光雷达有16个ring</span></span><br><span class="line"><span class="comment"># start_ring_index记录第一个ring在一维向量中的起始索引</span></span><br><span class="line"><span class="comment"># end_ring_index记录第一个ring在一维向量中的结束索引</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">start_ring_index</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">end_ring_index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录一维的Range数据中每一个点在原始range图片中属于那一个列</span></span><br><span class="line"><span class="string">int32[]</span>  <span class="string">point_col_ind</span> <span class="comment"># point column index in range image</span></span><br><span class="line"><span class="comment"># 所有点的range数值，展开为一维数组</span></span><br><span class="line"><span class="string">float32[]</span> <span class="string">point_range</span> <span class="comment"># point range </span></span><br><span class="line"></span><br><span class="line"><span class="string">int64</span> <span class="string">imu_available</span></span><br><span class="line"><span class="string">int64</span> <span class="string">odom_available</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attitude for LOAM initialization</span></span><br><span class="line"><span class="comment"># 从IMU原始数据获取的roll、pitch、yaw角初值</span></span><br><span class="line"><span class="comment"># 当上面的imu_avaliable为true，odom_available为false的时候，会被用来</span></span><br><span class="line"><span class="comment"># 当作这一帧点云的初值</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_roll_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_pitch_init</span></span><br><span class="line"><span class="string">float32</span> <span class="string">imu_yaw_init</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial guess from imu pre-integration</span></span><br><span class="line"><span class="comment"># 从imuPreintegration，IMU预积分模块获取的与这一帧雷达最接近的初始位姿</span></span><br><span class="line"><span class="comment"># 当上面的odom_available标签被置为true的时候会被使用</span></span><br><span class="line"><span class="comment"># 优先级比imu_xxx_init高</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_x</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_y</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_z</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_roll</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_pitch</span></span><br><span class="line"><span class="string">float32</span> <span class="string">initial_guess_yaw</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Point cloud messages</span></span><br><span class="line"><span class="comment"># 去畸变后的原始点云</span></span><br><span class="line"><span class="comment"># 在经过imageProjection模块后，这个数据字段被填充。在经过特征提取之后这个字段被清空</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_deskewed</span> </span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云边缘点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_corner</span></span><br><span class="line"><span class="comment"># featureExtraction模块提取出的点云平面点</span></span><br><span class="line"><span class="string">sensor_msgs/PointCloud2</span> <span class="string">cloud_surface</span></span><br></pre></td></tr></table></figure> 这里主要是前面几个数组类型会比较难理解，主要是要知道在去畸变模块中，将所有点的<code>range</code>信息（也就是点距离雷达的距离）拉成一个一维的数组，即<code>float32[] point_range</code>。 同时，<code>cloud_deskewed</code>里存储的是去完畸变后的点云，里面点的顺序与<code>point_range</code>的顺序是一样的。</p>
<p><code>cloud_corner</code>和<code>cloud_surface</code>两个字段在<code>imageProjection</code>模块中没有被放置数据。特征提取模块会将边缘点、平面点放置在这两个字段中，同时将<code>cloud_deskewed</code>字段清空。</p>
<h2 id="功能解读">功能解读</h2>
<h3 id="imu及imu里程计处理">IMU及IMU里程计处理</h3>
<p>ImageProjection监听IMU原始数据与从ImuPreintegration发布出来的IMU里程计数据，分别由两个回调函数处理，对于IMU原始数据，只是简单地将其旋转到雷达坐标系后塞入缓存队列。 对于IMU历程计，则是直接塞入缓存队列。</p>
<h3 id="去畸变流程">去畸变流程</h3>
<p>一句话说明点云运动畸变校正：根据每一帧点云中每一个点的时间戳，计算该点到该帧点云起始点的旋转平移变换，将每一个点变换到起始点的坐标系。</p>
<p>要注意的是，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中对运动畸变校正只做了旋转校正，没有做平移校正。</p>
<p>去畸变流程发生在点云的回调函数中 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection::cloudHandler</span></span><br><span class="line"><span class="comment">/** 原始雷达点云话题的回调函数，实际上真正做点云处理的函数</span></span><br><span class="line"><span class="comment">    * 实际处理流程是单线程流水线式处理，这个函数后面的所有函数都是为这个函数服务，因此需要了解</span></span><br><span class="line"><span class="comment">    * 点云去畸变的流程。</span></span><br><span class="line"><span class="comment">    * 订阅原始lidar数据</span></span><br><span class="line"><span class="comment">    * 1、转换点云为统一格式，提取点云信息</span></span><br><span class="line"><span class="comment">    *   1）添加一帧激光点云到队列，取出最早一帧作为当前帧</span></span><br><span class="line"><span class="comment">    *   2) 计算起止时间戳，检查数据有效性</span></span><br><span class="line"><span class="comment">    * 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line"><span class="comment">    *   imu数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu数据，初始时刻对应imu的姿态角RPY设为当前帧的初始姿态角</span></span><br><span class="line"><span class="comment">    *   2) 用角速度、时间积分，计算每一时刻相对于初始时刻的旋转量，初始时刻旋转设为0</span></span><br><span class="line"><span class="comment">    *   imu里程计数据：</span></span><br><span class="line"><span class="comment">    *   1) 遍历当前激光帧起止时刻之间的imu里程计数据，初始时刻对应imu里程计设为当前帧的初始位姿</span></span><br><span class="line"><span class="comment">    *   2) 用起始、终止时刻对应imu里程计，计算相对位姿变换，保存平移增量</span></span><br><span class="line"><span class="comment">    * 3、当前帧激光点云运动畸变校正</span></span><br><span class="line"><span class="comment">    *   1) 检查激光点距离、扫描线是否合规</span></span><br><span class="line"><span class="comment">    *   2) 激光运动畸变校正，保存激光点</span></span><br><span class="line"><span class="comment">    * 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line"><span class="comment">    * 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line"><span class="comment">    * 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cloudHandler</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::PointCloud2::SharedPtr laserCloudMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、提取、转换点云为统一格式</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cachePointCloud</span>(laserCloudMsg))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从IMU数据和IMU里程计数据中提取去畸变信息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">deskewInfo</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、当前帧激光点云运动畸变校正</span></span><br><span class="line">    <span class="built_in">projectPointCloud</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、提取有效激光点，集合信息到准备发布的cloud_info数据包</span></span><br><span class="line">    <span class="built_in">cloudExtraction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发布当前帧校正后点云，有效点和其他信息</span></span><br><span class="line">    <span class="built_in">publishClouds</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、重置参数，接收每帧lidar数据都要重置这些参数</span></span><br><span class="line">    <span class="built_in">resetParameters</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>提取、转换点云为统一格式 <img src="./imgs/Design-imageProjection-cachePointCloud.png" alt="提取、转换点云为统一格式" /></p></li>
<li><p>提取去畸变信息 <img src="./imgs/Design-imageProjection-deskewInfo.png" alt="提取去畸变信息" /></p></li>
</ul>
<p>这里有几点要注意 1. 从IMU原始数据计算每一时刻的位姿变换用的是近似算法（因为一帧点云成像时间很短，一般小与100ms） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对角度做积分</span></span><br><span class="line"><span class="comment">// 再次强调，对角速度的积分不是简单的角速度乘以间隔时间</span></span><br><span class="line"><span class="comment">// 关于角速度的积分公式可以查阅：https://zhuanlan.zhihu.com/p/591613108</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> timeDiff;</span><br><span class="line">timeDiff = currentImuTime - imuTime[imuPointerCur<span class="number">-1</span>];</span><br><span class="line">imuRotX[imuPointerCur] = imuRotX[imuPointerCur<span class="number">-1</span>] + angular_x * timeDiff;</span><br><span class="line">imuRotY[imuPointerCur] = imuRotY[imuPointerCur<span class="number">-1</span>] + angular_y * timeDiff;</span><br><span class="line">imuRotZ[imuPointerCur] = imuRotZ[imuPointerCur<span class="number">-1</span>] + angular_z * timeDiff;</span><br><span class="line">imuTime[imuPointerCur] = currentImuTime;</span><br><span class="line">++imuPointerCur;</span><br></pre></td></tr></table></figure> 2. 对于速度较低，角度变化不那么剧烈的行驶系统，即使不做点云畸变校正也没有问题</p>
<ul>
<li><p>对点云做去畸变处理 <img src="./imgs/Design-imageProjection-projectPointCloud.png" alt="对点云做去畸变处理" /></p></li>
<li><p>提取有效点云并集合其他信息 这里主要是将经过去畸变处理后记录下来的有效点进行数据转换，并把各种信息填入准备发布的<code>cloud_info</code>消息中。</p></li>
<li><p>发布点云</p></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">Simple-LIO-SAM——utility文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-22 11:18:09 / 修改时间：21:32:22" itemprop="dateCreated datePublished" datetime="2023-03-22T11:18:09+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——utility文件解读" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——utility文件解读" href="/2023/03/22/lio_sam/utility%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6ed3eebc09d2237963daad43bab3bc96" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<p>这是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>里一个最基础的文件，主要有几个重要功能： 1. 作为所有其他节点的基类，放置所有从配置文件读取的配置字 2. 提供一些实用函数 3. 配置<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a></p>
<h2 id="配置基类">配置基类</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>为了方便配置，把所有节点的配置项都写在同一个文件<code>Simple-LIO-SAM/config/params.yaml</code>，同时构建了一个基类<code>ParamServer</code>统一读取该配置文件，其余模块都从该基类继承。 <img src="./imgs/Design-Class.png" alt="类图" /> 这可能不是最优的方式，不过从实现上来说的确是最简单的。</p>
<p>每个模块的具体配置项后面具体讲解到会逐一解释，目前只需要知道是在哪里配置就行。 <details class="note info no-icon"><summary><p>配置部分代码</p>
</summary>
<figure class="highlight plaintext">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>
</td>
<td class="code">
<pre><span class="line">// Topics</span><br><span class="line">string pointCloudTopic;  // 原始点云数据话题（/points_raw）</span><br><span class="line">string imuTopic;         // 原始IMU数据话题（/imu_correct）</span><br><span class="line">string imuOdomTopic;     // IMU里程计，在imuPreintegration中对IMU做预积分得到（/lio_sam/imu/odometry）</span><br><span class="line">string lidarOdomTopic;   // 雷达里程计，在mapOptimization中得到（/lio_sam/mapping/odometry）</span><br><span class="line">string gpsTopic;         // 原始gps经过robot_localization包计算得到，暂未使用</span><br><span class="line"></span><br><span class="line">// Services</span><br><span class="line">string saveMapSrv;      // 保存地图service地址</span><br><span class="line"></span><br><span class="line">// Frames</span><br><span class="line">string imuFrame;        // IMU数据坐标系，如果IMU和激光雷达坐标系硬件对齐，可以认为IMU、Lidar、Chassis坐标系相同</span><br><span class="line">string lidarFrame;      // 激光雷达坐标系，点云数据坐标系，由激光雷达发布的数据指定。与lidarFrame相同，但是不同雷达有不同的名称</span><br><span class="line">string baseLinkFrame;   // 车辆底盘坐标系</span><br><span class="line">string odomFrame;       // 地图坐标系，在SLAM中一般也是世界坐标系，通常是车辆的起始坐标系</span><br><span class="line"></span><br><span class="line">// GPS Settings</span><br><span class="line">bool useImuHeadingInitialization;</span><br><span class="line">bool useGpsElevation;</span><br><span class="line">float gpsCovThreshold;</span><br><span class="line">float poseCovThreshold;</span><br><span class="line"></span><br><span class="line">// Save pcd</span><br><span class="line">bool savePCD;</span><br><span class="line">string savePCDDirectory;</span><br><span class="line"></span><br><span class="line">// Lidar Sensor Configuration</span><br><span class="line">SensorType sensor;</span><br><span class="line">int N_SCAN;</span><br><span class="line">int Horizon_SCAN;</span><br><span class="line">int downsampleRate;</span><br><span class="line">float lidarMinRange;</span><br><span class="line">float lidarMaxRange;</span><br><span class="line"></span><br><span class="line">// IMU</span><br><span class="line">float imuAccNoise;      // IMU加速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuGyrNoise;      // IMU角速度噪声协方差，可以用Allen方差标定；这里三个轴设为相同的方差</span><br><span class="line">float imuAccBiasN;      // IMU加速度偏差，三轴统一</span><br><span class="line">float imuGyrBiasN;      // IMU角速度偏差，三轴统一</span><br><span class="line">float imuGravity;       // 重力加速度值</span><br><span class="line">float imuRPYWeight;     // 算法中使用IMU的roll、pitch角对激光里程计的结果加权融合</span><br><span class="line">vector&lt;double&gt; extRotV;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extRPYV;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">vector&lt;double&gt; extTransV;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Matrix3d extRot;         // IMU加速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Matrix3d extRPY;         // IMU角速度向量到雷达坐标系的旋转</span><br><span class="line">Eigen::Vector3d extTrans;       // IMU向量到雷达坐标系的平移：P_&#123;lidar&#125; = T * P_&#123;imu&#125;</span><br><span class="line">Eigen::Quaterniond extQRPY;     // IMU角速度向量到雷达坐标系的旋转（四元数形式）</span><br><span class="line"></span><br><span class="line">// LOAM</span><br><span class="line">float edgeThreshold;            // 边缘特征点提取阈值</span><br><span class="line">float surfThreshold;            // 平面特征点提取阈值</span><br><span class="line">int edgeFeatureMinValidNum;     // 边缘特征点数量阈值（default:10)</span><br><span class="line">int surfFeatureMinValidNum;     // 平面特征点数量阈值（default:100)</span><br><span class="line"></span><br><span class="line">// voxel filter paprams</span><br><span class="line">float odometrySurfLeafSize;</span><br><span class="line">float mappingCornerLeafSize;</span><br><span class="line">float mappingSurfLeafSize ;</span><br><span class="line"></span><br><span class="line">float z_tollerance;             // 限制z轴平移的大小</span><br><span class="line">float rotation_tollerance;      // 限制roll、pitch角的大小</span><br><span class="line"></span><br><span class="line">// CPU Params</span><br><span class="line">int numberOfCores;              // 在点云匹配中使用指令集并行加速（default:4）</span><br><span class="line">double mappingProcessInterval;  // 点云帧处理时间间隔（default:0.15s）</span><br><span class="line"></span><br><span class="line">// Surrounding map</span><br><span class="line">float surroundingkeyframeAddingDistThreshold;   // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingkeyframeAddingAngleThreshold;  // 当前帧需要与上一帧距离大于1米或者角度大于0.2度才有可能采纳为关键帧</span><br><span class="line">float surroundingKeyframeDensity;               // 构建局部地图时对采用的关键帧数量做降采样</span><br><span class="line">float surroundingKeyframeSearchRadius;          // 构建局部地图时关键帧的检索半径</span><br><span class="line"></span><br><span class="line">// Loop closure</span><br><span class="line">bool  loopClosureEnableFlag;</span><br><span class="line">float loopClosureFrequency;                     // 回环检测独立线程的执行频率</span><br><span class="line">int   surroundingKeyframeSize;                  // 回环检测构建局部地图的最大关键帧数量</span><br><span class="line">float historyKeyframeSearchRadius;              // 执行回环检测时关键帧的检索半径</span><br><span class="line">float historyKeyframeSearchTimeDiff;            // 执行回环检测时关键帧的检索时间范围</span><br><span class="line">int   historyKeyframeSearchNum;                 // 执行回环检测时融合局部地图时对目标关键帧执行+-25帧的关键帧融合</span><br><span class="line">float historyKeyframeFitnessScore;              // 执行回环检测时使用ICP做点云匹配，阈值大于0.3认为匹配失败，不采纳当前回环检测</span><br><span class="line"></span><br><span class="line">// global map visualization radius</span><br><span class="line">float globalMapVisualizationSearchRadius;</span><br><span class="line">float globalMapVisualizationPoseDensity;</span><br><span class="line">float globalMapVisualizationLeafSize;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details></p>
<h2 id="实用函数">实用函数</h2>
<p>这里主要讲解其中一个<code>imuConverter</code>函数。该函数的功能主要是将<code>IMU</code>的原始数据<strong>旋转到</strong><code>Lidar</code>坐标系。这里要先知道，在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中， 默认将雷达坐标系和小车的坐标系等同为同一个坐标系，同时，这里只做了<strong>旋转</strong>操作，没有做平移操作。代码中有很多处位置都用到这个函数，因此需要理解这个函数到底做了什么。 简单来说这个函数就是做了一个<strong>向量坐标变换</strong>。旋转矩阵操作空间中一个点有两种意义：1）三维旋转；2）坐标变换。这两种不同的操作在做连续的操作时，对应旋转矩阵的左乘和右乘。 由于笔者以前的研究方向是六自由度姿态估计，用三维旋转操作比较多，一开始被这里的<code>矩阵右乘</code>搞蒙了。关于旋转矩阵的左乘和右乘，可以看这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45632220/article/details/117735223">博客</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将原始IMU数据：三轴加速度、三轴角速度、三轴角度，与雷达坐标系进行旋转对齐</span></span><br><span class="line"><span class="comment">+ 对齐之后输出的加速度、角速度、角度的x，y，z就变成雷达坐标系的x，y，z</span></span><br><span class="line"><span class="comment">+ 这里的特殊之处在于允许IMU的加速度、角速度与角度的输出是两个不同的坐标系。但在算法中，角度的输出除了用来做第一帧的初始化和加权融合，似乎没有其他作用</span></span><br><span class="line"><span class="comment">+ 这里是将IMU的三个轴与雷达的三个轴在旋转上做对齐，不能加上平移</span></span><br><span class="line"><span class="comment">+ 对向量做坐标系变换，对多个变换的复合应该是右乘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sensor_msgs::<span class="function">msg::Imu <span class="title">imuConverter</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::Imu&amp; imu_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sensor_msgs::msg::Imu imu_out = imu_in;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对加速度向量做坐标系变换，注意这里要理解成坐标系变换，也就是同一个加速度在IMU坐标系和Lidar坐标系的不同表达。不能想象成对加速度做旋转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">acc</span><span class="params">(imu_in.linear_acceleration.x, imu_in.linear_acceleration.y, imu_in.linear_acceleration.z)</span></span>;</span><br><span class="line">    acc = extRot * acc;</span><br><span class="line">    imu_out.linear_acceleration.x = acc.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.linear_acceleration.y = acc.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.linear_acceleration.z = acc.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角速度做坐标系变换。将IMU坐标系下的向量变换到雷达坐标系。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">gyr</span><span class="params">(imu_in.angular_velocity.x, imu_in.angular_velocity.y, imu_in.angular_velocity.z)</span></span>;</span><br><span class="line">    gyr = extRot * gyr;</span><br><span class="line">    imu_out.angular_velocity.x = gyr.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.angular_velocity.y = gyr.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.angular_velocity.z = gyr.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对角度做坐标系变换。</span></span><br><span class="line"><span class="comment">    + q_from是IMU在全局坐标系下的位姿，q_from: transformation_from_map_to_imu</span></span><br><span class="line"><span class="comment">    + extQRPY如果与extRot对应的话应该是lidar到imu的变换：transformation_from_lidar_to_imu</span></span><br><span class="line"><span class="comment">    + q_final是将雷达点云从雷达坐标系转换到map坐标系的变换，也是：transformation_from_map_to_lidar -&gt; pcd_in_map = q_final * pcd_in_lidar</span></span><br><span class="line"><span class="comment">    + 这里原代码是q_final = q_from * extQRPY；似乎有点问题，还是按照我的推导修改成q_final = q_from * extQRPT.inverse()；由于这里的extQRPY是</span></span><br><span class="line"><span class="comment">    + 直接从配置文件里面读取的，所以这里加不加逆只需要在配置文件里改就行。认为这里有问题的假设是认为extQRPY和extRot的坐标系关系的定义是一致的，也就是</span></span><br><span class="line"><span class="comment">    + 将imu坐标系下的向量转换到雷达坐标系下。如果作者对这两者的定义刚好是相反的，那这里就没有问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Eigen::Quaterniond <span class="title">q_from</span><span class="params">(imu_in.orientation.w, imu_in.orientation.x, imu_in.orientation.y, imu_in.orientation.z)</span></span>;</span><br><span class="line">    Eigen::Quaterniond q_final = q_from * extQRPY.<span class="built_in">inverse</span>();</span><br><span class="line">    imu_out.orientation.x = q_final.<span class="built_in">x</span>();</span><br><span class="line">    imu_out.orientation.y = q_final.<span class="built_in">y</span>();</span><br><span class="line">    imu_out.orientation.z = q_final.<span class="built_in">z</span>();</span><br><span class="line">    imu_out.orientation.w = q_final.<span class="built_in">w</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sqrt</span>(q_final.<span class="built_in">x</span>()*q_final.<span class="built_in">x</span>() + q_final.<span class="built_in">y</span>()*q_final.<span class="built_in">y</span>() + q_final.<span class="built_in">z</span>()*q_final.<span class="built_in">z</span>() + q_final.<span class="built_in">w</span>()*q_final.<span class="built_in">w</span>()) &lt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Invalid quaternion, please use a 9-axis IMU!&quot;</span>);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imu_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="qosquality-of-service">QoS:Quality of Service</h2>
<p>关于ROS2中<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a>的基本介绍，参考官方文档学习。<a target="_blank" rel="noopener" href="https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html" title="Ros2 QoS">QoS</a>的设置中，有两个参数是最重要的。一个是<code>depth</code>，一个是<code>RELIABILITY</code>。<code>depth</code>可以简要理解成中间件DDS为这个消息预留的缓存队列长度。 <code>RELIABILITY</code>主要有两种选项<code>best_effort</code>和<code>reliable</code>，它们的关系类似<code>TCP</code>,<code>UDP</code>。<code>best_effort</code>不能保证每一个消息到到达接收端，但可以保持最好的实时信。<code>reliable</code>保证每一帧消息 都到达接收端，但是无法保证实时性。ROS2中专门为传感器预设了一个<a target="_blank" rel="noopener" href="https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1SensorDataQoS.html">SensorDataQoS</a>，里面采用的就是<code>best_effort</code> 的设置。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>设置了三种<code>QoS</code>，分别为：原始IMU数据、原始雷达数据、框架内部传输</p>
<ol type="1">
<li><p>原始IMU数据QoS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始IMU数据的QOS，因为IMU数据较小，所以depth可以设成较大</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_imu&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">2000</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_imu = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_imu.history,</span><br><span class="line">      qos_profile_imu.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_imu);</span><br></pre></td></tr></table></figure></p></li>
<li><p>原始雷达数据QoS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 原始雷达数据topic的QOS，主要是best_effort和depth起作用</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile_lidar&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">5</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> qos_lidar = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile_lidar.history,</span><br><span class="line">      qos_profile_lidar.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile_lidar);</span><br></pre></td></tr></table></figure></p></li>
<li><p>算法框架内部传输QoS 算法框架内部要求有最高的实时性，并且由于传输中有很多点云类型的数据（较大），因此作者把<code>depth</code>设置为1 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 算法框架中默认的QOS，主要是depth=1和reliability=best_effort起作用。对于传输实时性有要求，不要求每个数据可接收的消息，一般</span></span><br><span class="line"><span class="comment">/// 设成best_effort。在ROS2中对于传感器数据，有一个内置的QOS叫rclcpp::SensorDataQoS()</span></span><br><span class="line"><span class="type">rmw_qos_profile_t</span> qos_profile&#123;</span><br><span class="line">  RMW_QOS_POLICY_HISTORY_KEEP_LAST,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,</span><br><span class="line">  RMW_QOS_POLICY_DURABILITY_VOLATILE,</span><br><span class="line">  RMW_QOS_DEADLINE_DEFAULT,</span><br><span class="line">  RMW_QOS_LIFESPAN_DEFAULT,</span><br><span class="line">  RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,</span><br><span class="line">  RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> qos = rclcpp::<span class="built_in">QoS</span>(</span><br><span class="line">    rclcpp::<span class="built_in">QoSInitialization</span>(</span><br><span class="line">      qos_profile.history,</span><br><span class="line">      qos_profile.depth</span><br><span class="line">    ),</span><br><span class="line">    qos_profile);</span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/" class="post-title-link" itemprop="url">Simple-LIO-SAM——总体流程认识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-16 19:38:59" itemprop="dateCreated datePublished" datetime="2023-03-16T19:38:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-22 21:31:59" itemprop="dateModified" datetime="2023-03-22T21:31:59+08:00">2023-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——总体流程认识" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——总体流程认识" href="/2023/03/16/lio_sam/%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::152660a48ad07f280a45860dc663a523" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="总体流程">总体流程</h2>
<p>话不多说，直接上干货。下图是整理出来的<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>整体运行流程</p>
<figure>
<img src="./imgs/Design-Pipelines.png" alt="" /><figcaption>Pipeline</figcaption>
</figure>
<h3 id="整体认识">整体认识</h3>
<p>所谓的紧耦合，我是这么理解的：IMU本身就可以积分出来一个位姿，连续帧的点云匹配也可以计算出一个位姿，如果两者分别进行，然后再做一个加权融合，那么就属于松耦合。而从上面的框架图也可以看出，<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的融合框架整体呈现一个<code>圈</code>，每个环节都为下一个环节提供信息，最后一个环节又为第一个环节提供信息。同时，耦合之处还在于以下几点： 1. 高频的IMU信息对激光雷达点云做了畸变矫正，做了畸变矫正后的点云被用来做匹配计算激光里程计 2. IMU的积分结果被用来当作该帧点云的初值，为点云匹配提供了较好的初始估计 3. 雷达里程计的结果被用来计算IMU的偏差，同时也被用来持续纠正IMU里程计</p>
<p>虽然<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>框架中还可以融合<code>GPS</code>信息，但是主要还是对雷达点云和IMU信息，因此，可以认为输入是点云和IMU数据，输出是小车当前时刻的位姿，已经对历史时刻位姿的平滑。</p>
<ul>
<li><p>框架的入口是点云去畸变模块，主要的功能就是对激光雷达运动畸变做矫正，然后输出去完畸变的点云。</p></li>
<li><p>去完畸变的点云经过特征提取模块，提取出角特征点和平面特征点，被图优化模块中的点云匹配部分用来做点云匹配。</p></li>
<li><p>图优化模块利用去完畸变后的点云与历史帧构建的局部地图做匹配，得出较准确的里程计结果。同时利用图优化，加入回环检测因子，使得整体估计更为准确顺滑</p></li>
<li><p>IMU预积分模块从IMU和图优化模块接收数据，对IMU的原始数据做积分，得出每一帧点云的初始位姿，提供给图优化模块作为优化初始值。同时又从图优化模块拿出经过点云、图优化校正后的里程计结果校正本身的结果</p></li>
<li><p>坐标系发布主要是为了<code>RIVZ</code>显示中用的，主要就是将各种里程计结果转换成<code>TF</code>坐标关系发布出去。在原始<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中是与<code>imuPreintegration</code>放置在同一个文件</p></li>
</ul>
<h3 id="运动畸变矫正">运动畸变矫正</h3>
<ul>
<li>为什么激光雷达有运动畸变？ 激光雷达通过发射高能量激光线束，计算激光线束往返时间，得到该激光线打到的物体的距离。以机械式激光雷达为例，雷达在统一时刻可以发送多条激光线（32、64、128），这多条激光线在垂直方向上可以扫到三维空间中垂直的一条线，激光雷达通过环绕一周的方式可以对360的空间做三维成像 <img src="./imgs/lidar.webp" alt="lidar" /></li>
</ul>
<p>由于激光雷达是通过激光线束环绕一周的方式成像一帧的点云，那么这一帧点云的点就是在不同的时间探测的。如果激光线束在环绕一周的过程中，激光雷达是在运动的，那么这一帧点云就由于激光雷达的运动而变得不准确，因此需要对其做校正。 <img src="./imgs/livox_lidar_distortion.png" alt="livox_lidar_distortion_removal" /> （上面这幅图片引用自livox官网[Liovox_distortion_removal])</p>
<p>激光雷达输出的每一帧点云<span class="math inline">\(P\)</span>，里面的每一个点<span class="math inline">\(p_i\)</span>，都有一个属性<span class="math inline">\(t_i\)</span>，记录了该点距离该帧点云起始时刻的时间间隔，也就是下面代码段里的<code>time</code>字段。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imageProjection.cpp 49-60</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VelodynePointXYZIRT</span></span><br><span class="line">&#123;</span><br><span class="line">    PCL_ADD_POINT4D</span><br><span class="line">    PCL_ADD_INTENSITY;</span><br><span class="line">    <span class="type">uint16_t</span> ring;</span><br><span class="line">    <span class="type">float</span> time;</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">&#125; EIGEN_ALIGN16;</span><br><span class="line"><span class="built_in">POINT_CLOUD_REGISTER_POINT_STRUCT</span> (VelodynePointXYZIRT,</span><br><span class="line">    (<span class="type">float</span>, x, x) (<span class="type">float</span>, y, y) (<span class="type">float</span>, z, z) (<span class="type">float</span>, intensity, intensity)</span><br><span class="line">    (<span class="type">uint16_t</span>, ring, ring) (<span class="type">float</span>, time, time)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>由于IMU是非常高频的，因此我们可以得出该帧点云成像时间段内的激光雷达位移和旋转的变换，然后通过每一个点的时间<span class="math inline">\(t_i\)</span>，可以根据时间进行插值得出每一个点相对于起始点的转换关系<span class="math inline">\(T_i\)</span>。（注：LIOSAM里面是直接通过时间戳查找，而不是进行插值）。从而，我们就可以将每个点都转换到起始点的坐标系 <span class="math display">\[
p_i^0 = T_ip_i
\]</span></p>
<h3 id="点云特征提取">点云特征提取</h3>
<p>激光里程计中一般会涉及到点云匹配，如果用原始点云进行匹配由于点数过多的关系，会导致耗时太长，因此<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>中用类似<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>的方法进行<code>边缘点</code>,<code>平面点</code>两类特征点的提取，后面点云匹配部分使用这两种特征点进行<code>LM</code>优化求解出匹配关系。</p>
<p>这部分的代码相对简单，后面关于这个模块的详细内容会介绍，这里唯一要清楚的是，这里的点云特征点提取用的是每个点的曲率，选择曲率大的点作为边缘点，选择曲率小的点作为平面点。但是曲率的计算是用每个点周围的点到其平均距离作为近似。</p>
<h3 id="imu预积分模块">IMU预积分模块</h3>
<p>这一个模块虽然从原理和实现上来说稍微有一点点复杂，但是从功能上简单来说只有一个功能，就是实时对<code>IMU原始数据</code>做处理（积分），得到每一个时刻的IMU里程计（也是6自由度位姿），然后该位姿被用来作为该帧点云的初始估计位姿，这个初始估计位姿会被用来作为点云匹配的初始估计。</p>
<h3 id="点云匹配及图优化">点云匹配及图优化</h3>
<p>这是整个框架最复杂的一个模块（也许是没有很好解耦？）。这个模块主要包含了以下几个功能： 1. 点云匹配 2. 回环检测 3. 因子图构建及优化 4. 根据关键帧信息构建全局地图</p>
<p>具体内容会在后面的章节展开，这里应该要有几个感性认识： 1. 一般点云精细匹配（比如ICP算法）需要有一个良好的初始值，这里的初始值可以理解成采用IMU预积分模块的输出。 2. 点云匹配部分用的是沿用自LOAM-&gt;LeGO-LOAM的点云匹配算法，不是使用ICP。<a target="_blank" rel="noopener" href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" title="LeGO-LOAM repo">LeGO-LOAM</a>也是<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan" title="作者Github">TixiaoShan</a>在<a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM" title="liosam仓库">LIOSAM</a>的上一篇相关论文 3. 回环检测根据里程计的x,y,z检索紧邻帧，然后通过ICP算法计算当前帧与近邻帧的转换关系 4. 经过点云匹配后的位姿会经过图优化得出更平滑的位姿 5. 地图和因子图的因子实际上是以关键帧的形态存在后端优化部分，关键帧的选取会比较稀疏，比如距离小与1米不会采用为关键帧。不采用为关键帧的点云会执行完点云匹配后就直接输出位姿。 6. 在有新的回环因子加入因子图后，会进行多次因子图优化器的更新步骤，然后将所有历史关键帧的位姿都更新一遍 7. 这个部分还支持<code>GPS里程计</code>的监听，并将<code>GPS里程计</code>也加入因子图进行优化</p>
<h2 id="坐标系规定">坐标系规定</h2>
<h3 id="坐标系规定-1">坐标系规定</h3>
<p>原有的<code>urdf</code>文件加入了太多额外没必要的关节，导致<code>rviz</code>中<code>tf-tree</code>关系太过复杂。为了简化坐标系关系，但同时又维持坐标系关系标准化并且与<code>ROS</code>的规定相同（<code>ROS</code>中关于姿态估计的坐标系关系主要参考：<a target="_blank" rel="noopener" href="http://docs.ros.org/en/melodic/api/robot_localization/html/preparing_sensor_data.html">robot_localization_coordinate_system</a>，这里对项目中的坐标系关系做了一些简化修改。 根据robot_localization包的规定，所有姿态都要转到世界坐标系，通常是<code>map</code>或者<code>odom</code>坐标系。所有的twist数据，都要转到base_link坐标系下处理。</p>
<h3 id="simple-lio-sam坐标系说明">Simple-LIO-SAM坐标系说明</h3>
<ol type="1">
<li>根据REP资料，一般有4个坐标系<code>earth</code>,<code>map</code>,<code>odom</code>,<code>base_link</code>。由于在SLAM中一般没有引入地球坐标系。所以在这里只有后三个坐标系。 同时，如果是以起始点作为地图原点，<code>map</code>,<code>odom</code>两个坐标系是重合的关系。</li>
<li>另外，为了可以在Rivz显示原始点云信息，则也加入一个雷达坐标系。</li>
<li>为了让坐标系定义自洽，虽然在算法中没有直接用到，但是IMU加速度速度和角速度应该定义在IMU坐标系，因此引入IMU坐标系</li>
<li>为了让定义更为标准，这里保留<code>map</code>坐标系，虽然在SLAM中<code>map</code>,<code>odom</code>大部分情况是重叠的</li>
<li>因此，整个spl_lio_sam框架可以简化成5个坐标系：<code>map</code>, <code>odom</code>,<code>base_link</code>,<code>lidar_link</code>,<code>imu_link</code>坐标系。其中， <code>map</code>是地图原点，在建图时是起始点，在重定位模式时，是地图原点。<code>odom</code>是里程计坐标系；<code>base_link</code>是车辆自身坐标系。<code>lidar_link</code>坐标系是雷达坐标系， 在lio_sam中是与<code>base_link</code>坐标系对齐的，但是<code>lidar_link</code>字段会根据雷达型号不同，被修改。<code>imu_link</code>坐标系是IMU坐标系，配置文件中 有指明IMU坐标系到Lidar坐标系的转换关系。</li>
</ol>
<h3 id="坐标系关系的其他说明">坐标系关系的其他说明</h3>
<ol type="1">
<li>ROS的Message Header只有一个frame_id字段，表明这个数据是在哪个坐标系下的。</li>
<li>nav_msgs/Odometry中还有一个child_frame_id字段，nav_msgs/Odometry中的twist数据应该是在child_frame_id坐标系下的数据 &gt; The twist in this message should be specified in the coordinate frame given by the child_frame_id</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">记一次解决rosbag2内存错误问题过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 18:28:01" itemprop="dateCreated datePublished" datetime="2023-03-15T18:28:01+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/ROS/" itemprop="url" rel="index"><span itemprop="name">ROS</span></a>
        </span>
    </span>

  
    <span id="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="记一次解决rosbag2内存错误问题过程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="记一次解决rosbag2内存错误问题过程" href="/2023/03/15/ros/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3rosbag2%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::73e4783c1a71c1ae17cdb35318885253" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/kai-shi-dong-liao-ge">Zeal's 知乎专栏</a></li>
</ul>
<h2 id="问题背景">问题背景</h2>
<p>由于工作需要，需要开发一个程序，根据记录的信息，从<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>保存的数据包根据打点的时间戳，提取出一段段单独的数据包。 为了存储空间考虑，保存时以及提取时都指定了使用<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#recording-with-compression">压缩的方式</a>进行存储。压缩器和压缩模式如下： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line"><span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>不仅有命令行工具，同时还开放API给开发者使用。<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>还提供了<code>convert</code>功能，可以对录下来的bagfile进行<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">二次提取</a>。因此开发这部分功能可以参考源码里面的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp">bag_rewriter.cpp</a></p>
<h2 id="开发环境">开发环境</h2>
<blockquote>
<p>ROS: ROS2-humble</p>
</blockquote>
<blockquote>
<p>OS: ubuntu 22.04</p>
</blockquote>
<blockquote>
<p>language: cpp17</p>
</blockquote>
<blockquote>
<p>rosbag2: 0.15.4-2jammy.20230118.031755</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p>完成上述数据提取功能后进行测试，发现提取的时候如果同时提取多个目标（构建多个writer，读取message后进行写操作，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L135">rosbag2源码参考部分</a>，并且都进行压缩的时候，会有<code>core dump</code>，错误信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corrupted size vs. prev_size</span><br><span class="line">[ros2run]: Aborted</span><br></pre></td></tr></table></figure></p>
<p>然而在其他情况：1.同时提取多个目标，但是不进行压缩；2.提取一个目标，进行压缩；的时候，程序都可以正常运行</p>
<p>为了确保不是自己编写的程序导致的问题，又使用<code>rosbag2 cli</code>进行类似的尝试。根据<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble#converting-bags">converting-bags</a>的说明，我使用下面的<code>output_options.yaml</code>进行数据转换： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure></p>
<p>然后使用如下命令进行提取 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<p>果不其然，直接使用<code>rosbag2</code>的包也会有<code>core</code>问题，不过报的信息会有区别，不同次运行报的信息还不一样，主要是类似下面这样： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc(): unsorted double linked list corrupted</span><br><span class="line">free(): corrupted unsorted chunks</span><br><span class="line">corrupted double-linked list</span><br></pre></td></tr></table></figure></p>
<h2 id="问题复现">问题复现</h2>
<p>简单起见可以直接使用<code>rosbag2 cli</code>复现这个问题 1. 准备一个ros2的bag包 2. 新建一个配置文件命名为：<code>output_options.yaml</code>，并填入下面内容： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output_bags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag01</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uri:</span> <span class="string">out_bag02</span></span><br><span class="line">  <span class="attr">all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">compression_format:</span> <span class="string">zstd</span></span><br><span class="line">  <span class="attr">compression_mode:</span> <span class="string">message</span></span><br></pre></td></tr></table></figure> 3. 执行数据转换命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">ros2 bag convert -i ./path/to/bag/file -o output_options.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="问题定位">问题定位</h2>
<h3 id="增加日志">增加日志</h3>
<p>由于已经确认不是自己写的程序的问题，所以其实可以跳过这一步 ### gdb检查 cpp程序排查还是需要上gdb，不要自己瞎折腾瞎改代码。<a href="#appendA">文末记录</a>如何在<code>ubuntu</code>上生成<code>core文件</code>。 运行一次程序，生成<code>core文件</code>后使用gdb检查错误堆栈 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ros_ws/install/package/lib/package/excutable /path/to/corefile</span><br><span class="line"></span><br><span class="line">bt  <span class="comment"># gdb命令，打印错误堆栈</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到如下的报错信息</p>
<figure>
<img src="./imgs/backtraces.png" alt="" /><figcaption>backtraces</figcaption>
</figure>
<p>虽然是在子线程中出错，但是大概也能看到是在<code>rosbag2_compression::SequentialCompressonWriter::compression_thread_fn()</code>函数中出错。 这也符合了现象，只在进行压缩的时候会出错。</p>
<p>同时，从错误堆栈里可以看出应该是<code>rosbag2_compression_zstd::ZstdCompressor</code>在进行压缩处理的时候调用<code>rcutils_uint8_array_resize</code>函数出错。</p>
<h3 id="对比不同的writer">对比不同的writer</h3>
<p>由于在进行多个<code>writers</code>写数据，但是不执行压缩的时候并没有相关问题发生，所以可以对比一下普通的<code>writer</code>和<code>SequentialCompressonWriter</code>在写函数中的区别 #### 普通的writer，即rosbag2_cpp::SequentialWriter 普通的<code>writer</code>，即<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/humble/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp">rosbag2_cpp::SequentialWriter</a>中，<code>void SequentialWriter::write(std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>函数比较简单，<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_cpp/src/rosbag2_cpp/writers/sequential_writer.cpp#L328-L337">核心代码</a>是这几行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (storage_options_.max_cache_size == <span class="number">0u</span>) &#123;</span><br><span class="line"><span class="comment">// If cache size is set to zero, we write to storage directly</span></span><br><span class="line">storage_-&gt;<span class="built_in">write</span>(converted_msg);</span><br><span class="line">++topic_information-&gt;message_count;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Otherwise, use cache buffer</span></span><br><span class="line">message_cache_-&gt;<span class="built_in">push</span>(converted_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>bag_rewrite</code>在调用<code>writer</code>的时候，<code>max_cache_size</code>始终<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_transport/src/rosbag2_transport/bag_rewrite.cpp#L191">设置为0</a>，因此执行的是<code>if</code>分支，也就是直接调用底层的数据库封装类直接写入硬盘。</p>
<h4 id="带压缩的writer即rosbag2_compressionsequentialcompressionwriter">带压缩的writer即rosbag2_compression::SequentialCompressionWriter</h4>
<p>带压缩功能的writer这部分的逻辑增加了一个单独线程做压缩处理，函数<code>void SequentialCompressionWriter::write(   std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; message)</code>的核心部分主要是<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L317-L321">这几行</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(compressor_queue_mutex_)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (compressor_message_queue_.<span class="built_in">size</span>() &gt; compression_options_.compression_queue_size) &#123;</span><br><span class="line">    compressor_message_queue_.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">compressor_message_queue_.<span class="built_in">push</span>(message);</span><br><span class="line">compressor_condition_.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>compressor_message_queue_</code>在另一个线程，即函数<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L63">void SequentialCompressionWriter::compression_thread_fn()</a>被处理。 这里面有一个对传入的<code>SerializedMessageSharedPtr</code>对象中的<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/blob/14bf3dcc2170ebe5bd73ed0cf83bb4077b3e36b4/rosbag2_compression/src/rosbag2_compression/sequential_compression_writer.cpp#L96">内存直接进行处理</a></p>
<h4 id="重新查看调用api的代码">重新查看调用API的代码</h4>
<p>调用<code>rosbag2 API</code>进行数据写操作的主要过程如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create rosbag2_storage::StorageOptions</span></span><br><span class="line">rosbag2_storage::StorageOptions storageOptions;</span><br><span class="line"><span class="comment">// create reader</span></span><br><span class="line"><span class="keyword">auto</span> inputReader = rosbag2_transport::ReaderWriterFactory::<span class="built_in">make_reader</span>(storageOptions);</span><br><span class="line"><span class="comment">// open file</span></span><br><span class="line">inputReader-&gt;<span class="built_in">open</span>(storageOptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create multiplt writers</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
<p><strong>可以看到，我们从<code>reader</code>中拿到的<code>SerializedBagMessage</code>是以共享指针的形式使用，当我们把共享指针传给不同的<code>writer</code>时，不同的<code>writer</code>内部同时对同一块内存进行数据压缩处理，因此也就导致了不同线程操作同一块地址空间的错误。</strong></p>
<h2 id="修复">修复</h2>
<p>由于不想更改<code>rosbag2</code>的代码，因此想办法在调用层解决。既然问题共享指针指向的内存被不同线程同时处理，那么我们就在每一次调用<code>writer-&gt;write(nextMsg)</code>的时候对<code>nextMsg</code>执行一次深拷贝，让不同的<code>writer</code>操作不同内存即可。 这里比较复杂的是<code>SerializedBagMessage</code>中使用一个指向<code>rcutils_uint8_array_t</code>的指针对内存进行管理。而<code>rcutils_uint8_array_t</code>里面又使用一个裸<code>uint8_t*</code>指针指向管理的内存。同时<code>rcutils</code>的文档不够详细，也没有提供函数对<code>rcutils_uint8_array_t</code>执行深拷贝操作。不过只要能够明白上面的内存管理关系，修复起来不太困难，关于<code>rcutils_uint8_array_t</code>的操作可以参考<code>rosbag2</code>里面的代码，最终修复的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">...create reader &amp;&amp; writer</span><br><span class="line"><span class="comment">// perform write</span></span><br><span class="line"><span class="keyword">while</span> (inputReader-&gt;<span class="built_in">has_next</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    nextMsg = inputReader-&gt;<span class="built_in">read_next</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; writer : outputWriters):</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;rosbag2_storage::SerializedBagMessage&gt; nextMsg_copy = std::<span class="built_in">make_shared</span>&lt;rosbag2_storage::SerializedBagMessage&gt;();</span><br><span class="line">        <span class="comment">// 新建rcutils_uint8_array_t需要按照下面这样的操作</span></span><br><span class="line">        nextMsg_copy-&gt;serialized_data = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">rcutils_uint8_array_t</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">rcutils_uint8_array_t</span>,</span><br><span class="line">        [](<span class="type">rcutils_uint8_array_t</span> * msg) &#123;</span><br><span class="line">        <span class="keyword">auto</span> fini_return = <span class="built_in">rcutils_uint8_array_fini</span>(msg);</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">        <span class="keyword">if</span> (fini_return != RCUTILS_RET_OK) &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR_STREAM</span>(</span><br><span class="line">            rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rosbag2_cpp&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Failed to destroy serialized message: &quot;</span> &lt;&lt; <span class="built_in">rcutils_get_error_string</span>().str);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建后需要执行内存初始化</span></span><br><span class="line">        <span class="type">rcutils_allocator_t</span> allocator = <span class="built_in">rcutils_get_default_allocator</span>();</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">rcutils_uint8_array_init</span>(</span><br><span class="line">            nextMsg_copy-&gt;serialized_data.<span class="built_in">get</span>(),</span><br><span class="line">            nextMsg-&gt;serialized_data-&gt;buffer_capacity,</span><br><span class="line">            &amp;allocator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span> (ret != RCUTILS_RET_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;Init arrry failed with ret code = %d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制内容</span></span><br><span class="line">        nextMsg_copy-&gt;topic_name = nextMsg-&gt;topic_name;</span><br><span class="line">        nextMsg_copy-&gt;time_stamp = nextMsg-&gt;time_stamp;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_capacity = nextMsg-&gt;serialized_data-&gt;buffer_capacity;</span><br><span class="line">        nextMsg_copy-&gt;serialized_data-&gt;buffer_length = nextMsg-&gt;serialized_data-&gt;buffer_length;</span><br><span class="line">        <span class="comment">// 复制内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)nextMsg_copy-&gt;serialized_data-&gt;buffer,</span><br><span class="line">                (<span class="type">void</span>*)nextMsg-&gt;serialized_data-&gt;buffer, nextMsg-&gt;serialized_data-&gt;buffer_length);</span><br><span class="line">        writer-&gt;<span class="built_in">write</span>(nextMsg_copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<p>这个bug同时提交到<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/tree/humble" title="rosbag2 repo">rosbag2</a>仓库<a target="_blank" rel="noopener" href="https://github.com/ros2/rosbag2/issues/1262">issues中</a>，看看后面有没有机会修复并提交PR</p>
<h2 id="附录aubuntu-core文件生成">附录A：ubuntu core文件生成</h2>
<div id="appendA">

</div>
<ol type="1">
<li><p>ubuntu有一个默认的错误搜集系统apport，必须要关掉之后才能生成core文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service apport status</span><br><span class="line">sudo service apport stop</span><br><span class="line">sudo systemctl apport disble  <span class="comment"># 似乎无法关闭开机启动，每次需要的时候需要手工确认是否关闭</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>设置core文件大小，默认是0，所以不会生成core文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c  <span class="comment"># 若结果是0，则不会生成core文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 不限制core文件大小</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 选择当前使用的终端</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -c unlimited&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></p></li>
<li><p>设置corefile路径(注意，路径必须普通用户可读！） <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /corefile</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /corefile</span><br><span class="line">sysctl -w kernel.core_pattern=/corefile/core-%e-%p-%t</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>CMakeLists.txt加上``Debug模式</code>下不进行编译器优化 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In CMakeLists.txt</span></span><br><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;<span class="variable">$ENV</span>&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb -Wno-unused-parameter&quot;</span>)  </span><br></pre></td></tr></table></figure> 注意在编译<code>ROS2</code>包的时候要指明<code>Debug</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select package_name --cmake-args -DCMAKE_BUILD_TYPE=Debug</span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeal-up.github.io/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zeal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeal's Blog">
      <meta itemprop="description" content="学习记录及分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-title-link" itemprop="url">Simple-LIO-SAM——环境搭建与运行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-14 19:49:06" itemprop="dateCreated datePublished" datetime="2023-03-14T19:49:06+08:00">2023-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-16 18:07:59" itemprop="dateModified" datetime="2023-03-16T18:07:59+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E8%83%BD/SLAM/LIOSAM/" itemprop="url" rel="index"><span itemprop="name">LIOSAM</span></a>
        </span>
    </span>

  
    <span id="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-meta-item leancloud_visitors" data-flag-title="Simple-LIO-SAM——环境搭建与运行" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Simple-LIO-SAM——环境搭建与运行" href="/2023/03/14/lio_sam/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::b824fa070f036b85c958cacd75daa48f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>⭐ <a href="https://zeal-up.github.io/categories/">Zeal's Blog</a></li>
<li>🛠 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1619085291536433152">知乎专栏</a></li>
<li>🌀 <a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">项目仓库</a></li>
</ul>
<h2 id="运行环境搭建">运行环境搭建</h2>
<p>本项目提供基于<code>ROS2-humble</code>的镜像，并提供脚本可直接在镜像中启动可视化程序 ### 数据 本项目同时提供转为<code>rosbag2</code>格式的数据包，<a href="">下载地址</a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATA_DIR=/path/to/download/ros2bag/dir</span><br></pre></td></tr></table></figure> 本项目中默认的配置文件<code>params_default.yaml</code>可以直接运行下面的数据： - park_dataset - walking_dataset - garden_dataset</p>
<h3 id="环境部署">环境部署</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zeal-up/Simple-LIO-SAM.git</span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_run.sh -h  <span class="comment"># show help message</span></span><br><span class="line">./docker_run.sh -c /path/to/code/repo -d <span class="variable">$DATA_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./docker_into.sh  # enter the container next time</span></span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令在镜像中执行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws/</span><br><span class="line"><span class="built_in">mkdir</span> src &amp;&amp; <span class="built_in">cd</span> src &amp;&amp;<span class="built_in">ln</span> -s /home/splsam/codes ./</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">source</span> /opt/ros/humble/setup.bash</span><br><span class="line">colcon build --packages-select spl_lio_sam</span><br></pre></td></tr></table></figure>
<h3 id="运行">运行</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker镜像下运行</span></span><br><span class="line"><span class="built_in">cd</span> ~/ros_ws</span><br><span class="line"><span class="built_in">source</span> ./install/setup.bash</span><br><span class="line">ros2 launch spl_lio_sam run.launch.py </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开终端</span></span><br><span class="line"><span class="built_in">cd</span> Simple-LIO-SAM</span><br><span class="line">./docker_into.sh</span><br><span class="line"><span class="built_in">cd</span> data/ros2/</span><br><span class="line">ros2 bag play ./park_dataset/ --topics /points_raw /imu_raw</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行时画面： <img src="./imgs/runtime.gif" alt="SplRunParkDataset" /></p>
<h2 id="开发环境搭建">开发环境搭建</h2>
<p>由于本项目作者在使用<code>vscode</code>开发<code>c++</code>时经常会遇到无法快捷跳转问题（其实笔者发现有很多人在使用vscode开发时都会有这个问题）， 因此一并把解决方案写入项目中。</p>
<h3 id="vscode-cpp函数快捷跳转">vscode Cpp函数快捷跳转</h3>
<ol type="1">
<li>安装cpp扩展 vscode侧边栏进入扩展选项（ctrl+shift+x)，搜索<code>c++</code>，安装<code>C/C++ Extension Pack</code></li>
<li>打开项目 &gt; File-&gt;Open Folder</li>
<li>保存为工作区 &gt; File-&gt;Save Workspace as 选择目标目录及文件（默认以<code>.code-workspace</code>结尾）</li>
<li>打开刚才保存的工作区文件 &gt; File-&gt;Open File 选择刚才打开的工作区文件</li>
<li>对工作区添加<code>c++</code>库检索路径 在刚才打开的工作区文件中，参考以下格式编辑 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;folders&quot;:</span> [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;path&quot;:</span> <span class="string">&quot;../Simple-LIO-SAM&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;settings&quot;:</span> &#123;</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.includePath&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/**&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/include/c++/9/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/8/include/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/include/**&quot;</span>,</span><br><span class="line"></span><br><span class="line">			<span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">//</span> <span class="string">重点！！这里的路径要设置为ros2工作空间下spl_lio_sam编译出来的头文件</span></span><br><span class="line">			<span class="string">&quot;/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam&quot;</span></span><br><span class="line"></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;C_Cpp.files.exclude&quot;:</span> &#123;</span><br><span class="line">			<span class="string">&quot;**/.vscode&quot;</span><span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">			<span class="string">&quot;**/.vs&quot;</span><span class="string">:</span> <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cStandard&quot;:</span> <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;C_Cpp.default.cppStandard&quot;:</span> <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;python.analysis.include&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.autoComplete.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">&quot;python.analysis.extraPaths&quot;:</span> [</span><br><span class="line">			<span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span>,</span><br><span class="line">		],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="对工作区文件的解释">对工作区文件的解释</h3>
<p>其实主要起作用的是工作区文件中<code>settings-&gt;C_Cpp.default.includePath</code>字段内容，vscode的cpp扩展会读取该工作空间文件下 的这个字段，并将里面的路径进行解析加到头文件解析路径中。</p>
<p>这里有两个路径要注意的</p>
<ol type="1">
<li><code>"$&#123;workspaceFolder&#125;/include"</code>，也就是Simple-LIO-SAM仓库下的include路径</li>
<li><code>"/path/to/ros2_ws/install/spl_lio_sam/include/spl_lio_sam"</code>，这个要设置成你的ros工作空间对应的路径</li>
</ol>
<p>另外，如果发现自己路径设置完成，但是有些函数还提示下划线，要看看是不是那些函数是<code>c++17</code>或者更高的标准才支持的特性，在上面的配置文件中 设置c++/c标准为17</p>
<h3 id="其余注意">其余注意</h3>
<ol type="1">
<li>尽量不要用<code>/path/**</code>的格式添加include路径，虽然看起来很省事，但会影响检索效率</li>
<li>刚设置完路径需要等待vscode检索构建数据库，在vscode右下方状态条会提示正在进行检索</li>
<li>上面配置文件中<code>"python.analysis.extraPaths","python.autoComplete.extraPaths","python.analysis.include"</code>是设置python语法提示器的 库检索路径，不同的python提示器插件会使用不同的路径。</li>
</ol>
<h2 id="reference">Reference</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/TixiaoShan/LIO-SAM">LIO-SAM</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.00258">LIO-SAM paper</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zeal-up/Simple-LIO-SAM">This Project</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chennuo0125-HIT/LIO-SAM-note">LIO-SAM-note</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/smilefacehh/LIO-SAM-DetailedNote">LIO-SAM-DetailedNote</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/archives/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"covS4Q3Q0SaMRjqI2VomagVm-gzGzoHsz","app_key":"iK7kdlu4InjORoPr3oksi1IM","server_url":"https://covs4q3q.lc-cn-n1-shared.com","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywzGuJ0w","appkey":"7c4a236bb42c7db38424a76bf68ccf99","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
